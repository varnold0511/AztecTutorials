import { Fr, FunctionLeafPreimage } from '@aztec/circuits.js';
import { computeFunctionLeaf, hashVK } from '@aztec/circuits.js/abis';
import { FunctionSelector, FunctionType } from '@aztec/foundation/abi';
/**
 * Computes the hash of a hex-encoded string representation of a verification key (vk).
 * The input 'vk' should be a hexadecimal string, and the resulting hash is computed using 'hashVK' function.
 * Returns a Promise that resolves to a Buffer containing the hash of the verification key.
 *
 * @param vk - The hex-encoded string representing the verification key.
 * @returns A Promise resolving to a Buffer containing the hash of the verification key.
 */
export function hashVKStr(vk) {
    // TODO - check consistent encoding
    return hashVK(Buffer.from(vk, 'hex'));
}
/**
 * Determine if the given function is a constructor.
 * This utility function checks if the 'name' property of the input object is "constructor".
 * Returns true if the function is a constructor, false otherwise.
 *
 * @param Object - An object containing a 'name' property.
 * @returns Boolean indicating if the function is a constructor.
 */
export function isConstructor({ name, }) {
    return name === 'constructor';
}
/**
 * @param Object - An object containing function name and type.
 * @returns Boolean indicating if the function is constrained and therefore in the function tree.
 */
export function isConstrained({ name, functionType, }) {
    return functionType !== FunctionType.UNCONSTRAINED && !isConstructor({ name });
}
/**
 * Generate function leaves for the constrained functions in a contract.
 * Only computes leaves for functions that are either secret or open and not constructors.
 * Each function leaf is computed from its selector, privacy flag, hashed verification key, and hashed bytecode.
 *
 * @param functions - Array of ContractFunctionDao objects representing the functions in a contract.
 * @returns An array of Fr instances representing the generated function leaves.
 */
export function generateFunctionLeaves(functions) {
    const targetFunctions = functions.filter(isConstrained);
    const result = [];
    for (let i = 0; i < targetFunctions.length; i++) {
        const f = targetFunctions[i];
        const selector = FunctionSelector.fromNameAndParameters(f.name, f.parameters);
        const isInternal = f.isInternal;
        const isPrivate = f.functionType === FunctionType.SECRET;
        // All non-unconstrained functions have vks
        // TODO we'd need to have a defined length of the VK for this to be computed in noir
        // const vkHash = hashVKStr(f.verificationKey!, wasm);
        const vkHash = Buffer.alloc(32, 0);
        // TODO
        // FIXME: https://github.com/AztecProtocol/aztec3-packages/issues/262
        // const acirHash = keccak(Buffer.from(f.bytecode, 'hex'));
        const acirHash = Buffer.alloc(32, 0);
        const fnLeafPreimage = new FunctionLeafPreimage(selector, isInternal, isPrivate, Fr.fromBuffer(vkHash), Fr.fromBuffer(acirHash));
        const fnLeaf = computeFunctionLeaf(fnLeafPreimage);
        result.push(fnLeaf);
    }
    return result;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29udHJhY3RfdHJlZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9jb250cmFjdC9jb250cmFjdF90cmVlL2NvbnRyYWN0X3RyZWUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUF1QixFQUFFLEVBQWdCLG9CQUFvQixFQUFFLE1BQU0sb0JBQW9CLENBQUM7QUFDakcsT0FBTyxFQUFFLG1CQUFtQixFQUFFLE1BQU0sRUFBRSxNQUFNLHlCQUF5QixDQUFDO0FBQ3RFLE9BQU8sRUFBRSxnQkFBZ0IsRUFBRSxZQUFZLEVBQUUsTUFBTSx1QkFBdUIsQ0FBQztBQUV2RTs7Ozs7OztHQU9HO0FBQ0gsTUFBTSxVQUFVLFNBQVMsQ0FBQyxFQUFVO0lBQ2xDLG1DQUFtQztJQUNuQyxPQUFPLE1BQU0sQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLEVBQUUsRUFBRSxLQUFLLENBQUMsQ0FBQyxDQUFDO0FBQ3hDLENBQUM7QUFFRDs7Ozs7OztHQU9HO0FBQ0gsTUFBTSxVQUFVLGFBQWEsQ0FBQyxFQUM1QixJQUFJLEdBTUw7SUFDQyxPQUFPLElBQUksS0FBSyxhQUFhLENBQUM7QUFDaEMsQ0FBQztBQUVEOzs7R0FHRztBQUNILE1BQU0sVUFBVSxhQUFhLENBQUMsRUFDNUIsSUFBSSxFQUNKLFlBQVksR0FVYjtJQUNDLE9BQU8sWUFBWSxLQUFLLFlBQVksQ0FBQyxhQUFhLElBQUksQ0FBQyxhQUFhLENBQUMsRUFBRSxJQUFJLEVBQUUsQ0FBQyxDQUFDO0FBQ2pGLENBQUM7QUFFRDs7Ozs7OztHQU9HO0FBQ0gsTUFBTSxVQUFVLHNCQUFzQixDQUFDLFNBQWdDO0lBQ3JFLE1BQU0sZUFBZSxHQUFHLFNBQVMsQ0FBQyxNQUFNLENBQUMsYUFBYSxDQUFDLENBQUM7SUFDeEQsTUFBTSxNQUFNLEdBQVMsRUFBRSxDQUFDO0lBQ3hCLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxlQUFlLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxFQUFFO1FBQy9DLE1BQU0sQ0FBQyxHQUFHLGVBQWUsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUM3QixNQUFNLFFBQVEsR0FBRyxnQkFBZ0IsQ0FBQyxxQkFBcUIsQ0FBQyxDQUFDLENBQUMsSUFBSSxFQUFFLENBQUMsQ0FBQyxVQUFVLENBQUMsQ0FBQztRQUM5RSxNQUFNLFVBQVUsR0FBRyxDQUFDLENBQUMsVUFBVSxDQUFDO1FBQ2hDLE1BQU0sU0FBUyxHQUFHLENBQUMsQ0FBQyxZQUFZLEtBQUssWUFBWSxDQUFDLE1BQU0sQ0FBQztRQUN6RCwyQ0FBMkM7UUFDM0Msb0ZBQW9GO1FBQ3BGLHNEQUFzRDtRQUN0RCxNQUFNLE1BQU0sR0FBRyxNQUFNLENBQUMsS0FBSyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQztRQUNuQyxPQUFPO1FBQ1AscUVBQXFFO1FBQ3JFLDJEQUEyRDtRQUMzRCxNQUFNLFFBQVEsR0FBRyxNQUFNLENBQUMsS0FBSyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQztRQUVyQyxNQUFNLGNBQWMsR0FBRyxJQUFJLG9CQUFvQixDQUM3QyxRQUFRLEVBQ1IsVUFBVSxFQUNWLFNBQVMsRUFDVCxFQUFFLENBQUMsVUFBVSxDQUFDLE1BQU0sQ0FBQyxFQUNyQixFQUFFLENBQUMsVUFBVSxDQUFDLFFBQVEsQ0FBQyxDQUN4QixDQUFDO1FBQ0YsTUFBTSxNQUFNLEdBQUcsbUJBQW1CLENBQUMsY0FBYyxDQUFDLENBQUM7UUFDbkQsTUFBTSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQztLQUNyQjtJQUNELE9BQU8sTUFBTSxDQUFDO0FBQ2hCLENBQUMifQ==