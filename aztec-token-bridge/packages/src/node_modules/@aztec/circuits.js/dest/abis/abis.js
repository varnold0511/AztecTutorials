import { AztecAddress } from '@aztec/foundation/aztec-address';
import { padArrayEnd } from '@aztec/foundation/collection';
import { keccak, pedersenHash, pedersenHashBuffer } from '@aztec/foundation/crypto';
import { Fr } from '@aztec/foundation/fields';
import { numToUInt8, numToUInt16BE, numToUInt32BE } from '@aztec/foundation/serialize';
import { Buffer } from 'buffer';
import chunk from 'lodash.chunk';
import { FUNCTION_SELECTOR_NUM_BYTES, FUNCTION_TREE_HEIGHT, GeneratorIndex, PRIVATE_CIRCUIT_PUBLIC_INPUTS_HASH_INPUT_LENGTH, PUBLIC_CIRCUIT_PUBLIC_INPUTS_HASH_INPUT_LENGTH, } from '../constants.gen.js';
import { CompleteAddress, PublicCircuitPublicInputs, VerificationKey, } from '../structs/index.js';
import { boolToBuffer } from '../utils/serialize.js';
import { MerkleTreeCalculator } from './merkle_tree_calculator.js';
/**
 * Computes a hash of a transaction request.
 * @param txRequest - The transaction request.
 * @returns The hash of the transaction request.
 */
export function hashTxRequest(txRequest) {
    return computeTxHash(txRequest).toBuffer();
}
/**
 * Computes a function selector from a given function signature.
 * @param funcSig - The function signature.
 * @returns The function selector.
 */
export function computeFunctionSelector(funcSig) {
    return keccak(Buffer.from(funcSig)).subarray(0, FUNCTION_SELECTOR_NUM_BYTES);
}
/**
 * Computes a hash of a given verification key.
 * @param vkBuf - The verification key.
 * @returns The hash of the verification key.
 */
export function hashVK(vkBuf) {
    const vk = VerificationKey.fromBuffer(vkBuf);
    const toHash = Buffer.concat([
        numToUInt8(vk.circuitType),
        numToUInt16BE(5),
        numToUInt32BE(vk.circuitSize),
        numToUInt32BE(vk.numPublicInputs),
        ...Object.values(vk.commitments)
            .map(e => [e.y.toBuffer(), e.x.toBuffer()])
            .flat(),
        // Montgomery form of fr::one()? Not sure. But if so, why?
        Buffer.from('1418144d5b080fcac24cdb7649bdadf246a6cb2426e324bedb94fb05118f023a', 'hex'),
    ]);
    return pedersenHashBuffer(toHash);
    // barretenberg::evaluation_domain eval_domain = barretenberg::evaluation_domain(circuit_size);
    // std::vector<uint8_t> preimage_data;
    // preimage_data.push_back(static_cast<uint8_t>(proof_system::CircuitType(circuit_type)));
    // const uint256_t domain = eval_domain.domain; // montgomery form of circuit_size
    // const uint256_t generator = eval_domain.generator; //coset_generator(0)
    // const uint256_t public_inputs = num_public_inputs;
    // write(preimage_data, static_cast<uint16_t>(uint256_t(generator))); // maybe 1?
    // write(preimage_data, static_cast<uint32_t>(uint256_t(domain))); // try circuit_size
    // write(preimage_data, static_cast<uint32_t>(public_inputs));
    // for (const auto& [tag, selector] : commitments) {
    //     write(preimage_data, selector.y);
    //     write(preimage_data, selector.x);
    // }
    // write(preimage_data, eval_domain.root);  // fr::one()
    // return crypto::pedersen_hash::hash_buffer(preimage_data, hash_index);
}
/**
 * Computes a function leaf from a given preimage.
 * @param fnLeaf - The function leaf preimage.
 * @returns The function leaf.
 */
export function computeFunctionLeaf(fnLeaf) {
    return Fr.fromBuffer(pedersenHash([
        numToUInt32BE(fnLeaf.functionSelector.value, 32),
        boolToBuffer(fnLeaf.isInternal, 32),
        boolToBuffer(fnLeaf.isPrivate, 32),
        fnLeaf.vkHash.toBuffer(),
        fnLeaf.acirHash.toBuffer(),
    ], GeneratorIndex.FUNCTION_LEAF));
}
let functionTreeRootCalculator;
/**
 * The "zero leaf" of the function tree is the hash of 5 zero fields.
 * TODO: Why can we not just use a zero field as the zero leaf? Complicates things perhaps unnecessarily?
 */
function getFunctionTreeRootCalculator() {
    if (!functionTreeRootCalculator) {
        const functionTreeZeroLeaf = pedersenHash(new Array(5).fill(Buffer.alloc(32)));
        functionTreeRootCalculator = new MerkleTreeCalculator(FUNCTION_TREE_HEIGHT, functionTreeZeroLeaf);
    }
    return functionTreeRootCalculator;
}
/**
 * Computes a function tree from function leaves.
 * @param fnLeaves - The function leaves to be included in the contract function tree.
 * @returns All nodes of the tree.
 */
export function computeFunctionTree(fnLeaves) {
    const leaves = fnLeaves.map(fr => fr.toBuffer());
    return getFunctionTreeRootCalculator()
        .computeTree(leaves)
        .map(b => Fr.fromBuffer(b));
}
/**
 * Computes a function tree root from function leaves.
 * @param fnLeaves - The function leaves to be included in the contract function tree.
 * @returns The function tree root.
 */
export function computeFunctionTreeRoot(fnLeaves) {
    const leaves = fnLeaves.map(fr => fr.toBuffer());
    return Fr.fromBuffer(getFunctionTreeRootCalculator().computeTreeRoot(leaves));
}
/**
 * Computes a constructor hash.
 * @param functionData - Constructor's function data.
 * @param argsHash - Constructor's arguments hashed.
 * @param constructorVKHash - Hash of the constructor's verification key.
 * @returns The constructor hash.
 */
export function hashConstructor(functionData, argsHash, constructorVKHash) {
    return Fr.fromBuffer(pedersenHash([computeFunctionDataHash(functionData).toBuffer(), argsHash.toBuffer(), constructorVKHash], GeneratorIndex.CONSTRUCTOR));
}
/**
 * Computes a complete address.
 * @param deployerPubKey - The pubkey of the contract deployer.
 * @param contractAddrSalt - The salt used as one of the inputs of the contract address computation.
 * @param fnTreeRoot - The function tree root of the contract being deployed.
 * @param constructorHash - The hash of the constructor.
 * @returns The complete address.
 */
export function computeCompleteAddress(deployerPubKey, contractAddrSalt, fnTreeRoot, constructorHash) {
    const partialAddress = computePartialAddress(contractAddrSalt, fnTreeRoot, constructorHash);
    return new CompleteAddress(computeContractAddressFromPartial(deployerPubKey, partialAddress), deployerPubKey, partialAddress);
}
/**
 *
 */
function computePartialAddress(contractAddrSalt, fnTreeRoot, constructorHash) {
    return Fr.fromBuffer(pedersenHash([
        Fr.ZERO.toBuffer(),
        Fr.ZERO.toBuffer(),
        contractAddrSalt.toBuffer(),
        fnTreeRoot.toBuffer(),
        constructorHash.toBuffer(),
    ], GeneratorIndex.PARTIAL_ADDRESS));
}
/**
 * Computes a contract address from its partial address and the pubkey.
 * @param partial - The salt used as one of the inputs of the contract address computation.
 * @param fnTreeRoot - The function tree root of the contract being deployed.
 * @param constructorHash - The hash of the constructor.
 * @returns The partially constructed contract address.
 */
export function computeContractAddressFromPartial(pubKey, partialAddress) {
    const result = pedersenHash([pubKey.x.toBuffer(), pubKey.y.toBuffer(), partialAddress.toBuffer()], GeneratorIndex.CONTRACT_ADDRESS);
    return new AztecAddress(result);
}
/**
 * Computes a commitment nonce, which will be used to create a unique commitment.
 * @param nullifierZero - The first nullifier in the tx.
 * @param commitmentIndex - The index of the commitment.
 * @returns A commitment nonce.
 */
export function computeCommitmentNonce(nullifierZero, commitmentIndex) {
    return Fr.fromBuffer(pedersenHash([nullifierZero.toBuffer(), numToUInt32BE(commitmentIndex, 32)], GeneratorIndex.COMMITMENT_NONCE));
}
/**
 * Computes a siloed commitment, given the contract address and the commitment itself.
 * A siloed commitment effectively namespaces a commitment to a specific contract.
 * @param contract - The contract address
 * @param innerCommitment - The commitment to silo.
 * @returns A siloed commitment.
 */
export function siloCommitment(contract, innerCommitment) {
    return Fr.fromBuffer(pedersenHash([contract.toBuffer(), innerCommitment.toBuffer()], GeneratorIndex.SILOED_COMMITMENT));
}
/**
 * Computes a unique commitment. It includes a nonce which contains data that guarantees the commitment will be unique.
 * @param nonce - The contract address.
 * @param siloedCommitment - An siloed commitment.
 * @returns A unique commitment.
 */
export function computeUniqueCommitment(nonce, siloedCommitment) {
    return Fr.fromBuffer(pedersenHash([nonce.toBuffer(), siloedCommitment.toBuffer()], GeneratorIndex.UNIQUE_COMMITMENT));
}
/**
 * Computes a siloed nullifier, given the contract address and the inner nullifier.
 * A siloed nullifier effectively namespaces a nullifier to a specific contract.
 * @param contract - The contract address.
 * @param innerNullifier - The nullifier to silo.
 * @returns A siloed nullifier.
 */
export function siloNullifier(contract, innerNullifier) {
    return Fr.fromBuffer(pedersenHash([contract.toBuffer(), innerNullifier.toBuffer()], GeneratorIndex.OUTER_NULLIFIER));
}
/**
 * Computes the block hash given the blocks globals and roots.
 * @param globals - The global variables to put into the block hash.
 * @param noteHashTree - The root of the note hash tree.
 * @param nullifierTreeRoot - The root of the nullifier tree.
 * @param contractTreeRoot - The root of the contract tree.
 * @param l1ToL2DataTreeRoot - The root of the l1 to l2 data tree.
 * @param publicDataTreeRoot - The root of the public data tree.
 * @returns The block hash.
 */
export function computeBlockHashWithGlobals(globals, noteHashTreeRoot, nullifierTreeRoot, contractTreeRoot, l1ToL2DataTreeRoot, publicDataTreeRoot) {
    return computeBlockHash(computeGlobalsHash(globals), noteHashTreeRoot, nullifierTreeRoot, contractTreeRoot, l1ToL2DataTreeRoot, publicDataTreeRoot);
}
/**
 * Computes the block hash given the blocks globals and roots.
 * @param globalsHash - The global variables hash to put into the block hash.
 * @param noteHashTree - The root of the note hash tree.
 * @param nullifierTreeRoot - The root of the nullifier tree.
 * @param contractTreeRoot - The root of the contract tree.
 * @param l1ToL2DataTreeRoot - The root of the l1 to l2 data tree.
 * @param publicDataTreeRoot - The root of the public data tree.
 * @returns The block hash.
 */
export function computeBlockHash(globalsHash, noteHashTreeRoot, nullifierTreeRoot, contractTreeRoot, l1ToL2DataTreeRoot, publicDataTreeRoot) {
    return Fr.fromBuffer(pedersenHash([
        globalsHash.toBuffer(),
        noteHashTreeRoot.toBuffer(),
        nullifierTreeRoot.toBuffer(),
        contractTreeRoot.toBuffer(),
        l1ToL2DataTreeRoot.toBuffer(),
        publicDataTreeRoot.toBuffer(),
    ], GeneratorIndex.BLOCK_HASH));
}
/**
 * Computes the globals hash given the globals.
 * @param globals - The global variables to put into the block hash.
 * @returns The globals hash.
 * TODO: move this to GlobalVariables?
 */
export function computeGlobalsHash(globals) {
    return Fr.fromBuffer(pedersenHash([
        globals.chainId.toBuffer(),
        globals.version.toBuffer(),
        globals.blockNumber.toBuffer(),
        globals.timestamp.toBuffer(),
    ], GeneratorIndex.GLOBAL_VARIABLES));
}
/**
 * Computes a public data tree value ready for insertion.
 * @param value - Raw public data tree value to hash into a tree-insertion-ready value.
 * @returns Value hash into a tree-insertion-ready value.

 */
export function computePublicDataTreeValue(value) {
    return value;
}
/**
 * Computes a public data tree index from contract address and storage slot.
 * @param contractAddress - Contract where insertion is occurring.
 * @param storageSlot - Storage slot where insertion is occurring.
 * @returns Public data tree index computed from contract address and storage slot.

 */
export function computePublicDataTreeIndex(contractAddress, storageSlot) {
    return Fr.fromBuffer(pedersenHash([contractAddress.toBuffer(), storageSlot.toBuffer()], GeneratorIndex.PUBLIC_LEAF_INDEX));
}
const ARGS_HASH_CHUNK_SIZE = 32;
const ARGS_HASH_CHUNK_COUNT = 16;
/**
 * Computes the hash of a list of arguments.
 * @param args - Arguments to hash.
 * @returns Pedersen hash of the arguments.
 */
export function computeVarArgsHash(args) {
    if (args.length === 0) {
        return Fr.ZERO;
    }
    if (args.length > ARGS_HASH_CHUNK_SIZE * ARGS_HASH_CHUNK_COUNT) {
        throw new Error(`Cannot hash more than ${ARGS_HASH_CHUNK_SIZE * ARGS_HASH_CHUNK_COUNT} arguments`);
    }
    let chunksHashes = chunk(args, ARGS_HASH_CHUNK_SIZE).map(c => {
        if (c.length < ARGS_HASH_CHUNK_SIZE) {
            c = padArrayEnd(c, Fr.ZERO, ARGS_HASH_CHUNK_SIZE);
        }
        return Fr.fromBuffer(pedersenHash(c.map(a => a.toBuffer()), GeneratorIndex.FUNCTION_ARGS));
    });
    if (chunksHashes.length < ARGS_HASH_CHUNK_COUNT) {
        chunksHashes = padArrayEnd(chunksHashes, Fr.ZERO, ARGS_HASH_CHUNK_COUNT);
    }
    return Fr.fromBuffer(pedersenHash(chunksHashes.map(a => a.toBuffer()), GeneratorIndex.FUNCTION_ARGS));
}
/**
 * Computes a contract leaf of the given contract.
 * @param cd - The contract data of the deployed contract.
 * @returns The contract leaf.
 */
export function computeContractLeaf(cd) {
    if (cd.contractAddress.isZero() && cd.portalContractAddress.isZero() && cd.functionTreeRoot.isZero()) {
        return new Fr(0);
    }
    return Fr.fromBuffer(pedersenHash([cd.contractAddress.toBuffer(), cd.portalContractAddress.toBuffer(), cd.functionTreeRoot.toBuffer()], GeneratorIndex.CONTRACT_LEAF));
}
/**
 * Computes tx hash of a given transaction request.
 * @param txRequest - The signed transaction request.
 * @returns The transaction hash.
 */
export function computeTxHash(txRequest) {
    return Fr.fromBuffer(pedersenHash([
        txRequest.origin.toBuffer(),
        computeFunctionDataHash(txRequest.functionData).toBuffer(),
        txRequest.argsHash.toBuffer(),
        computeTxContextHash(txRequest.txContext).toBuffer(),
    ], GeneratorIndex.TX_REQUEST));
}
/**
 *
 */
function computeFunctionDataHash(functionData) {
    return Fr.fromBuffer(pedersenHash([
        functionData.selector.toBuffer(32),
        new Fr(functionData.isInternal).toBuffer(),
        new Fr(functionData.isPrivate).toBuffer(),
        new Fr(functionData.isConstructor).toBuffer(),
    ], GeneratorIndex.FUNCTION_DATA));
}
/**
 *
 */
function computeTxContextHash(txContext) {
    return Fr.fromBuffer(pedersenHash([
        new Fr(txContext.isFeePaymentTx).toBuffer(),
        new Fr(txContext.isRebatePaymentTx).toBuffer(),
        new Fr(txContext.isContractDeploymentTx).toBuffer(),
        computeContractDeploymentDataHash(txContext.contractDeploymentData).toBuffer(),
        txContext.chainId.toBuffer(),
        txContext.version.toBuffer(),
    ], GeneratorIndex.TX_CONTEXT));
}
/**
 *
 */
function computeContractDeploymentDataHash(data) {
    return Fr.fromBuffer(pedersenHash([
        data.deployerPublicKey.x.toBuffer(),
        data.deployerPublicKey.y.toBuffer(),
        data.constructorVkHash.toBuffer(),
        data.functionTreeRoot.toBuffer(),
        data.contractAddressSalt.toBuffer(),
        data.portalContractAddress.toBuffer(),
    ], GeneratorIndex.CONTRACT_DEPLOYMENT_DATA));
}
/**
 *
 */
function computeCallContextHash(input) {
    return pedersenHash([
        input.msgSender.toBuffer(),
        input.storageContractAddress.toBuffer(),
        input.portalContractAddress.toBuffer(),
        input.functionSelector.toBuffer(),
        boolToBuffer(input.isDelegateCall, 32),
        boolToBuffer(input.isStaticCall, 32),
        boolToBuffer(input.isContractDeployment, 32),
    ], GeneratorIndex.CALL_CONTEXT);
}
/**
 *
 */
function computePrivateInputsHash(input) {
    const toHash = [
        computeCallContextHash(input.callContext),
        input.argsHash.toBuffer(),
        ...input.returnValues.map(fr => fr.toBuffer()),
        ...input.readRequests.map(fr => fr.toBuffer()),
        ...input.pendingReadRequests.map(fr => fr.toBuffer()),
        ...input.newCommitments.map(fr => fr.toBuffer()),
        ...input.newNullifiers.map(fr => fr.toBuffer()),
        ...input.nullifiedCommitments.map(fr => fr.toBuffer()),
        ...input.privateCallStackHashes.map(fr => fr.toBuffer()),
        ...input.publicCallStackHashes.map(fr => fr.toBuffer()),
        ...input.newL2ToL1Msgs.map(fr => fr.toBuffer()),
        ...input.encryptedLogsHash.map(fr => fr.toBuffer()),
        ...input.unencryptedLogsHash.map(fr => fr.toBuffer()),
        input.encryptedLogPreimagesLength.toBuffer(),
        input.unencryptedLogPreimagesLength.toBuffer(),
        input.blockHeader.noteHashTreeRoot.toBuffer(),
        input.blockHeader.nullifierTreeRoot.toBuffer(),
        input.blockHeader.contractTreeRoot.toBuffer(),
        input.blockHeader.l1ToL2MessagesTreeRoot.toBuffer(),
        input.blockHeader.archiveRoot.toBuffer(),
        input.blockHeader.publicDataTreeRoot.toBuffer(),
        input.blockHeader.globalVariablesHash.toBuffer(),
        computeContractDeploymentDataHash(input.contractDeploymentData).toBuffer(),
        input.chainId.toBuffer(),
        input.version.toBuffer(),
    ];
    if (toHash.length != PRIVATE_CIRCUIT_PUBLIC_INPUTS_HASH_INPUT_LENGTH) {
        throw new Error('Incorrect number of input fields when hashing PrivateCircuitPublicInputs');
    }
    return pedersenHash(toHash, GeneratorIndex.PRIVATE_CIRCUIT_PUBLIC_INPUTS);
}
/**
 * Computes a call stack item hash.
 * @param callStackItem - The call stack item.
 * @returns The call stack item hash.
 */
export function computePrivateCallStackItemHash(callStackItem) {
    return Fr.fromBuffer(pedersenHash([
        callStackItem.contractAddress.toBuffer(),
        computeFunctionDataHash(callStackItem.functionData).toBuffer(),
        computePrivateInputsHash(callStackItem.publicInputs),
    ], GeneratorIndex.CALL_STACK_ITEM));
}
/**
 *
 */
function computeContractStorageUpdateRequestHash(input) {
    return pedersenHash([input.storageSlot.toBuffer(), input.oldValue.toBuffer(), input.newValue.toBuffer()], GeneratorIndex.PUBLIC_DATA_UPDATE_REQUEST);
}
/**
 *
 */
function computeContractStorageReadsHash(input) {
    return pedersenHash([input.storageSlot.toBuffer(), input.currentValue.toBuffer()], GeneratorIndex.PUBLIC_DATA_READ);
}
/**
 *
 */
function computePublicInputsHash(input) {
    const toHash = [
        computeCallContextHash(input.callContext),
        input.argsHash.toBuffer(),
        ...input.returnValues.map(fr => fr.toBuffer()),
        ...input.contractStorageUpdateRequests.map(computeContractStorageUpdateRequestHash),
        ...input.contractStorageReads.map(computeContractStorageReadsHash),
        ...input.publicCallStackHashes.map(fr => fr.toBuffer()),
        ...input.newCommitments.map(fr => fr.toBuffer()),
        ...input.newNullifiers.map(fr => fr.toBuffer()),
        ...input.newL2ToL1Msgs.map(fr => fr.toBuffer()),
        ...input.unencryptedLogsHash.map(fr => fr.toBuffer()),
        input.unencryptedLogPreimagesLength.toBuffer(),
        input.blockHeader.noteHashTreeRoot.toBuffer(),
        input.blockHeader.nullifierTreeRoot.toBuffer(),
        input.blockHeader.contractTreeRoot.toBuffer(),
        input.blockHeader.l1ToL2MessagesTreeRoot.toBuffer(),
        input.blockHeader.archiveRoot.toBuffer(),
        input.blockHeader.publicDataTreeRoot.toBuffer(),
        input.blockHeader.globalVariablesHash.toBuffer(),
        input.proverAddress.toBuffer(),
    ];
    if (toHash.length != PUBLIC_CIRCUIT_PUBLIC_INPUTS_HASH_INPUT_LENGTH) {
        throw new Error('Incorrect number of input fields when hashing PublicCircuitPublicInputs');
    }
    return pedersenHash(toHash, GeneratorIndex.PUBLIC_CIRCUIT_PUBLIC_INPUTS);
}
/**
 * Computes a call stack item hash.
 * @param callStackItem - The call stack item.
 * @returns The call stack item hash.
 */
export function computePublicCallStackItemHash({ contractAddress, functionData, publicInputs, isExecutionRequest, }) {
    if (isExecutionRequest) {
        const { callContext, argsHash } = publicInputs;
        publicInputs = PublicCircuitPublicInputs.empty();
        publicInputs.callContext = callContext;
        publicInputs.argsHash = argsHash;
    }
    return Fr.fromBuffer(pedersenHash([
        contractAddress.toBuffer(),
        computeFunctionDataHash(functionData).toBuffer(),
        computePublicInputsHash(publicInputs),
    ], GeneratorIndex.CALL_STACK_ITEM));
}
/**
 * Computes a secret message hash for sending secret l1 to l2 messages.
 * @param secretMessage - The secret message.
 * @returns
 */
export function computeSecretMessageHash(secretMessage) {
    return Fr.fromBuffer(pedersenHash([secretMessage.toBuffer()], GeneratorIndex.L1_TO_L2_MESSAGE_SECRET));
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYWJpcy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9hYmlzL2FiaXMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLFlBQVksRUFBRSxNQUFNLGlDQUFpQyxDQUFDO0FBQy9ELE9BQU8sRUFBRSxXQUFXLEVBQUUsTUFBTSw4QkFBOEIsQ0FBQztBQUMzRCxPQUFPLEVBQUUsTUFBTSxFQUFFLFlBQVksRUFBRSxrQkFBa0IsRUFBRSxNQUFNLDBCQUEwQixDQUFDO0FBQ3BGLE9BQU8sRUFBRSxFQUFFLEVBQUUsTUFBTSwwQkFBMEIsQ0FBQztBQUM5QyxPQUFPLEVBQUUsVUFBVSxFQUFFLGFBQWEsRUFBRSxhQUFhLEVBQUUsTUFBTSw2QkFBNkIsQ0FBQztBQUV2RixPQUFPLEVBQUUsTUFBTSxFQUFFLE1BQU0sUUFBUSxDQUFDO0FBQ2hDLE9BQU8sS0FBSyxNQUFNLGNBQWMsQ0FBQztBQUVqQyxPQUFPLEVBQ0wsMkJBQTJCLEVBQzNCLG9CQUFvQixFQUNwQixjQUFjLEVBQ2QsK0NBQStDLEVBQy9DLDhDQUE4QyxHQUMvQyxNQUFNLHFCQUFxQixDQUFDO0FBQzdCLE9BQU8sRUFFTCxlQUFlLEVBV2YseUJBQXlCLEVBR3pCLGVBQWUsR0FDaEIsTUFBTSxxQkFBcUIsQ0FBQztBQUU3QixPQUFPLEVBQUUsWUFBWSxFQUFFLE1BQU0sdUJBQXVCLENBQUM7QUFDckQsT0FBTyxFQUFFLG9CQUFvQixFQUFFLE1BQU0sNkJBQTZCLENBQUM7QUFFbkU7Ozs7R0FJRztBQUNILE1BQU0sVUFBVSxhQUFhLENBQUMsU0FBb0I7SUFDaEQsT0FBTyxhQUFhLENBQUMsU0FBUyxDQUFDLENBQUMsUUFBUSxFQUFFLENBQUM7QUFDN0MsQ0FBQztBQUVEOzs7O0dBSUc7QUFDSCxNQUFNLFVBQVUsdUJBQXVCLENBQUMsT0FBZTtJQUNyRCxPQUFPLE1BQU0sQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsUUFB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