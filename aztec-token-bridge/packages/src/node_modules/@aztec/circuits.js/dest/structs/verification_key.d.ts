/// <reference types="node" resolution-mode="require"/>
import { BufferReader } from '@aztec/foundation/serialize';
import { Fq } from './index.js';
import { CircuitType } from './shared.js';
/**
 * Curve data.
 */
export declare class G1AffineElement {
    /**
     * Element's x coordinate.
     */
    x: Fq;
    /**
     * Element's y coordinate.
     */
    y: Fq;
    constructor(x: Fq | bigint, y: Fq | bigint);
    /**
     * Serialize as a buffer.
     * @returns The buffer.
     */
    toBuffer(): Buffer;
    /**
     * Deserializes from a buffer or reader, corresponding to a write in cpp.
     * @param buffer - Buffer  or BufferReader to read from.
     * @returns The G1AffineElement.
     */
    static fromBuffer(buffer: Buffer | BufferReader): G1AffineElement;
}
/**
 * Used store and serialize a key-value map of commitments where key is the name of the commitment and value is
 * the commitment itself. The name can be e.g. Q_1, Q_2, SIGMA_1 etc.
 */
export declare class CommitmentMap {
    /**
     * An object used to store the commitments.
     */
    record: {
        [name: string]: G1AffineElement;
    };
    constructor(
    /**
     * An object used to store the commitments.
     */
    record: {
        [name: string]: G1AffineElement;
    });
    /**
     * Serialize as a buffer.
     * @returns The buffer.
     */
    toBuffer(): Buffer;
    /**
     * Deserializes from a buffer or reader, corresponding to a write in cpp.
     * @param buffer - Buffer or BufferReader to read from.
     * @returns The CommitmentMap.
     */
    static fromBuffer(buffer: Buffer | BufferReader): CommitmentMap;
}
/**
 * Kate commitment key object for verifying pairing equations.
 * @see proof_system/verification_key/verification_key.hpp
 */
export declare class VerificationKey {
    /**
     * For Plonk, this is equivalent to the proving system used to prove and verify.
     */
    circuitType: CircuitType;
    /**
     * The number of gates in this circuit.
     */
    circuitSize: number;
    /**
     * The number of public inputs in this circuit.
     */
    numPublicInputs: number;
    /**
     * The commitments for this circuit.
     */
    commitments: Record<string, G1AffineElement>;
    /**
     * Contains a recursive proof?
     */
    containsRecursiveProof: boolean;
    /**
     * Recursion stack.
     */
    recursiveProofPublicInputIndices: number[];
    constructor(
    /**
     * For Plonk, this is equivalent to the proving system used to prove and verify.
     */
    circuitType: CircuitType, 
    /**
     * The number of gates in this circuit.
     */
    circuitSize: number, 
    /**
     * The number of public inputs in this circuit.
     */
    numPublicInputs: number, 
    /**
     * The commitments for this circuit.
     */
    commitments: Record<string, G1AffineElement>, 
    /**
     * Contains a recursive proof?
     */
    containsRecursiveProof: boolean, 
    /**
     * Recursion stack.
     */
    recursiveProofPublicInputIndices: number[]);
    /**
     * Serialize as a buffer.
     * @returns The buffer.
     */
    toBuffer(): Buffer;
    /**
     * Deserializes from a buffer or reader, corresponding to a write in cpp.
     * @param buffer - Buffer to read from.
     * @returns The VerificationKey.
     */
    static fromBuffer(buffer: Buffer | BufferReader): VerificationKey;
    /**
     * Builds a fake verification key that should be accepted by circuits.
     * @returns A fake verification key.
     */
    static makeFake(): VerificationKey;
}
//# sourceMappingURL=verification_key.d.ts.map