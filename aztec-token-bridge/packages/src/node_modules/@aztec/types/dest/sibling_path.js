import { makeTuple } from '@aztec/circuits.js';
import { Fr } from '@aztec/foundation/fields';
import { assertLength, deserializeArrayFromVector, serializeBufferArrayToVector, } from '@aztec/foundation/serialize';
/**
 * Contains functionality to compute and serialize/deserialize a sibling path.
 * E.g. Sibling path for a leaf at index 3 in a tree of depth 3 consists of:
 *      d0:                                            [ root ]
 *      d1:                      [ ]                                               [*]
 *      d2:         [*]                      [ ]                       [ ]                     [ ]
 *      d3:   [ ]         [ ]          [*]         [ ]           [ ]         [ ]          [ ]        [ ].
 *
 *      And the elements would be ordered as: [ leaf_at_index_2, node_at_level_2_index_0, node_at_level_1_index_1 ].
 */
export class SiblingPath {
    /**
     * Returns sibling path hashed up from the a element.
     * @param size - The number of elements in a given path.
     * @param zeroElement - Value of the zero element.
     * @param hasher - Implementation of a hasher interface.
     * @returns A sibling path hashed up from a zero element.
     */
    static ZERO(size, zeroElement, hasher) {
        const bufs = [];
        let current = zeroElement;
        for (let i = 0; i < size; ++i) {
            bufs.push(current);
            current = hasher.hash(current, current);
        }
        return new SiblingPath(size, bufs);
    }
    /**
     * Constructor.
     * @param pathSize - The size of the sibling path.
     * @param path - The sibling path data.
     */
    constructor(
    /**
     * Size of the sibling path (number of fields it contains).
     */
    pathSize, 
    /**
     * The sibling path data.
     */
    path) {
        this.pathSize = pathSize;
        this.data = assertLength(path, pathSize);
    }
    /**
     * Serializes this SiblingPath object to a buffer.
     * @returns The buffer representation of this object.
     */
    toBuffer() {
        return serializeBufferArrayToVector(this.data);
    }
    /**
     * Returns the path buffer underlying the sibling path.
     * @returns The Buffer array representation of this object.
     */
    toBufferArray() {
        return this.data;
    }
    /**
     * Convert the Sibling Path object into an array of field elements.
     * @returns The field array representation of this object.
     */
    toFieldArray() {
        return this.data.map(buf => Fr.fromBuffer(buf));
    }
    /**
     * Convert Sibling Path object into a tuple of field elements.
     * @returns A tuple representation of the sibling path.
     */
    toTuple() {
        const array = this.toFieldArray();
        return makeTuple(array.length, i => array[i], 0);
    }
    /**
     * Deserializes a SiblingPath from a buffer.
     * @param buf - A buffer containing the buffer representation of SiblingPath.
     * @param offset - An offset to start deserializing from.
     * @returns A SiblingPath object.
     */
    static fromBuffer(buf, offset = 0) {
        const { elem } = SiblingPath.deserialize(buf, offset);
        return elem;
    }
    /**
     * Deserializes a SiblingPath object from a slice of a part of a buffer and returns the amount of bytes advanced.
     * @param buf - A buffer representation of the sibling path.
     * @param offset - An offset to start deserializing from.
     * @returns The deserialized sibling path and the number of bytes advanced.
     */
    static deserialize(buf, offset = 0) {
        const deserializePath = (buf, offset) => ({
            elem: buf.slice(offset, offset + 32),
            adv: 32,
        });
        const { elem, adv } = deserializeArrayFromVector(deserializePath, buf, offset);
        const size = elem.length;
        return { elem: new SiblingPath(size, elem), adv };
    }
    /**
     * Serializes this SiblingPath object to a hex string representation.
     * @returns A hex string representation of the sibling path.
     */
    toString() {
        return this.toBuffer().toString('hex');
    }
    /**
     * Deserializes a SiblingPath object from a hex string representation.
     * @param repr - A hex string representation of the sibling path.
     * @returns A SiblingPath object.
     */
    static fromString(repr) {
        return SiblingPath.fromBuffer(Buffer.from(repr, 'hex'));
    }
    /**
     * Generate a subtree path from the current sibling path.
     * @param subtreeHeight - The size of the subtree that we are getting the path for.
     * @returns A new sibling path that is the for the requested subtree.
     */
    getSubtreeSiblingPath(subtreeHeight) {
        // Drop the size of the subtree from the path, and return the rest.
        const subtreeData = this.data.slice(subtreeHeight);
        const subtreePathSize = (this.pathSize - subtreeHeight);
        return new SiblingPath(subtreePathSize, subtreeData);
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2libGluZ19wYXRoLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vc3JjL3NpYmxpbmdfcGF0aC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsU0FBUyxFQUFFLE1BQU0sb0JBQW9CLENBQUM7QUFDL0MsT0FBTyxFQUFFLEVBQUUsRUFBRSxNQUFNLDBCQUEwQixDQUFDO0FBQzlDLE9BQU8sRUFFTCxZQUFZLEVBQ1osMEJBQTBCLEVBQzFCLDRCQUE0QixHQUM3QixNQUFNLDZCQUE2QixDQUFDO0FBSXJDOzs7Ozs7Ozs7R0FTRztBQUNILE1BQU0sT0FBTyxXQUFXO0lBR3RCOzs7Ozs7T0FNRztJQUNJLE1BQU0sQ0FBQyxJQUFJLENBQW1CLElBQU8sRUFBRSxXQUFtQixFQUFFLE1BQWM7UUFDL0UsTUFBTSxJQUFJLEdBQWEsRUFBRSxDQUFDO1FBQzFCLElBQUksT0FBTyxHQUFHLFdBQVcsQ0FBQztRQUMxQixLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsSUFBSSxFQUFFLEVBQUUsQ0FBQyxFQUFFO1lBQzdCLElBQUksQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUM7WUFDbkIsT0FBTyxHQUFHLE1BQU0sQ0FBQyxJQUFJLENBQUMsT0FBTyxFQUFFLE9BQU8sQ0FBQyxDQUFDO1NBQ3pDO1FBQ0QsT0FBTyxJQUFJLFdBQVcsQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLENBQUM7SUFDckMsQ0FBQztJQUVEOzs7O09BSUc7SUFDSDtJQUNFOztPQUVHO0lBQ0ksUUFBVztJQUNsQjs7T0FFRztJQUNILElBQWM7UUFKUCxhQUFRLEdBQVIsUUFBUSxDQUFHO1FBTWxCLElBQUksQ0FBQyxJQUFJLEdBQUcsWUFBWSxDQUFDLElBQUksRUFBRSxRQUFRLENBQUMsQ0FBQztJQUMzQyxDQUFDO0lBRUQ7OztPQUdHO0lBQ0ksUUFBUTtRQUNiLE9BQU8sNEJBQTRCLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO0lBQ2pELENBQUM7SUFFRDs7O09BR0c7SUFDSSxhQUFhO1FBQ2xCLE9BQU8sSUFBSSxDQUFDLElBQUksQ0FBQztJQUNuQixDQUFDO0lBRUQ7OztPQUdHO0lBQ0ksWUFBWTtRQUNqQixPQUFPLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLFVBQVUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO0lBQ2xELENBQUM7SUFFRDs7O09BR0c7SUFDSSxPQUFPO1FBQ1osTUFBTSxLQUFLLEdBQUcsSUFBSSxDQUFDLFlBQVksRUFBRSxDQUFDO1FBQ2xDLE9BQU8sU0FBUyxDQUFDLEtBQUssQ0FBQyxNQUFXLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7SUFDeEQsQ0FBQztJQUVEOzs7OztPQUtHO0lBQ0gsTUFBTSxDQUFDLFVBQVUsQ0FBbUIsR0FBVyxFQUFFLE1BQU0sR0FBRyxDQUFDO1FBQ3pELE1BQU0sRUFBRSxJQUFJLEVBQUUsR0FBRyxXQUFXLENBQUMsV0FBVyxDQUFJLEdBQUcsRUFBRSxNQUFNLENBQUMsQ0FBQztRQUN6RCxPQUFPLElBQUksQ0FBQztJQUNkLENBQUM7SUFFRDs7Ozs7T0FLRztJQUNILE1BQU0sQ0FBQyxXQUFXLENBQW1CLEdBQVcsRUFBRSxNQUFNLEdBQUcsQ0FBQztRQUMxRCxNQUFNLGVBQWUsR0FBRyxDQUFDLEdBQVcsRUFBRSxNQUFjLEVBQUUsRUFBRSxDQUFDLENBQUM7WUFDeEQsSUFBSSxFQUFFLEdBQUcsQ0FBQyxLQUFLLENBQUMsTUFBTSxFQUFFLE1BQU0sR0FBRyxFQUFFLENBQUM7WUFDcEMsR0FBRyxFQUFFLEVBQUU7U0FDUixDQUFDLENBQUM7UUFDSCxNQUFNLEVBQUUsSUFBSSxFQUFFLEdBQUcsRUFBRSxHQUFHLDBCQUEwQixDQUFDLGVBQWUsRUFBRSxHQUFHLEVBQUUsTUFBTSxDQUFDLENBQUM7UUFDL0UsTUFBTSxJQUFJLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQztRQUN6QixPQUFPLEVBQUUsSUFBSSxFQUFFLElBQUksV0FBVyxDQUFJLElBQVMsRUFBRSxJQUFJLENBQUMsRUFBRSxHQUFHLEVBQUUsQ0FBQztJQUM1RCxDQUFDO0lBRUQ7OztPQUdHO0lBQ0ksUUFBUTtRQUNiLE9BQU8sSUFBSSxDQUFDLFFBQVEsRUFBRSxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUN6QyxDQUFDO0lBRUQ7Ozs7T0FJRztJQUNJLE1BQU0sQ0FBQyxVQUFVLENBQW1CLElBQVk7UUFDckQsT0FBTyxXQUFXLENBQUMsVUFBVSxDQUFJLE1BQU0sQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLEtBQUssQ0FBQyxDQUFDLENBQUM7SUFDN0QsQ0FBQztJQUVEOzs7O09BSUc7SUFDSSxxQkFBcUIsQ0FDMUIsYUFBNEI7UUFFNUIsbUVBQW1FO1FBQ25FLE1BQU0sV0FBVyxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLGFBQWEsQ0FBQyxDQUFDO1FBQ25ELE1BQU0sZUFBZSxHQUFHLENBQUMsSUFBSSxDQUFDLFFBQVEsR0FBRyxhQUFhLENBQTZCLENBQUM7UUFDcEYsT0FBTyxJQUFJLFdBQVcsQ0FBQyxlQUFlLEVBQUUsV0FBVyxDQUFDLENBQUM7SUFDdkQsQ0FBQztDQUNGIn0=