/// <reference types="node" resolution-mode="require"/>
import { BufferReader } from '@aztec/circuits.js/utils';
import { AztecAddress } from '@aztec/foundation/aztec-address';
import { EthAddress } from '@aztec/foundation/eth-address';
import { Fr } from '@aztec/foundation/fields';
/**
 * Interface of classes allowing for the retrieval of L1 to L2 messages.
 */
export interface L1ToL2MessageSource {
    /**
     * Gets up to `limit` amount of pending L1 to L2 messages, sorted by fee
     * @param limit - The maximum number of messages to return (by default NUMBER_OF_L1_L2_MESSAGES_PER_ROLLUP).
     * @returns The requested L1 to L2 messages' keys.
     */
    getPendingL1ToL2Messages(limit?: number): Promise<Fr[]>;
    /**
     * Gets the confirmed L1 to L2 message with the given message key.
     * i.e. message that has already been consumed by the sequencer and published in an L2 Block
     * @param messageKey - The message key.
     * @returns The confirmed L1 to L2 message (throws if not found)
     */
    getConfirmedL1ToL2Message(messageKey: Fr): Promise<L1ToL2Message>;
    /**
     * Gets the number of the latest L2 block processed by the implementation.
     * @returns The number of the latest L2 block processed by the implementation.
     */
    getBlockNumber(): Promise<number>;
}
/**
 * L1AndL2Message and Index (in the merkle tree) as one type
 */
export declare class L1ToL2MessageAndIndex {
    /** the index in the L1 to L2 Message tree. */
    readonly index: bigint;
    /** The message. */
    readonly message: L1ToL2Message;
    constructor(
    /** the index in the L1 to L2 Message tree. */
    index: bigint, 
    /** The message. */
    message: L1ToL2Message);
    toBuffer(): Buffer;
    toString(): string;
    static fromString(data: string): L1ToL2MessageAndIndex;
    static fromBuffer(buffer: Buffer | BufferReader): L1ToL2MessageAndIndex;
}
/**
 * An L1 to L2 message emitted in a particular L1 block.
 */
export declare class PendingL1ToL2Message {
    /** the message */
    readonly message: L1ToL2Message;
    /** the L1 block this message was emitted in */
    readonly blockNumber: bigint;
    /** at which index in the L1 block this message was emitted */
    readonly indexInBlock: number;
    constructor(
    /** the message */
    message: L1ToL2Message, 
    /** the L1 block this message was emitted in */
    blockNumber: bigint, 
    /** at which index in the L1 block this message was emitted */
    indexInBlock: number);
}
/**
 * An L1 to L2 message that was cancelled.
 */
export declare class CancelledL1ToL2Message {
    /** the message */
    readonly entryKey: Fr;
    /** the L1 block this message was emitted in */
    readonly blockNumber: bigint;
    /** at which index in the L1 block this message was emitted */
    readonly indexInBlock: number;
    constructor(
    /** the message */
    entryKey: Fr, 
    /** the L1 block this message was emitted in */
    blockNumber: bigint, 
    /** at which index in the L1 block this message was emitted */
    indexInBlock: number);
}
/**
 * The format of an L1 to L2 Message.
 */
export declare class L1ToL2Message {
    /**
     * The sender of the message on L1.
     */
    readonly sender: L1Actor;
    /**
     * The recipient of the message on L2.
     */
    readonly recipient: L2Actor;
    /**
     * The message content.
     */
    readonly content: Fr;
    /**
     * The hash of the spending secret.
     */
    readonly secretHash: Fr;
    /**
     * The deadline for the message.
     */
    readonly deadline: number;
    /**
     * The fee for the message.
     */
    readonly fee: number;
    /**
     * The entry key for the message - optional.
     */
    readonly entryKey?: Fr | undefined;
    constructor(
    /**
     * The sender of the message on L1.
     */
    sender: L1Actor, 
    /**
     * The recipient of the message on L2.
     */
    recipient: L2Actor, 
    /**
     * The message content.
     */
    content: Fr, 
    /**
     * The hash of the spending secret.
     */
    secretHash: Fr, 
    /**
     * The deadline for the message.
     */
    deadline: number, 
    /**
     * The fee for the message.
     */
    fee: number, 
    /**
     * The entry key for the message - optional.
     */
    entryKey?: Fr | undefined);
    /**
     * Returns each element within its own field so that it can be consumed by an acvm oracle call.
     * @returns The message as an array of fields (in order).
     */
    toFieldArray(): Fr[];
    toBuffer(): Buffer;
    static fromBuffer(buffer: Buffer | BufferReader): L1ToL2Message;
    static empty(): L1ToL2Message;
    static random(entryKey?: Fr): L1ToL2Message;
}
/**
 * The sender of an L1 to L2 message.
 */
export declare class L1Actor {
    /**
     * The sender of the message.
     */
    readonly sender: EthAddress;
    /**
     * The chain id on which the message was sent.
     */
    readonly chainId: number;
    constructor(
    /**
     * The sender of the message.
     */
    sender: EthAddress, 
    /**
     * The chain id on which the message was sent.
     */
    chainId: number);
    static empty(): L1Actor;
    toFieldArray(): Fr[];
    toBuffer(): Buffer;
    static fromBuffer(buffer: Buffer | BufferReader): L1Actor;
    static random(): L1Actor;
}
/**
 * The recipient of an L2 message.
 */
export declare class L2Actor {
    /**
     * The recipient of the message.
     */
    readonly recipient: AztecAddress;
    /**
     * The version of the protocol.
     */
    readonly version: number;
    constructor(
    /**
     * The recipient of the message.
     */
    recipient: AztecAddress, 
    /**
     * The version of the protocol.
     */
    version: number);
    static empty(): L2Actor;
    toFieldArray(): Fr[];
    toBuffer(): Buffer;
    static fromBuffer(buffer: Buffer | BufferReader): L2Actor;
    static random(): L2Actor;
}
//# sourceMappingURL=l1_to_l2_message.d.ts.map