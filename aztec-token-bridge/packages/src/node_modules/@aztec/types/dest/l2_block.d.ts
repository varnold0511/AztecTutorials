/// <reference types="node" resolution-mode="require"/>
import { AppendOnlyTreeSnapshot, GlobalVariables } from '@aztec/circuits.js';
import { BufferReader } from '@aztec/circuits.js/utils';
import { Fr } from '@aztec/foundation/fields';
import { ContractData } from './contract_data.js';
import { L2Tx } from './l2_tx.js';
import { LogType, TxL2Logs } from './logs/index.js';
import { L2BlockL2Logs } from './logs/l2_block_l2_logs.js';
import { PublicDataWrite } from './public_data_write.js';
/**
 * The data that makes up the rollup proof, with encoder decoder functions.
 * TODO: Reuse data types and serialization functions from circuits package.
 */
export declare class L2Block {
    #private;
    /**
     * The number of the L2 block.
     */
    number: number;
    /**
     * The global variables for the L2 block.
     */
    globalVariables: GlobalVariables;
    /**
     * The tree snapshot of the note hash tree at the start of the rollup.
     */
    startNoteHashTreeSnapshot: AppendOnlyTreeSnapshot;
    /**
     * The tree snapshot of the nullifier tree at the start of the rollup.
     */
    startNullifierTreeSnapshot: AppendOnlyTreeSnapshot;
    /**
     * The tree snapshot of the contract tree at the start of the rollup.
     */
    startContractTreeSnapshot: AppendOnlyTreeSnapshot;
    /**
     * The tree root of the public data tree at the start of the rollup.
     */
    startPublicDataTreeRoot: Fr;
    /**
     * The tree snapshot of the L2 message tree at the start of the rollup.
     */
    startL1ToL2MessagesTreeSnapshot: AppendOnlyTreeSnapshot;
    /**
     * The tree snapshot of the archive at the start of the rollup.
     */
    startArchiveSnapshot: AppendOnlyTreeSnapshot;
    /**
     * The tree snapshot of the note hash tree at the end of the rollup.
     */
    endNoteHashTreeSnapshot: AppendOnlyTreeSnapshot;
    /**
     * The tree snapshot of the nullifier tree at the end of the rollup.
     */
    endNullifierTreeSnapshot: AppendOnlyTreeSnapshot;
    /**
     * The tree snapshot of the contract tree at the end of the rollup.
     */
    endContractTreeSnapshot: AppendOnlyTreeSnapshot;
    /**
     * The tree root of the public data tree at the end of the rollup.
     */
    endPublicDataTreeRoot: Fr;
    /**
     * The tree snapshot of the L2 message tree at the end of the rollup.
     */
    endL1ToL2MessagesTreeSnapshot: AppendOnlyTreeSnapshot;
    /**
     * The tree snapshot of the archive at the end of the rollup.
     */
    endArchiveSnapshot: AppendOnlyTreeSnapshot;
    /**
     * The commitments to be inserted into the note hash tree.
     */
    newCommitments: Fr[];
    /**
     * The nullifiers to be inserted into the nullifier tree.
     */
    newNullifiers: Fr[];
    /**
     * The public data writes to be inserted into the public data tree.
     */
    newPublicDataWrites: PublicDataWrite[];
    /**
     * The L2 to L1 messages to be inserted into the messagebox on L1.
     */
    newL2ToL1Msgs: Fr[];
    /**
     * The contracts leafs to be inserted into the contract tree.
     */
    newContracts: Fr[];
    /**
     * The aztec address and ethereum address for the deployed contract and its portal contract.
     */
    newContractData: ContractData[];
    /**
     * The L1 to L2 messages to be inserted into the L2 toL2 message tree.
     */
    newL1ToL2Messages: Fr[];
    private blockHash?;
    private static logger;
    /**
     * The number of L2Tx in this L2Block.
     */
    numberOfTxs: number;
    /**
     * Encrypted logs emitted by txs in this block.
     * @remarks `L2BlockL2Logs.txLogs` array has to match number of txs in this block and has to be in the same order
     *          (e.g. logs from the first tx on the first place...).
     * @remarks Only private function can emit encrypted logs and for this reason length of
     *          `newEncryptedLogs.txLogs.functionLogs` is equal to the number of private function invocations in the tx.
     */
    newEncryptedLogs?: L2BlockL2Logs;
    /**
     * Unencrypted logs emitted by txs in this block.
     * @remarks `L2BlockL2Logs.txLogs` array has to match number of txs in this block and has to be in the same order
     *          (e.g. logs from the first tx on the first place...).
     * @remarks Both private and public functions can emit unencrypted logs and for this reason length of
     *          `newUnencryptedLogs.txLogs.functionLogs` is equal to the number of all function invocations in the tx.
     */
    newUnencryptedLogs?: L2BlockL2Logs;
    constructor(
    /**
     * The number of the L2 block.
     */
    number: number, 
    /**
     * The global variables for the L2 block.
     */
    globalVariables: GlobalVariables, 
    /**
     * The tree snapshot of the note hash tree at the start of the rollup.
     */
    startNoteHashTreeSnapshot: AppendOnlyTreeSnapshot, 
    /**
     * The tree snapshot of the nullifier tree at the start of the rollup.
     */
    startNullifierTreeSnapshot: AppendOnlyTreeSnapshot, 
    /**
     * The tree snapshot of the contract tree at the start of the rollup.
     */
    startContractTreeSnapshot: AppendOnlyTreeSnapshot, 
    /**
     * The tree root of the public data tree at the start of the rollup.
     */
    startPublicDataTreeRoot: Fr, 
    /**
     * The tree snapshot of the L2 message tree at the start of the rollup.
     */
    startL1ToL2MessagesTreeSnapshot: AppendOnlyTreeSnapshot, 
    /**
     * The tree snapshot of the archive at the start of the rollup.
     */
    startArchiveSnapshot: AppendOnlyTreeSnapshot, 
    /**
     * The tree snapshot of the note hash tree at the end of the rollup.
     */
    endNoteHashTreeSnapshot: AppendOnlyTreeSnapshot, 
    /**
     * The tree snapshot of the nullifier tree at the end of the rollup.
     */
    endNullifierTreeSnapshot: AppendOnlyTreeSnapshot, 
    /**
     * The tree snapshot of the contract tree at the end of the rollup.
     */
    endContractTreeSnapshot: AppendOnlyTreeSnapshot, 
    /**
     * The tree root of the public data tree at the end of the rollup.
     */
    endPublicDataTreeRoot: Fr, 
    /**
     * The tree snapshot of the L2 message tree at the end of the rollup.
     */
    endL1ToL2MessagesTreeSnapshot: AppendOnlyTreeSnapshot, 
    /**
     * The tree snapshot of the archive at the end of the rollup.
     */
    endArchiveSnapshot: AppendOnlyTreeSnapshot, 
    /**
     * The commitments to be inserted into the note hash tree.
     */
    newCommitments: Fr[], 
    /**
     * The nullifiers to be inserted into the nullifier tree.
     */
    newNullifiers: Fr[], 
    /**
     * The public data writes to be inserted into the public data tree.
     */
    newPublicDataWrites: PublicDataWrite[], 
    /**
     * The L2 to L1 messages to be inserted into the messagebox on L1.
     */
    newL2ToL1Msgs: Fr[], 
    /**
     * The contracts leafs to be inserted into the contract tree.
     */
    newContracts: Fr[], 
    /**
     * The aztec address and ethereum address for the deployed contract and its portal contract.
     */
    newContractData: ContractData[], 
    /**
     * The L1 to L2 messages to be inserted into the L2 toL2 message tree.
     */
    newL1ToL2Messages?: Fr[], newEncryptedLogs?: L2BlockL2Logs, newUnencryptedLogs?: L2BlockL2Logs, blockHash?: Buffer | undefined, l1BlockNumber?: bigint);
    /**
     * Creates an L2 block containing random data.
     * @param l2BlockNum - The number of the L2 block.
     * @param txsPerBlock - The number of transactions to include in the block.
     * @param numPrivateCallsPerTx - The number of private function calls to include in each transaction.
     * @param numPublicCallsPerTx - The number of public function calls to include in each transaction.
     * @param numEncryptedLogsPerCall - The number of encrypted logs per 1 private function invocation.
     * @param numUnencryptedLogsPerCall - The number of unencrypted logs per 1 public function invocation.
     * @returns The L2 block.
     */
    static random(l2BlockNum: number, txsPerBlock?: number, numPrivateCallsPerTx?: number, numPublicCallsPerTx?: number, numEncryptedLogsPerCall?: number, numUnencryptedLogsPerCall?: number): L2Block;
    /**
     * Constructs a new instance from named fields.
     * @param fields - Fields to pass to the constructor.
     * @param blockHash - Hash of the block.
     * @param l1BlockNumber - The block number of the L1 block that contains this L2 block.
     * @returns A new instance.
     */
    static fromFields(fields: {
        /**
         * The number of the L2 block.
         */
        number: number;
        /**
         * The global variables of the L2 block.
         */
        globalVariables: GlobalVariables;
        /**
         * The tree snapshot of the note hash tree at the start of the rollup.
         */
        startNoteHashTreeSnapshot: AppendOnlyTreeSnapshot;
        /**
         * The tree snapshot of the nullifier tree at the start of the rollup.
         */
        startNullifierTreeSnapshot: AppendOnlyTreeSnapshot;
        /**
         * The tree snapshot of the contract tree at the start of the rollup.
         */
        startContractTreeSnapshot: AppendOnlyTreeSnapshot;
        /**
         * The tree root of the public data tree at the start of the rollup.
         */
        startPublicDataTreeRoot: Fr;
        /**
         * The tree snapshot of the L2 message tree at the start of the rollup.
         */
        startL1ToL2MessagesTreeSnapshot: AppendOnlyTreeSnapshot;
        /**
         * The tree snapshot of the archive at the start of the rollup.
         */
        startArchiveSnapshot: AppendOnlyTreeSnapshot;
        /**
         * The tree snapshot of the note hash tree at the end of the rollup.
         */
        endNoteHashTreeSnapshot: AppendOnlyTreeSnapshot;
        /**
         * The tree snapshot of the nullifier tree at the end of the rollup.
         */
        endNullifierTreeSnapshot: AppendOnlyTreeSnapshot;
        /**
         * The tree snapshot of the contract tree at the end of the rollup.
         */
        endContractTreeSnapshot: AppendOnlyTreeSnapshot;
        /**
         * The tree root of the public data tree at the end of the rollup.
         */
        endPublicDataTreeRoot: Fr;
        /**
         * The tree snapshot of the L2 message tree at the end of the rollup.
         */
        endL1ToL2MessagesTreeSnapshot: AppendOnlyTreeSnapshot;
        /**
         * The tree snapshot of the archive at the end of the rollup.
         */
        endArchiveSnapshot: AppendOnlyTreeSnapshot;
        /**
         * The commitments to be inserted into the note hash tree.
         */
        newCommitments: Fr[];
        /**
         * The nullifiers to be inserted into the nullifier tree.
         */
        newNullifiers: Fr[];
        /**
         * The public data writes to be inserted into the public data tree.
         */
        newPublicDataWrites: PublicDataWrite[];
        /**
         * The L2 to L1 messages to be inserted into the messagebox on L1.
         */
        newL2ToL1Msgs: Fr[];
        /**
         * The contracts leafs to be inserted into the contract tree.
         */
        newContracts: Fr[];
        /**
         * The aztec address and ethereum address for the deployed contract and its portal contract.
         */
        newContractData: ContractData[];
        /**
         * The L1 to L2 messages to be inserted into the L2 toL2 message tree.
         */
        newL1ToL2Messages: Fr[];
        /**
         * Encrypted logs emitted by txs in a block.
         */
        newEncryptedLogs?: L2BlockL2Logs;
        /**
         * Unencrypted logs emitted by txs in a block.
         */
        newUnencryptedLogs?: L2BlockL2Logs;
    }, blockHash?: Buffer, l1BlockNumber?: bigint): L2Block;
    /**
     * Serializes a block without logs to a buffer.
     * @remarks This is used when the block is being served via JSON-RPC because the logs are expected to be served
     * separately.
     * @returns A serialized L2 block without logs.
     */
    toBuffer(): Buffer;
    /**
     * Serializes a block with logs to a buffer.
     * @remarks This is used when the block is being submitted on L1.
     * @returns A serialized L2 block with logs.
     */
    toBufferWithLogs(): Buffer;
    /**
     * Serializes a block without logs to a string.
     * @remarks This is used when the block is being served via JSON-RPC because the logs are expected to be served
     * separately.
     * @returns A serialized L2 block without logs.
     */
    toString(): string;
    /**
     * Deserializes L2 block without logs from a buffer.
     * @param buf - A serialized L2 block.
     * @returns Deserialized L2 block.
     */
    static fromBuffer(buf: Buffer | BufferReader): L2Block;
    /**
     * Deserializes L2 block with logs from a buffer.
     * @param buf - A serialized L2 block.
     * @returns Deserialized L2 block.
     */
    static fromBufferWithLogs(buf: Buffer | BufferReader): L2Block;
    /**
     * Deserializes L2 block without logs from a buffer.
     * @param str - A serialized L2 block.
     * @returns Deserialized L2 block.
     */
    static fromString(str: string): L2Block;
    /**
     * Helper function to attach logs related to a block.
     * @param logs - The logs to be attached to a block.
     * @param logType - The type of logs to be attached.
     * @remarks Here, because we can have L2 blocks without logs and those logs can be attached later.
     */
    attachLogs(logs: L2BlockL2Logs, logType: LogType): void;
    /**
     * Sets the L1 block number that included this block
     * @param l1BlockNumber - The block number of the L1 block that contains this L2 block.
     */
    setL1BlockNumber(l1BlockNumber: bigint): void;
    /**
     * Gets the L1 block number that included this block
     */
    getL1BlockNumber(): bigint;
    /**
     * Returns the block's hash.
     * @returns The block's hash.
     */
    getBlockHash(): Buffer;
    /**
     * Computes the public inputs hash for the L2 block.
     * The same output as the hash of RootRollupPublicInputs.
     * @returns The public input hash for the L2 block as a field element.
     */
    getPublicInputsHash(): Fr;
    /**
     * Computes the start state hash (should equal contract data before block).
     * @returns The start state hash for the L2 block.
     */
    getStartStateHash(): Buffer;
    /**
     * Computes the end state hash (should equal contract data after block).
     * @returns The end state hash for the L2 block.
     */
    getEndStateHash(): Buffer;
    /**
     * Computes the calldata hash for the L2 block
     * This calldata hash is also computed by the rollup contract when the block is submitted,
     * and inside the circuit, it is part of the public inputs.
     * @returns The calldata hash.
     */
    getCalldataHash(): Buffer;
    /**
     * Compute the hash of all of this blocks l1 to l2 messages,
     * The hash is also calculated within the contract when the block is submitted.
     * @returns The hash of all of the l1 to l2 messages.
     */
    getL1ToL2MessagesHash(): Buffer;
    /**
     * Get the ith transaction in an L2 block.
     * @param txIndex - The index of the tx in the block.
     * @returns The tx.
     */
    getTx(txIndex: number): L2Tx;
    /**
     * Get all the transaction in an L2 block.
     * @returns The tx.
     */
    getTxs(): L2Tx[];
    /**
     * Returns stats used for logging.
     * @returns Stats on tx count, number, and log size and count.
     */
    getStats(): {
        unencryptedLogCount?: number | undefined;
        unencryptedLogSize?: number | undefined;
        encryptedLogCount?: number | undefined;
        encryptedLogSize?: number | undefined;
        txCount: number;
        blockNumber: number;
    };
    /**
     * Inspect for debugging purposes..
     * @param maxBufferSize - The number of bytes to be extracted from buffer.
     * @returns A human-friendly string representation of the l2Block.
     */
    inspect(maxBufferSize?: number): string;
    /**
     * Computes logs hash as is done in the kernel and app circuits.
     * @param logs - Logs to be hashed.
     * @returns The hash of the logs.
     * Note: This is a TS implementation of `computeKernelLogsHash` function in Decoder.sol. See that function documentation
     *       for more details.
     */
    static computeKernelLogsHash(logs: TxL2Logs): Buffer;
}
//# sourceMappingURL=l2_block.d.ts.map