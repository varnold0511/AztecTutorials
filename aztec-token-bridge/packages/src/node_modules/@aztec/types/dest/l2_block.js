var _L2Block_l1BlockNumber;
import { __classPrivateFieldGet, __classPrivateFieldSet } from "tslib";
import { AppendOnlyTreeSnapshot, GlobalVariables, MAX_NEW_COMMITMENTS_PER_TX, MAX_NEW_CONTRACTS_PER_TX, MAX_NEW_L2_TO_L1_MSGS_PER_TX, MAX_NEW_NULLIFIERS_PER_TX, MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_TX, NUMBER_OF_L1_L2_MESSAGES_PER_ROLLUP, STRING_ENCODING, } from '@aztec/circuits.js';
import { makeAppendOnlyTreeSnapshot, makeGlobalVariables } from '@aztec/circuits.js/factories';
import { BufferReader, serializeToBuffer } from '@aztec/circuits.js/utils';
import { keccak, sha256 } from '@aztec/foundation/crypto';
import { Fr } from '@aztec/foundation/fields';
import { createDebugLogger } from '@aztec/foundation/log';
import times from 'lodash.times';
import { ContractData } from './contract_data.js';
import { L2Tx } from './l2_tx.js';
import { LogType } from './logs/index.js';
import { L2BlockL2Logs } from './logs/l2_block_l2_logs.js';
import { PublicDataWrite } from './public_data_write.js';
/**
 * The data that makes up the rollup proof, with encoder decoder functions.
 * TODO: Reuse data types and serialization functions from circuits package.
 */
export class L2Block {
    constructor(
    /**
     * The number of the L2 block.
     */
    number, 
    /**
     * The global variables for the L2 block.
     */
    globalVariables, 
    /**
     * The tree snapshot of the note hash tree at the start of the rollup.
     */
    startNoteHashTreeSnapshot, 
    /**
     * The tree snapshot of the nullifier tree at the start of the rollup.
     */
    startNullifierTreeSnapshot, 
    /**
     * The tree snapshot of the contract tree at the start of the rollup.
     */
    startContractTreeSnapshot, 
    /**
     * The tree root of the public data tree at the start of the rollup.
     */
    startPublicDataTreeRoot, 
    /**
     * The tree snapshot of the L2 message tree at the start of the rollup.
     */
    startL1ToL2MessagesTreeSnapshot, 
    /**
     * The tree snapshot of the archive at the start of the rollup.
     */
    startArchiveSnapshot = AppendOnlyTreeSnapshot.empty(), 
    /**
     * The tree snapshot of the note hash tree at the end of the rollup.
     */
    endNoteHashTreeSnapshot, 
    /**
     * The tree snapshot of the nullifier tree at the end of the rollup.
     */
    endNullifierTreeSnapshot, 
    /**
     * The tree snapshot of the contract tree at the end of the rollup.
     */
    endContractTreeSnapshot, 
    /**
     * The tree root of the public data tree at the end of the rollup.
     */
    endPublicDataTreeRoot, 
    /**
     * The tree snapshot of the L2 message tree at the end of the rollup.
     */
    endL1ToL2MessagesTreeSnapshot, 
    /**
     * The tree snapshot of the archive at the end of the rollup.
     */
    endArchiveSnapshot, 
    /**
     * The commitments to be inserted into the note hash tree.
     */
    newCommitments, 
    /**
     * The nullifiers to be inserted into the nullifier tree.
     */
    newNullifiers, 
    /**
     * The public data writes to be inserted into the public data tree.
     */
    newPublicDataWrites, 
    /**
     * The L2 to L1 messages to be inserted into the messagebox on L1.
     */
    newL2ToL1Msgs, 
    /**
     * The contracts leafs to be inserted into the contract tree.
     */
    newContracts, 
    /**
     * The aztec address and ethereum address for the deployed contract and its portal contract.
     */
    newContractData, 
    /**
     * The L1 to L2 messages to be inserted into the L2 toL2 message tree.
     */
    newL1ToL2Messages = [], newEncryptedLogs, newUnencryptedLogs, blockHash, l1BlockNumber) {
        this.number = number;
        this.globalVariables = globalVariables;
        this.startNoteHashTreeSnapshot = startNoteHashTreeSnapshot;
        this.startNullifierTreeSnapshot = startNullifierTreeSnapshot;
        this.startContractTreeSnapshot = startContractTreeSnapshot;
        this.startPublicDataTreeRoot = startPublicDataTreeRoot;
        this.startL1ToL2MessagesTreeSnapshot = startL1ToL2MessagesTreeSnapshot;
        this.startArchiveSnapshot = startArchiveSnapshot;
        this.endNoteHashTreeSnapshot = endNoteHashTreeSnapshot;
        this.endNullifierTreeSnapshot = endNullifierTreeSnapshot;
        this.endContractTreeSnapshot = endContractTreeSnapshot;
        this.endPublicDataTreeRoot = endPublicDataTreeRoot;
        this.endL1ToL2MessagesTreeSnapshot = endL1ToL2MessagesTreeSnapshot;
        this.endArchiveSnapshot = endArchiveSnapshot;
        this.newCommitments = newCommitments;
        this.newNullifiers = newNullifiers;
        this.newPublicDataWrites = newPublicDataWrites;
        this.newL2ToL1Msgs = newL2ToL1Msgs;
        this.newContracts = newContracts;
        this.newContractData = newContractData;
        this.newL1ToL2Messages = newL1ToL2Messages;
        this.blockHash = blockHash;
        _L2Block_l1BlockNumber.set(this, void 0);
        if (newCommitments.length % MAX_NEW_COMMITMENTS_PER_TX !== 0) {
            throw new Error(`The number of new commitments must be a multiple of ${MAX_NEW_COMMITMENTS_PER_TX}.`);
        }
        if (newEncryptedLogs) {
            this.attachLogs(newEncryptedLogs, LogType.ENCRYPTED);
        }
        if (newUnencryptedLogs) {
            this.attachLogs(newUnencryptedLogs, LogType.UNENCRYPTED);
        }
        // Since the block is padded to always contain a fixed number of nullifiers we get number of txs by counting number
        // of non-zero tx hashes --> tx hash is set to be the first nullifier in the tx.
        this.numberOfTxs = 0;
        for (let i = 0; i < this.newNullifiers.length; i += MAX_NEW_NULLIFIERS_PER_TX) {
            if (!this.newNullifiers[i].equals(Fr.ZERO)) {
                this.numberOfTxs++;
            }
        }
        __classPrivateFieldSet(this, _L2Block_l1BlockNumber, l1BlockNumber, "f");
    }
    /**
     * Creates an L2 block containing random data.
     * @param l2BlockNum - The number of the L2 block.
     * @param txsPerBlock - The number of transactions to include in the block.
     * @param numPrivateCallsPerTx - The number of private function calls to include in each transaction.
     * @param numPublicCallsPerTx - The number of public function calls to include in each transaction.
     * @param numEncryptedLogsPerCall - The number of encrypted logs per 1 private function invocation.
     * @param numUnencryptedLogsPerCall - The number of unencrypted logs per 1 public function invocation.
     * @returns The L2 block.
     */
    static random(l2BlockNum, txsPerBlock = 4, numPrivateCallsPerTx = 2, numPublicCallsPerTx = 3, numEncryptedLogsPerCall = 2, numUnencryptedLogsPerCall = 1) {
        const newNullifiers = times(MAX_NEW_NULLIFIERS_PER_TX * txsPerBlock, Fr.random);
        const newCommitments = times(MAX_NEW_COMMITMENTS_PER_TX * txsPerBlock, Fr.random);
        const newContracts = times(MAX_NEW_CONTRACTS_PER_TX * txsPerBlock, Fr.random);
        const newContractData = times(MAX_NEW_CONTRACTS_PER_TX * txsPerBlock, ContractData.random);
        const newPublicDataWrites = times(MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_TX * txsPerBlock, PublicDataWrite.random);
        const newL1ToL2Messages = times(NUMBER_OF_L1_L2_MESSAGES_PER_ROLLUP, Fr.random);
        const newL2ToL1Msgs = times(MAX_NEW_L2_TO_L1_MSGS_PER_TX, Fr.random);
        const newEncryptedLogs = L2BlockL2Logs.random(txsPerBlock, numPrivateCallsPerTx, numEncryptedLogsPerCall, LogType.ENCRYPTED);
        const newUnencryptedLogs = L2BlockL2Logs.random(txsPerBlock, numPublicCallsPerTx, numUnencryptedLogsPerCall, LogType.UNENCRYPTED);
        return L2Block.fromFields({
            number: l2BlockNum,
            globalVariables: makeGlobalVariables(0, l2BlockNum),
            startNoteHashTreeSnapshot: makeAppendOnlyTreeSnapshot(0),
            startNullifierTreeSnapshot: makeAppendOnlyTreeSnapshot(0),
            startContractTreeSnapshot: makeAppendOnlyTreeSnapshot(0),
            startPublicDataTreeRoot: Fr.random(),
            startL1ToL2MessagesTreeSnapshot: makeAppendOnlyTreeSnapshot(0),
            startArchiveSnapshot: makeAppendOnlyTreeSnapshot(0),
            endNoteHashTreeSnapshot: makeAppendOnlyTreeSnapshot(newCommitments.length),
            endNullifierTreeSnapshot: makeAppendOnlyTreeSnapshot(newNullifiers.length),
            endContractTreeSnapshot: makeAppendOnlyTreeSnapshot(newContracts.length),
            endPublicDataTreeRoot: Fr.random(),
            endL1ToL2MessagesTreeSnapshot: makeAppendOnlyTreeSnapshot(1),
            endArchiveSnapshot: makeAppendOnlyTreeSnapshot(1),
            newCommitments,
            newNullifiers,
            newContracts,
            newContractData,
            newPublicDataWrites,
            newL1ToL2Messages,
            newL2ToL1Msgs,
            newEncryptedLogs,
            newUnencryptedLogs,
        }, undefined, 
        // just for testing purposes, each random L2 block got emitted in the equivalent L1 block
        BigInt(l2BlockNum));
    }
    /**
     * Constructs a new instance from named fields.
     * @param fields - Fields to pass to the constructor.
     * @param blockHash - Hash of the block.
     * @param l1BlockNumber - The block number of the L1 block that contains this L2 block.
     * @returns A new instance.
     */
    static fromFields(fields, blockHash, l1BlockNumber) {
        return new this(fields.number, fields.globalVariables, fields.startNoteHashTreeSnapshot, fields.startNullifierTreeSnapshot, fields.startContractTreeSnapshot, fields.startPublicDataTreeRoot, fields.startL1ToL2MessagesTreeSnapshot, fields.startArchiveSnapshot, fields.endNoteHashTreeSnapshot, fields.endNullifierTreeSnapshot, fields.endContractTreeSnapshot, fields.endPublicDataTreeRoot, fields.endL1ToL2MessagesTreeSnapshot, fields.endArchiveSnapshot, fields.newCommitments, fields.newNullifiers, fields.newPublicDataWrites, fields.newL2ToL1Msgs, fields.newContracts, fields.newContractData, fields.newL1ToL2Messages, fields.newEncryptedLogs, fields.newUnencryptedLogs, blockHash, l1BlockNumber);
    }
    /**
     * Serializes a block without logs to a buffer.
     * @remarks This is used when the block is being served via JSON-RPC because the logs are expected to be served
     * separately.
     * @returns A serialized L2 block without logs.
     */
    toBuffer() {
        return serializeToBuffer(this.globalVariables, this.startNoteHashTreeSnapshot, this.startNullifierTreeSnapshot, this.startContractTreeSnapshot, this.startPublicDataTreeRoot, this.startL1ToL2MessagesTreeSnapshot, this.startArchiveSnapshot, this.endNoteHashTreeSnapshot, this.endNullifierTreeSnapshot, this.endContractTreeSnapshot, this.endPublicDataTreeRoot, this.endL1ToL2MessagesTreeSnapshot, this.endArchiveSnapshot, this.newCommitments.length, this.newCommitments, this.newNullifiers.length, this.newNullifiers, this.newPublicDataWrites.length, this.newPublicDataWrites, this.newL2ToL1Msgs.length, this.newL2ToL1Msgs, this.newContracts.length, this.newContracts, this.newContractData, this.newL1ToL2Messages.length, this.newL1ToL2Messages);
    }
    /**
     * Serializes a block with logs to a buffer.
     * @remarks This is used when the block is being submitted on L1.
     * @returns A serialized L2 block with logs.
     */
    toBufferWithLogs() {
        if (this.newEncryptedLogs === undefined || this.newUnencryptedLogs === undefined) {
            throw new Error(`newEncryptedLogs and newUnencryptedLogs must be defined when encoding L2BlockData (block ${this.number})`);
        }
        return serializeToBuffer(this.toBuffer(), this.newEncryptedLogs, this.newUnencryptedLogs);
    }
    /**
     * Serializes a block without logs to a string.
     * @remarks This is used when the block is being served via JSON-RPC because the logs are expected to be served
     * separately.
     * @returns A serialized L2 block without logs.
     */
    toString() {
        return this.toBuffer().toString(STRING_ENCODING);
    }
    /**
     * Deserializes L2 block without logs from a buffer.
     * @param buf - A serialized L2 block.
     * @returns Deserialized L2 block.
     */
    static fromBuffer(buf) {
        const reader = BufferReader.asReader(buf);
        const globalVariables = reader.readObject(GlobalVariables);
        const number = Number(globalVariables.blockNumber.toBigInt());
        const startNoteHashTreeSnapshot = reader.readObject(AppendOnlyTreeSnapshot);
        const startNullifierTreeSnapshot = reader.readObject(AppendOnlyTreeSnapshot);
        const startContractTreeSnapshot = reader.readObject(AppendOnlyTreeSnapshot);
        const startPublicDataTreeRoot = reader.readObject(Fr);
        const startL1ToL2MessagesTreeSnapshot = reader.readObject(AppendOnlyTreeSnapshot);
        const startArchiveSnapshot = reader.readObject(AppendOnlyTreeSnapshot);
        const endNoteHashTreeSnapshot = reader.readObject(AppendOnlyTreeSnapshot);
        const endNullifierTreeSnapshot = reader.readObject(AppendOnlyTreeSnapshot);
        const endContractTreeSnapshot = reader.readObject(AppendOnlyTreeSnapshot);
        const endPublicDataTreeRoot = reader.readObject(Fr);
        const endL1ToL2MessagesTreeSnapshot = reader.readObject(AppendOnlyTreeSnapshot);
        const endArchiveSnapshot = reader.readObject(AppendOnlyTreeSnapshot);
        const newCommitments = reader.readVector(Fr);
        const newNullifiers = reader.readVector(Fr);
        const newPublicDataWrites = reader.readVector(PublicDataWrite);
        const newL2ToL1Msgs = reader.readVector(Fr);
        const newContracts = reader.readVector(Fr);
        const newContractData = reader.readArray(newContracts.length, ContractData);
        // TODO(sean): could an optimization of this be that it is encoded such that zeros are assumed
        const newL1ToL2Messages = reader.readVector(Fr);
        return L2Block.fromFields({
            number,
            globalVariables,
            startNoteHashTreeSnapshot,
            startNullifierTreeSnapshot,
            startContractTreeSnapshot,
            startPublicDataTreeRoot,
            startL1ToL2MessagesTreeSnapshot: startL1ToL2MessagesTreeSnapshot,
            startArchiveSnapshot,
            endNoteHashTreeSnapshot,
            endNullifierTreeSnapshot,
            endContractTreeSnapshot,
            endPublicDataTreeRoot,
            endL1ToL2MessagesTreeSnapshot,
            endArchiveSnapshot,
            newCommitments,
            newNullifiers,
            newPublicDataWrites,
            newL2ToL1Msgs,
            newContracts,
            newContractData,
            newL1ToL2Messages,
        });
    }
    /**
     * Deserializes L2 block with logs from a buffer.
     * @param buf - A serialized L2 block.
     * @returns Deserialized L2 block.
     */
    static fromBufferWithLogs(buf) {
        const reader = BufferReader.asReader(buf);
        const block = L2Block.fromBuffer(reader);
        const newEncryptedLogs = reader.readObject(L2BlockL2Logs);
        const newUnencryptedLogs = reader.readObject(L2BlockL2Logs);
        block.attachLogs(newEncryptedLogs, LogType.ENCRYPTED);
        block.attachLogs(newUnencryptedLogs, LogType.UNENCRYPTED);
        return block;
    }
    /**
     * Deserializes L2 block without logs from a buffer.
     * @param str - A serialized L2 block.
     * @returns Deserialized L2 block.
     */
    static fromString(str) {
        return L2Block.fromBuffer(Buffer.from(str, STRING_ENCODING));
    }
    /**
     * Helper function to attach logs related to a block.
     * @param logs - The logs to be attached to a block.
     * @param logType - The type of logs to be attached.
     * @remarks Here, because we can have L2 blocks without logs and those logs can be attached later.
     */
    attachLogs(logs, logType) {
        const logFieldName = logType === LogType.ENCRYPTED ? 'newEncryptedLogs' : 'newUnencryptedLogs';
        if (this[logFieldName]) {
            if (this[logFieldName]?.equals(logs)) {
                L2Block.logger(`${logFieldName} logs already attached`);
                return;
            }
            throw new Error(`Trying to attach different ${logFieldName} logs to block ${this.number}.`);
        }
        L2Block.logger(`Attaching ${logFieldName} ${logs.getTotalLogCount()} logs to block ${this.number}`);
        const numTxs = this.newCommitments.length / MAX_NEW_COMMITMENTS_PER_TX;
        if (numTxs !== logs.txLogs.length) {
            throw new Error(`Number of txLogs within ${logFieldName} does not match number of transactions. Expected: ${numTxs} Got: ${logs.txLogs.length}`);
        }
        this[logFieldName] = logs;
    }
    /**
     * Sets the L1 block number that included this block
     * @param l1BlockNumber - The block number of the L1 block that contains this L2 block.
     */
    setL1BlockNumber(l1BlockNumber) {
        __classPrivateFieldSet(this, _L2Block_l1BlockNumber, l1BlockNumber, "f");
    }
    /**
     * Gets the L1 block number that included this block
     */
    getL1BlockNumber() {
        if (typeof __classPrivateFieldGet(this, _L2Block_l1BlockNumber, "f") === 'undefined') {
            throw new Error('L1 block number has to be attached before calling "getL1BlockNumber"');
        }
        return __classPrivateFieldGet(this, _L2Block_l1BlockNumber, "f");
    }
    /**
     * Returns the block's hash.
     * @returns The block's hash.
     */
    getBlockHash() {
        if (!this.blockHash) {
            this.blockHash = keccak(this.toBufferWithLogs());
        }
        return this.blockHash;
    }
    /**
     * Computes the public inputs hash for the L2 block.
     * The same output as the hash of RootRollupPublicInputs.
     * @returns The public input hash for the L2 block as a field element.
     */
    getPublicInputsHash() {
        const buf = serializeToBuffer(this.globalVariables, this.startNoteHashTreeSnapshot, this.startNullifierTreeSnapshot, this.startContractTreeSnapshot, this.startPublicDataTreeRoot, this.startL1ToL2MessagesTreeSnapshot, this.startArchiveSnapshot, this.endNoteHashTreeSnapshot, this.endNullifierTreeSnapshot, this.endContractTreeSnapshot, this.endPublicDataTreeRoot, this.endL1ToL2MessagesTreeSnapshot, this.endArchiveSnapshot, this.getCalldataHash(), this.getL1ToL2MessagesHash());
        return Fr.fromBufferReduce(sha256(buf));
    }
    /**
     * Computes the start state hash (should equal contract data before block).
     * @returns The start state hash for the L2 block.
     */
    getStartStateHash() {
        const inputValue = serializeToBuffer(new Fr(this.number - 1), this.startNoteHashTreeSnapshot, this.startNullifierTreeSnapshot, this.startContractTreeSnapshot, this.startPublicDataTreeRoot, this.startL1ToL2MessagesTreeSnapshot, this.startArchiveSnapshot);
        return sha256(inputValue);
    }
    /**
     * Computes the end state hash (should equal contract data after block).
     * @returns The end state hash for the L2 block.
     */
    getEndStateHash() {
        const inputValue = serializeToBuffer(this.globalVariables.blockNumber, this.endNoteHashTreeSnapshot, this.endNullifierTreeSnapshot, this.endContractTreeSnapshot, this.endPublicDataTreeRoot, this.endL1ToL2MessagesTreeSnapshot, this.endArchiveSnapshot);
        return sha256(inputValue);
    }
    /**
     * Computes the calldata hash for the L2 block
     * This calldata hash is also computed by the rollup contract when the block is submitted,
     * and inside the circuit, it is part of the public inputs.
     * @returns The calldata hash.
     */
    getCalldataHash() {
        if (this.newEncryptedLogs === undefined) {
            throw new Error('Encrypted logs has to be attached before calling "getCalldataHash"');
        }
        if (this.newUnencryptedLogs === undefined) {
            throw new Error('Unencrypted logs has to be attached before calling "getCalldataHash"');
        }
        const computeRoot = (leafs) => {
            const layers = [leafs];
            let activeLayer = 0;
            while (layers[activeLayer].length > 1) {
                const layer = [];
                const layerLength = layers[activeLayer].length;
                for (let i = 0; i < layerLength; i += 2) {
                    const left = layers[activeLayer][i];
                    const right = layers[activeLayer][i + 1];
                    layer.push(sha256(Buffer.concat([left, right])));
                }
                layers.push(layer);
                activeLayer++;
            }
            return layers[layers.length - 1][0];
        };
        const leafCount = this.newCommitments.length / (MAX_NEW_COMMITMENTS_PER_TX * 2);
        const leafs = [];
        for (let i = 0; i < leafCount; i++) {
            const commitmentsPerBase = MAX_NEW_COMMITMENTS_PER_TX * 2;
            const nullifiersPerBase = MAX_NEW_NULLIFIERS_PER_TX * 2;
            const publicDataUpdateRequestsPerBase = MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_TX * 2;
            const l2ToL1MsgsPerBase = MAX_NEW_L2_TO_L1_MSGS_PER_TX * 2;
            const commitmentsBuffer = Buffer.concat(this.newCommitments.slice(i * commitmentsPerBase, (i + 1) * commitmentsPerBase).map(x => x.toBuffer()));
            const nullifiersBuffer = Buffer.concat(this.newNullifiers.slice(i * nullifiersPerBase, (i + 1) * nullifiersPerBase).map(x => x.toBuffer()));
            const publicDataUpdateRequestsBuffer = Buffer.concat(this.newPublicDataWrites
                .slice(i * publicDataUpdateRequestsPerBase, (i + 1) * publicDataUpdateRequestsPerBase)
                .map(x => x.toBuffer()));
            const newL2ToL1MsgsBuffer = Buffer.concat(this.newL2ToL1Msgs.slice(i * l2ToL1MsgsPerBase, (i + 1) * l2ToL1MsgsPerBase).map(x => x.toBuffer()));
            const encryptedLogsHashKernel0 = L2Block.computeKernelLogsHash(this.newEncryptedLogs.txLogs[i * 2]);
            const encryptedLogsHashKernel1 = L2Block.computeKernelLogsHash(this.newEncryptedLogs.txLogs[i * 2 + 1]);
            const unencryptedLogsHashKernel0 = L2Block.computeKernelLogsHash(this.newUnencryptedLogs.txLogs[i * 2]);
            const unencryptedLogsHashKernel1 = L2Block.computeKernelLogsHash(this.newUnencryptedLogs.txLogs[i * 2 + 1]);
            const inputValue = Buffer.concat([
                commitmentsBuffer,
                nullifiersBuffer,
                publicDataUpdateRequestsBuffer,
                newL2ToL1MsgsBuffer,
                this.newContracts[i * 2].toBuffer(),
                this.newContracts[i * 2 + 1].toBuffer(),
                this.newContractData[i * 2].contractAddress.toBuffer(),
                this.newContractData[i * 2].portalContractAddress.toBuffer32(),
                this.newContractData[i * 2 + 1].contractAddress.toBuffer(),
                this.newContractData[i * 2 + 1].portalContractAddress.toBuffer32(),
                encryptedLogsHashKernel0,
                encryptedLogsHashKernel1,
                unencryptedLogsHashKernel0,
                unencryptedLogsHashKernel1,
            ]);
            leafs.push(sha256(inputValue));
        }
        return computeRoot(leafs);
    }
    /**
     * Compute the hash of all of this blocks l1 to l2 messages,
     * The hash is also calculated within the contract when the block is submitted.
     * @returns The hash of all of the l1 to l2 messages.
     */
    getL1ToL2MessagesHash() {
        // Create a long buffer of all of the l1 to l2 messages
        const l1ToL2Messages = Buffer.concat(this.newL1ToL2Messages.map(message => message.toBuffer()));
        return sha256(l1ToL2Messages);
    }
    /**
     * Get the ith transaction in an L2 block.
     * @param txIndex - The index of the tx in the block.
     * @returns The tx.
     */
    getTx(txIndex) {
        if (txIndex >= this.numberOfTxs) {
            throw new Error(`Failed to get tx ${txIndex}. Block ${this.globalVariables.blockNumber} only has ${this.numberOfTxs} txs.`);
        }
        const newCommitments = this.newCommitments
            .slice(MAX_NEW_COMMITMENTS_PER_TX * txIndex, MAX_NEW_COMMITMENTS_PER_TX * (txIndex + 1))
            .filter(x => !x.isZero());
        const newNullifiers = this.newNullifiers
            .slice(MAX_NEW_NULLIFIERS_PER_TX * txIndex, MAX_NEW_NULLIFIERS_PER_TX * (txIndex + 1))
            .filter(x => !x.isZero());
        const newPublicDataWrites = this.newPublicDataWrites
            .slice(MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_TX * txIndex, MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_TX * (txIndex + 1))
            .filter(x => !x.isEmpty());
        const newL2ToL1Msgs = this.newL2ToL1Msgs
            .slice(MAX_NEW_L2_TO_L1_MSGS_PER_TX * txIndex, MAX_NEW_L2_TO_L1_MSGS_PER_TX * (txIndex + 1))
            .filter(x => !x.isZero());
        const newContracts = this.newContracts
            .slice(MAX_NEW_CONTRACTS_PER_TX * txIndex, MAX_NEW_CONTRACTS_PER_TX * (txIndex + 1))
            .filter(x => !x.isZero());
        const newContractData = this.newContractData
            .slice(MAX_NEW_CONTRACTS_PER_TX * txIndex, MAX_NEW_CONTRACTS_PER_TX * (txIndex + 1))
            .filter(x => !x.isEmpty());
        return new L2Tx(newCommitments, newNullifiers, newPublicDataWrites, newL2ToL1Msgs, newContracts, newContractData, this.getBlockHash(), this.number);
    }
    /**
     * Get all the transaction in an L2 block.
     * @returns The tx.
     */
    getTxs() {
        return Array(this.numberOfTxs)
            .fill(0)
            .map((_, i) => this.getTx(i));
    }
    /**
     * Returns stats used for logging.
     * @returns Stats on tx count, number, and log size and count.
     */
    getStats() {
        const encryptedLogsStats = this.newEncryptedLogs && {
            encryptedLogCount: this.newEncryptedLogs?.getTotalLogCount() ?? 0,
            encryptedLogSize: this.newEncryptedLogs?.getSerializedLength() ?? 0,
        };
        const unencryptedLogsStats = this.newUnencryptedLogs && {
            unencryptedLogCount: this.newUnencryptedLogs?.getTotalLogCount() ?? 0,
            unencryptedLogSize: this.newUnencryptedLogs?.getSerializedLength() ?? 0,
        };
        return {
            txCount: this.numberOfTxs,
            blockNumber: this.number,
            ...encryptedLogsStats,
            ...unencryptedLogsStats,
        };
    }
    /**
     * Inspect for debugging purposes..
     * @param maxBufferSize - The number of bytes to be extracted from buffer.
     * @returns A human-friendly string representation of the l2Block.
     */
    inspect(maxBufferSize = 4) {
        const inspectHex = (fr) => `0x${fr.toBuffer().subarray(0, maxBufferSize).toString('hex')}`;
        const inspectArray = (arr, inspector) => '[' + arr.map(inspector).join(', ') + ']';
        const inspectTreeSnapshot = (s) => `(${s.nextAvailableLeafIndex}, ${inspectHex(s.root)})`;
        const inspectGlobalVariables = (gv) => {
            return `(${gv.chainId}, ${gv.version}, ${gv.blockNumber}, ${gv.timestamp}))`;
        };
        const inspectFrArray = (arr) => inspectArray(arr, inspectHex);
        const inspectContractDataArray = (arr) => inspectArray(arr, cd => `(${inspectHex(cd.contractAddress)}, ${inspectHex(cd.portalContractAddress)})`);
        const inspectPublicDataWriteArray = (arr) => inspectArray(arr, pdw => `(${inspectHex(pdw.leafIndex)}, ${inspectHex(pdw.newValue)})`);
        return [
            `L2Block`,
            `number: ${this.number}`,
            `globalVariables: ${inspectGlobalVariables(this.globalVariables)}`,
            `startNoteHashTreeSnapshot: ${inspectTreeSnapshot(this.startNoteHashTreeSnapshot)}`,
            `startNullifierTreeSnapshot: ${inspectTreeSnapshot(this.startNullifierTreeSnapshot)}`,
            `startContractTreeSnapshot: ${inspectTreeSnapshot(this.startContractTreeSnapshot)}`,
            `startPublicDataTreeRoot: ${this.startPublicDataTreeRoot.toString()}`,
            `startL1ToL2MessagesTreeSnapshot: ${inspectTreeSnapshot(this.startL1ToL2MessagesTreeSnapshot)}`,
            `startArchiveSnapshot: ${inspectTreeSnapshot(this.startArchiveSnapshot)}`,
            `endNoteHashTreeSnapshot: ${inspectTreeSnapshot(this.endNoteHashTreeSnapshot)}`,
            `endNullifierTreeSnapshot: ${inspectTreeSnapshot(this.endNullifierTreeSnapshot)}`,
            `endContractTreeSnapshot: ${inspectTreeSnapshot(this.endContractTreeSnapshot)}`,
            `endPublicDataTreeRoot: ${this.endPublicDataTreeRoot.toString()}`,
            `endPublicDataTreeRoot: ${this.endPublicDataTreeRoot.toString()}`,
            `endL1ToL2MessagesTreeSnapshot: ${inspectTreeSnapshot(this.endL1ToL2MessagesTreeSnapshot)}`,
            `endArchiveSnapshot: ${inspectTreeSnapshot(this.endArchiveSnapshot)}`,
            `newCommitments: ${inspectFrArray(this.newCommitments)}`,
            `newNullifiers: ${inspectFrArray(this.newNullifiers)}`,
            `newPublicDataWrite: ${inspectPublicDataWriteArray(this.newPublicDataWrites)}`,
            `newL2ToL1Msgs: ${inspectFrArray(this.newL2ToL1Msgs)}`,
            `newContracts: ${inspectFrArray(this.newContracts)}`,
            `newContractData: ${inspectContractDataArray(this.newContractData)}`,
            `newPublicDataWrite: ${inspectPublicDataWriteArray(this.newPublicDataWrites)}`,
            `newL1ToL2Messages: ${inspectFrArray(this.newL1ToL2Messages)}`,
        ].join('\n');
    }
    /**
     * Computes logs hash as is done in the kernel and app circuits.
     * @param logs - Logs to be hashed.
     * @returns The hash of the logs.
     * Note: This is a TS implementation of `computeKernelLogsHash` function in Decoder.sol. See that function documentation
     *       for more details.
     */
    static computeKernelLogsHash(logs) {
        const logsHashes = [Buffer.alloc(32), Buffer.alloc(32)];
        let kernelPublicInputsLogsHash = Buffer.alloc(32);
        for (const functionLogs of logs.functionLogs) {
            logsHashes[0] = kernelPublicInputsLogsHash;
            logsHashes[1] = functionLogs.hash(); // privateCircuitPublicInputsLogsHash
            // Hash logs hash from the public inputs of previous kernel iteration and logs hash from private circuit public inputs
            kernelPublicInputsLogsHash = sha256(Buffer.concat(logsHashes));
        }
        return kernelPublicInputsLogsHash;
    }
}
_L2Block_l1BlockNumber = new WeakMap();
/* Having logger static to avoid issues with comparing 2 block */
L2Block.logger = createDebugLogger('aztec:l2_block');
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibDJfYmxvY2suanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi9zcmMvbDJfYmxvY2sudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFBQSxPQUFPLEVBQ0wsc0JBQXNCLEVBQ3RCLGVBQWUsRUFDZiwwQkFBMEIsRUFDMUIsd0JBQXdCLEVBQ3hCLDRCQUE0QixFQUM1Qix5QkFBeUIsRUFDekIsc0NBQXNDLEVBQ3RDLG1DQUFtQyxFQUNuQyxlQUFlLEdBQ2hCLE1BQU0sb0JBQW9CLENBQUM7QUFDNUIsT0FBTyxFQUFFLDBCQUEwQixFQUFFLG1CQUFtQixFQUFFLE1BQU0sOEJBQThCLENBQUM7QUFDL0YsT0FBTyxFQUFFLFlBQVksRUFBRSxpQkFBaUIsRUFBRSxNQUFNLDBCQUEwQixDQUFDO0FBQzNFLE9BQU8sRUFBRSxNQUFNLEVBQUUsTUFBTSxFQUFFLE1BQU0sMEJBQTBCLENBQUM7QUFDMUQsT0FBTyxFQUFFLEVBQUUsRUFBRSxNQUFNLDBCQUEwQixDQUFDO0FBQzlDLE9BQU8sRUFBRSxpQkFBaUIsRUFBRSxNQUFNLHVCQUF1QixDQUFDO0FBRTFELE9BQU8sS0FBSyxNQUFNLGNBQWMsQ0FBQztBQUVqQyxPQUFPLEVBQUUsWUFBWSxFQUFFLE1BQU0sb0JBQW9CLENBQUM7QUFDbEQsT0FBTyxFQUFFLElBQUksRUFBRSxNQUFNLFlBQVksQ0FBQztBQUNsQyxPQUFPLEVBQUUsT0FBTyxFQUFZLE1BQU0saUJBQWlCLENBQUM7QUFDcEQsT0FBTyxFQUFFLGFBQWEsRUFBRSxNQUFNLDRCQUE0QixDQUFDO0FBQzNELE9BQU8sRUFBRSxlQUFlLEVBQUUsTUFBTSx3QkFBd0IsQ0FBQztBQUV6RDs7O0dBR0c7QUFDSCxNQUFNLE9BQU8sT0FBTztJQTZCbEI7SUFDRTs7T0FFRztJQUNJLE1BQWM7SUFDckI7O09BRUc7SUFDSSxlQUFnQztJQUN2Qzs7T0FFRztJQUNJLHlCQUFpRDtJQUN4RDs7T0FFRztJQUNJLDBCQUFrRDtJQUN6RDs7T0FFRztJQUNJLHlC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