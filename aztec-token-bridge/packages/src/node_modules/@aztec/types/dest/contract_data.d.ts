/// <reference types="node" resolution-mode="require"/>
import { CompleteAddress, FunctionSelector, PartialAddress, PublicKey } from '@aztec/circuits.js';
import { BufferReader } from '@aztec/circuits.js/utils';
import { AztecAddress } from '@aztec/foundation/aztec-address';
import { EthAddress } from '@aztec/foundation/eth-address';
export { BufferReader } from '@aztec/circuits.js/utils';
/**
 * Used for retrieval of contract data (A3 address, portal contract address, bytecode).
 */
export interface ContractDataSource {
    /**
     * Get the extended contract data for this contract.
     * @param contractAddress - The contract data address.
     * @returns The extended contract data or undefined if not found.
     */
    getExtendedContractData(contractAddress: AztecAddress): Promise<ExtendedContractData | undefined>;
    /**
     * Lookup the L2 contract base info for this contract.
     * NOTE: This works for all Aztec contracts and will only return contractAddress / portalAddress.
     * @param contractAddress - The contract data address.
     * @returns The aztec & ethereum portal address (if found).
     */
    getContractData(contractAddress: AztecAddress): Promise<ContractData | undefined>;
    /**
     * Gets extended contract data for all contracts deployed in L2 block.
     * @param blockNumber - The block number.
     * @returns Extended contract data of contracts deployed in L2 block.
     */
    getExtendedContractDataInBlock(blockNumber: number): Promise<ExtendedContractData[]>;
    /**
     * Lookup contract data in an L2 block.
     * @param blockNumber - The block number.
     * @returns Portal contract address info of contracts deployed in L2 block.
     */
    getContractDataInBlock(blockNumber: number): Promise<ContractData[] | undefined>;
    /**
     * Returns a contract's encoded public function, given its function selector.
     * @param address - The contract aztec address.
     * @param selector - The function's selector.
     * @returns The function's data.
     */
    getPublicFunction(address: AztecAddress, selector: FunctionSelector): Promise<EncodedContractFunction | undefined>;
    /**
     * Gets the number of the latest L2 block processed by the implementation.
     * @returns The number of the latest L2 block processed by the implementation.
     */
    getBlockNumber(): Promise<number>;
}
/**
 * Represents encoded contract function.
 */
export declare class EncodedContractFunction {
    /**
     * The function selector.
     */
    selector: FunctionSelector;
    /**
     * Whether the function is internal.
     */
    isInternal: boolean;
    /**
     * The function bytecode.
     */
    bytecode: Buffer;
    constructor(
    /**
     * The function selector.
     */
    selector: FunctionSelector, 
    /**
     * Whether the function is internal.
     */
    isInternal: boolean, 
    /**
     * The function bytecode.
     */
    bytecode: Buffer);
    /**
     * Serializes this instance into a buffer.
     * @returns Encoded buffer.
     */
    toBuffer(): Buffer;
    /**
     * Deserializes a contract function object from an encoded buffer.
     * @param buffer - The encoded buffer.
     * @returns The deserialized contract function.
     */
    static fromBuffer(buffer: Buffer | BufferReader): EncodedContractFunction;
    /**
     * Creates a random contract function.
     * @returns A random contract function.
     */
    static random(): EncodedContractFunction;
}
/**
 * A contract data blob, containing L1 and L2 addresses, public functions' bytecode, partial address and public key.
 */
export declare class ExtendedContractData {
    /** The base contract data: aztec & portal addresses. */
    contractData: ContractData;
    /** Artifacts of public functions. */
    private publicFunctions;
    /** Partial addresses of the contract. */
    readonly partialAddress: PartialAddress;
    /** Public key of the contract. */
    readonly publicKey: PublicKey;
    /** The contract's encoded ACIR code. This should become Brillig code once implemented. */
    bytecode: Buffer;
    constructor(
    /** The base contract data: aztec & portal addresses. */
    contractData: ContractData, 
    /** Artifacts of public functions. */
    publicFunctions: EncodedContractFunction[], 
    /** Partial addresses of the contract. */
    partialAddress: PartialAddress, 
    /** Public key of the contract. */
    publicKey: PublicKey);
    /**
     * Gets the public function data or undefined.
     * @param selector - The function selector of the function to fetch.
     * @returns The public function data (if found).
     */
    getPublicFunction(selector: FunctionSelector): EncodedContractFunction | undefined;
    /**
     * Serializes this instance into a buffer, using 20 bytes for the eth address.
     * @returns Encoded buffer.
     */
    toBuffer(): Buffer;
    /**
     * Serializes this instance into a string.
     * @returns Encoded string.
     */
    toString(): string;
    /**
     * Gets the complete address.
     * @returns The complete address.
     */
    getCompleteAddress(): CompleteAddress;
    /** True if this represents an empty instance. */
    isEmpty(): boolean;
    /**
     * Deserializes a contract data object from an encoded buffer, using 20 bytes for the eth address.
     * @param buffer - Byte array resulting from calling toBuffer.
     * @returns Deserialized instance.
     */
    static fromBuffer(buffer: Buffer | BufferReader): ExtendedContractData;
    /**
     * Deserializes a contract data object from an encoded string, using 20 bytes for the eth address.
     * @param str - String resulting from calling toString.
     * @returns Deserialized instance.
     */
    static fromString(str: string): ExtendedContractData;
    /**
     * Generate ContractData with random addresses.
     * @param contractData - Optional contract data to use.
     * @returns A random ExtendedContractData object.
     */
    static random(contractData?: ContractData): ExtendedContractData;
    /** Generates empty extended contract data. */
    static empty(): ExtendedContractData;
}
/**
 * A contract data blob, containing L1 and L2 addresses.
 */
export declare class ContractData {
    /**
     * The L2 address of the contract, as a field element (32 bytes).
     */
    contractAddress: AztecAddress;
    /**
     * The L1 address of the contract, (20 bytes).
     */
    portalContractAddress: EthAddress;
    constructor(
    /**
     * The L2 address of the contract, as a field element (32 bytes).
     */
    contractAddress: AztecAddress, 
    /**
     * The L1 address of the contract, (20 bytes).
     */
    portalContractAddress: EthAddress);
    /**
     * Serializes this instance into a buffer, using 20 bytes for the eth address.
     * @returns Encoded buffer.
     */
    toBuffer(): Buffer;
    /**
     * Serializes this instance into a string, using 20 bytes for the eth address.
     * @returns Encoded string.
     */
    toString(): string;
    /** True if all data is zero. */
    isEmpty(): boolean;
    /**
     * Deserializes a contract data object from an encoded buffer, using 20 bytes for the eth address.
     * @param buffer - Byte array resulting from calling toBuffer.
     * @returns Deserialized instance.
     */
    static fromBuffer(buffer: Buffer | BufferReader): ContractData;
    /**
     * Deserializes a contract data object from an encoded string, using 20 bytes for the eth address.
     * @param str - String resulting from calling toString.
     * @returns Deserialized instance.
     */
    static fromString(str: string): ContractData;
    /**
     * Generate ContractData with random addresses.
     * @returns ContractData.
     */
    static random(): ContractData;
    /** Generates an empty ContractData. */
    static empty(): ContractData;
}
//# sourceMappingURL=contract_data.d.ts.map