import { CompleteAddress, FUNCTION_SELECTOR_NUM_BYTES, Fr, FunctionSelector, Point, } from '@aztec/circuits.js';
import { BufferReader, serializeToBuffer } from '@aztec/circuits.js/utils';
import { AztecAddress } from '@aztec/foundation/aztec-address';
import { randomBytes } from '@aztec/foundation/crypto';
import { EthAddress } from '@aztec/foundation/eth-address';
import { numToInt32BE, serializeBufferArrayToVector } from '@aztec/foundation/serialize';
export { BufferReader } from '@aztec/circuits.js/utils';
/**
 * Represents encoded contract function.
 */
export class EncodedContractFunction {
    constructor(
    /**
     * The function selector.
     */
    selector, 
    /**
     * Whether the function is internal.
     */
    isInternal, 
    /**
     * The function bytecode.
     */
    bytecode) {
        this.selector = selector;
        this.isInternal = isInternal;
        this.bytecode = bytecode;
    }
    /**
     * Serializes this instance into a buffer.
     * @returns Encoded buffer.
     */
    toBuffer() {
        const bytecodeBuf = Buffer.concat([numToInt32BE(this.bytecode.length), this.bytecode]);
        return serializeToBuffer(this.selector, this.isInternal, bytecodeBuf);
    }
    /**
     * Deserializes a contract function object from an encoded buffer.
     * @param buffer - The encoded buffer.
     * @returns The deserialized contract function.
     */
    static fromBuffer(buffer) {
        const reader = BufferReader.asReader(buffer);
        const fnSelector = FunctionSelector.fromBuffer(reader.readBytes(FUNCTION_SELECTOR_NUM_BYTES));
        const isInternal = reader.readBoolean();
        return new EncodedContractFunction(fnSelector, isInternal, reader.readBuffer());
    }
    /**
     * Creates a random contract function.
     * @returns A random contract function.
     */
    static random() {
        return new EncodedContractFunction(FunctionSelector.fromBuffer(randomBytes(4)), false, randomBytes(64));
    }
}
/**
 * A contract data blob, containing L1 and L2 addresses, public functions' bytecode, partial address and public key.
 */
export class ExtendedContractData {
    constructor(
    /** The base contract data: aztec & portal addresses. */
    contractData, 
    /** Artifacts of public functions. */
    publicFunctions, 
    /** Partial addresses of the contract. */
    partialAddress, 
    /** Public key of the contract. */
    publicKey) {
        this.contractData = contractData;
        this.publicFunctions = publicFunctions;
        this.partialAddress = partialAddress;
        this.publicKey = publicKey;
        this.bytecode = serializeBufferArrayToVector(publicFunctions.map(fn => fn.toBuffer()));
    }
    /**
     * Gets the public function data or undefined.
     * @param selector - The function selector of the function to fetch.
     * @returns The public function data (if found).
     */
    getPublicFunction(selector) {
        return this.publicFunctions.find(fn => fn.selector.equals(selector));
    }
    /**
     * Serializes this instance into a buffer, using 20 bytes for the eth address.
     * @returns Encoded buffer.
     */
    toBuffer() {
        const contractDataBuf = this.contractData.toBuffer();
        return serializeToBuffer(contractDataBuf, this.bytecode, this.partialAddress, this.publicKey);
    }
    /**
     * Serializes this instance into a string.
     * @returns Encoded string.
     */
    toString() {
        return this.toBuffer().toString('hex');
    }
    /**
     * Gets the complete address.
     * @returns The complete address.
     */
    getCompleteAddress() {
        return new CompleteAddress(this.contractData.contractAddress, this.publicKey, this.partialAddress);
    }
    /** True if this represents an empty instance. */
    isEmpty() {
        return (this.contractData.isEmpty() &&
            this.publicFunctions.length === 0 &&
            this.partialAddress.isZero() &&
            this.publicKey.x.isZero() &&
            this.publicKey.y.isZero());
    }
    /**
     * Deserializes a contract data object from an encoded buffer, using 20 bytes for the eth address.
     * @param buffer - Byte array resulting from calling toBuffer.
     * @returns Deserialized instance.
     */
    static fromBuffer(buffer) {
        const reader = BufferReader.asReader(buffer);
        const contractData = reader.readObject(ContractData);
        const publicFns = reader.readVector(EncodedContractFunction);
        const partialAddress = reader.readObject(Fr);
        const publicKey = reader.readObject(Point);
        return new ExtendedContractData(contractData, publicFns, partialAddress, publicKey);
    }
    /**
     * Deserializes a contract data object from an encoded string, using 20 bytes for the eth address.
     * @param str - String resulting from calling toString.
     * @returns Deserialized instance.
     */
    static fromString(str) {
        return ExtendedContractData.fromBuffer(Buffer.from(str, 'hex'));
    }
    /**
     * Generate ContractData with random addresses.
     * @param contractData - Optional contract data to use.
     * @returns A random ExtendedContractData object.
     */
    static random(contractData) {
        return new ExtendedContractData(contractData ?? ContractData.random(), [EncodedContractFunction.random(), EncodedContractFunction.random()], Fr.random(), Point.random());
    }
    /** Generates empty extended contract data. */
    static empty() {
        return new ExtendedContractData(ContractData.empty(), [], Fr.ZERO, Point.ZERO);
    }
}
/**
 * A contract data blob, containing L1 and L2 addresses.
 */
export class ContractData {
    constructor(
    /**
     * The L2 address of the contract, as a field element (32 bytes).
     */
    contractAddress, 
    /**
     * The L1 address of the contract, (20 bytes).
     */
    portalContractAddress) {
        this.contractAddress = contractAddress;
        this.portalContractAddress = portalContractAddress;
    }
    /**
     * Serializes this instance into a buffer, using 20 bytes for the eth address.
     * @returns Encoded buffer.
     */
    toBuffer() {
        return serializeToBuffer(this.contractAddress, this.portalContractAddress.toBuffer20());
    }
    /**
     * Serializes this instance into a string, using 20 bytes for the eth address.
     * @returns Encoded string.
     */
    toString() {
        return this.toBuffer().toString('hex');
    }
    /** True if all data is zero. */
    isEmpty() {
        return this.contractAddress.isZero() && this.portalContractAddress.isZero();
    }
    /**
     * Deserializes a contract data object from an encoded buffer, using 20 bytes for the eth address.
     * @param buffer - Byte array resulting from calling toBuffer.
     * @returns Deserialized instance.
     */
    static fromBuffer(buffer) {
        const reader = BufferReader.asReader(buffer);
        const aztecAddr = AztecAddress.fromBuffer(reader);
        const ethAddr = new EthAddress(reader.readBytes(EthAddress.SIZE_IN_BYTES));
        return new ContractData(aztecAddr, ethAddr);
    }
    /**
     * Deserializes a contract data object from an encoded string, using 20 bytes for the eth address.
     * @param str - String resulting from calling toString.
     * @returns Deserialized instance.
     */
    static fromString(str) {
        return ContractData.fromBuffer(Buffer.from(str, 'hex'));
    }
    /**
     * Generate ContractData with random addresses.
     * @returns ContractData.
     */
    static random() {
        return new ContractData(AztecAddress.random(), EthAddress.random());
    }
    /** Generates an empty ContractData. */
    static empty() {
        return new ContractData(AztecAddress.ZERO, EthAddress.ZERO);
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29udHJhY3RfZGF0YS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uL3NyYy9jb250cmFjdF9kYXRhLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFDTCxlQUFlLEVBQ2YsMkJBQTJCLEVBQzNCLEVBQUUsRUFDRixnQkFBZ0IsRUFFaEIsS0FBSyxHQUVOLE1BQU0sb0JBQW9CLENBQUM7QUFDNUIsT0FBTyxFQUFFLFlBQVksRUFBRSxpQkFBaUIsRUFBRSxNQUFNLDBCQUEwQixDQUFDO0FBQzNFLE9BQU8sRUFBRSxZQUFZLEVBQUUsTUFBTSxpQ0FBaUMsQ0FBQztBQUMvRCxPQUFPLEVBQUUsV0FBVyxFQUFFLE1BQU0sMEJBQTBCLENBQUM7QUFDdkQsT0FBTyxFQUFFLFVBQVUsRUFBRSxNQUFNLCtCQUErQixDQUFDO0FBQzNELE9BQU8sRUFBRSxZQUFZLEVBQUUsNEJBQTRCLEVBQUUsTUFBTSw2QkFBNkIsQ0FBQztBQUV6RixPQUFPLEVBQUUsWUFBWSxFQUFFLE1BQU0sMEJBQTBCLENBQUM7QUFrRHhEOztHQUVHO0FBQ0gsTUFBTSxPQUFPLHVCQUF1QjtJQUNsQztJQUNFOztPQUVHO0lBQ0ksUUFBMEI7SUFDakM7O09BRUc7SUFDSSxVQUFtQjtJQUMxQjs7T0FFRztJQUNJLFFBQWdCO1FBUmhCLGFBQVEsR0FBUixRQUFRLENBQWtCO1FBSTFCLGVBQVUsR0FBVixVQUFVLENBQVM7UUFJbkIsYUFBUSxHQUFSLFFBQVEsQ0FBUTtJQUN0QixDQUFDO0lBRUo7OztPQUdHO0lBQ0gsUUFBUTtRQUNOLE1BQU0sV0FBVyxHQUFHLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsRUFBRSxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQztRQUN2RixPQUFPLGlCQUFpQixDQUFDLElBQUksQ0FBQyxRQUFRLEVBQUUsSUFBSSxDQUFDLFVBQVUsRUFBRSxXQUFXLENBQUMs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