/// <reference types="node" resolution-mode="require"/>
import { BufferReader } from '../serialize/buffer_reader.js';
import { Fr } from './fields.js';
/**
 * Represents a Point on an elliptic curve with x and y coordinates.
 * The Point class provides methods for creating instances from different input types,
 * converting instances to various output formats, and checking the equality of points.
 */
export declare class Point {
    /**
     * The point's x coordinate
     */
    readonly x: Fr;
    /**
     * The point's y coordinate
     */
    readonly y: Fr;
    static ZERO: Point;
    static SIZE_IN_BYTES: number;
    /** Used to differentiate this class from AztecAddress */
    readonly kind = "point";
    constructor(
    /**
     * The point's x coordinate
     */
    x: Fr, 
    /**
     * The point's y coordinate
     */
    y: Fr);
    /**
     * Generate a random Point instance.
     *
     * @returns A randomly generated Point instance.
     */
    static random(): Point;
    /**
     * Create a Point instance from a given buffer or BufferReader.
     * The input 'buffer' should have exactly 64 bytes representing the x and y coordinates.
     *
     * @param buffer - The buffer or BufferReader containing the x and y coordinates of the point.
     * @returns A Point instance.
     */
    static fromBuffer(buffer: Buffer | BufferReader): Point;
    /**
     * Create a Point instance from a hex-encoded string.
     * The input 'address' should be prefixed with '0x' or not, and have exactly 128 hex characters representing the x and y coordinates.
     * Throws an error if the input length is invalid or coordinate values are out of range.
     *
     * @param address - The hex-encoded string representing the Point coordinates.
     * @returns A Point instance.
     */
    static fromString(address: string): Point;
    /**
     * Returns the contents of the point as an array of 2 fields.
     * @returns The point as an array of 2 fields
     */
    toFields(): Fr[];
    /**
     * Returns the contents of the point as BigInts.
     * @returns The point as BigInts
     */
    toBigInts(): {
        x: bigint;
        y: bigint;
    };
    /**
     * Converts the Point instance to a Buffer representation of the coordinates.
     * The outputs buffer length will be 64, the length of both coordinates not represented as fields.
     * @returns A Buffer representation of the Point instance.
     */
    toBuffer(): Buffer;
    /**
     * Convert the Point instance to a hexadecimal string representation.
     * The output string is prefixed with '0x' and consists of exactly 128 hex characters,
     * representing the concatenated x and y coordinates of the point.
     *
     * @returns A hex-encoded string representing the Point instance.
     */
    toString(): string;
    /**
     * Generate a short string representation of the Point instance.
     * The returned string includes the first 10 and last 4 characters of the full string representation,
     * with '...' in between to indicate truncation. This is useful for displaying or logging purposes
     * when the full string representation may be too long.
     *
     * @returns A truncated string representation of the Point instance.
     */
    toShortString(): string;
    /**
     * Check if two Point instances are equal by comparing their buffer values.
     * Returns true if the buffer values are the same, and false otherwise.
     *
     * @param rhs - The Point instance to compare with the current instance.
     * @returns A boolean indicating whether the two Point instances are equal.
     */
    equals(rhs: Point): boolean;
    isZero(): boolean;
}
/**
 * Does this object look like a point?
 * @param obj - Object to test if it is a point.
 * @returns Whether it looks like a point.
 */
export declare function isPoint(obj: object): obj is Point;
//# sourceMappingURL=point.d.ts.map