import { toBigIntBE, toBufferBE } from '../bigint-buffer/index.js';
import { randomBytes } from '../crypto/random/index.js';
import { BufferReader } from '../serialize/buffer_reader.js';
const ZERO_BUFFER = Buffer.alloc(32);
/**
 * Base field class.
 * Conversions from Buffer to BigInt and vice-versa are not cheap.
 * We allow construction with either form and lazily convert to other as needed.
 * We only check we are within the field modulus when initializing with bigint.
 * If NODE_ENV === 'test', we will always initialize both types to check the modulus.
 * This is also necessary in test environment as a lot of tests just use deep equality to check equality.
 * WARNING: This could lead to a bugs in production that don't reveal in tests, but it's low risk.
 */
class BaseField {
    /**
     * Return bigint representation.
     * @deprecated Just to get things compiling. Use toBigInt().
     * */
    get value() {
        return this.toBigInt();
    }
    constructor(value) {
        if (value instanceof Buffer) {
            if (value.length > BaseField.SIZE_IN_BYTES) {
                throw new Error(`Value length ${value.length} exceeds ${BaseField.SIZE_IN_BYTES}`);
            }
            this.asBuffer =
                value.length === BaseField.SIZE_IN_BYTES
                    ? value
                    : Buffer.concat([Buffer.alloc(BaseField.SIZE_IN_BYTES - value.length), value]);
        }
        else if (typeof value === 'bigint' || typeof value === 'number' || typeof value === 'boolean') {
            this.asBigInt = BigInt(value);
            if (this.asBigInt >= this.modulus()) {
                throw new Error('Value >= to field modulus.');
            }
        }
        else if (value instanceof BaseField) {
            this.asBuffer = value.asBuffer;
            this.asBigInt = value.asBigInt;
        }
        else {
            throw new Error(`Type '${typeof value}' with value '${value}' passed to BaseField ctor.`);
        }
        // Loads of our tests are just doing deep equality rather than calling e.g. toBigInt() first.
        // This ensures the deep equality passes regardless of the internal representation.
        // It also ensures the value range is checked even when initializing as a buffer.
        if (process.env.NODE_ENV === 'test') {
            this.toBuffer();
            this.toBigInt();
        }
    }
    /**
     * We return a copy of the Buffer to ensure this remains immutable.
     */
    toBuffer() {
        if (!this.asBuffer) {
            this.asBuffer = toBufferBE(this.asBigInt, 32);
        }
        return Buffer.from(this.asBuffer);
    }
    toString() {
        return `0x${this.toBuffer().toString('hex')}`;
    }
    toBigInt() {
        if (this.asBigInt === undefined) {
            this.asBigInt = toBigIntBE(this.asBuffer);
            if (this.asBigInt >= this.modulus()) {
                throw new Error('Value >= to field modulus.');
            }
        }
        return this.asBigInt;
    }
    toShortString() {
        const str = this.toString();
        return `${str.slice(0, 10)}...${str.slice(-4)}`;
    }
    equals(rhs) {
        return this.toBuffer().equals(rhs.toBuffer());
    }
    isZero() {
        return this.toBuffer().equals(ZERO_BUFFER);
    }
    toFriendlyJSON() {
        return this.toString();
    }
    toField() {
        return this;
    }
}
BaseField.SIZE_IN_BYTES = 32;
/**
 * Constructs a field from a Buffer of BufferReader.
 * It maybe not read the full 32 bytes if the Buffer is shorter, but it will padded in BaseField constructor.
 */
function fromBuffer(buffer, f) {
    const reader = BufferReader.asReader(buffer);
    return new f(reader.readBytes(BaseField.SIZE_IN_BYTES));
}
/**
 * Constructs a field from a Buffer, but reduces it first.
 * This requires a conversion to a bigint first so the initial underlying representation will be a bigint.
 */
function fromBufferReduce(buffer, f) {
    return new f(toBigIntBE(buffer) % f.MODULUS);
}
/**
 * To ensure a field is uniformly random, it's important to reduce a 512 bit value.
 * If you reduced a 256 bit number, there would a be a high skew in the lower range of the field.
 */
function random(f) {
    return fromBufferReduce(randomBytes(64), f);
}
/**
 * Constructs a field from a 0x prefixed hex string.
 */
function fromString(buf, f) {
    const buffer = Buffer.from(buf.replace(/^0x/i, ''), 'hex');
    return new f(buffer);
}
/**
 * Fr field class.
 */
export class Fr extends BaseField {
    constructor(value) {
        super(value);
    }
    modulus() {
        return Fr.MODULUS;
    }
    static random() {
        return random(Fr);
    }
    static zero() {
        return Fr.ZERO;
    }
    static fromBuffer(buffer) {
        return fromBuffer(buffer, Fr);
    }
    static fromBufferReduce(buffer) {
        return fromBufferReduce(buffer, Fr);
    }
    static fromString(buf) {
        return fromString(buf, Fr);
    }
}
Fr.ZERO = new Fr(0n);
Fr.MODULUS = 0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f0000001n;
/**
 * Fq field class.
 */
export class Fq extends BaseField {
    get low() {
        return new Fr(this.toBigInt() & Fq.LOW_MASK);
    }
    get high() {
        return new Fr(this.toBigInt() >> Fq.HIGH_SHIFT);
    }
    constructor(value) {
        super(value);
    }
    modulus() {
        return Fq.MODULUS;
    }
    static random() {
        return random(Fq);
    }
    static zero() {
        return Fq.ZERO;
    }
    static fromBuffer(buffer) {
        return fromBuffer(buffer, Fq);
    }
    static fromBufferReduce(buffer) {
        return fromBufferReduce(buffer, Fq);
    }
    static fromString(buf) {
        return fromString(buf, Fq);
    }
    static fromHighLow(high, low) {
        return new Fq((high.toBigInt() << Fq.HIGH_SHIFT) + low.toBigInt());
    }
}
Fq.ZERO = new Fq(0n);
Fq.MODULUS = 0x30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd47n;
Fq.HIGH_SHIFT = BigInt((BaseField.SIZE_IN_BYTES / 2) * 8);
Fq.LOW_MASK = (1n << Fq.HIGH_SHIFT) - 1n;
export const GrumpkinScalar = Fq;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZmllbGRzLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL2ZpZWxkcy9maWVsZHMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLFVBQVUsRUFBRSxVQUFVLEVBQUUsTUFBTSwyQkFBMkIsQ0FBQztBQUNuRSxPQUFPLEVBQUUsV0FBVyxFQUFFLE1BQU0sMkJBQTJCLENBQUM7QUFDeEQsT0FBTyxFQUFFLFlBQVksRUFBRSxNQUFNLCtCQUErQixDQUFDO0FBRTdELE1BQU0sV0FBVyxHQUFHLE1BQU0sQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDLENBQUM7QUFlckM7Ozs7Ozs7O0dBUUc7QUFDSCxNQUFlLFNBQVM7SUFLdEI7OztTQUdLO0lBQ0wsSUFBSSxLQUFLO1FBQ1AsT0FBTyxJQUFJLENBQUMsUUFBUSxFQUFFLENBQUM7SUFDekIsQ0FBQztJQUVELFlBQXNCLEtBQXFEO1FBQ3pFLElBQUksS0FBSyxZQUFZLE1BQU0sRUFBRTtZQUMzQixJQUFJLEtBQUssQ0FBQyxNQUFNLEdBQUcsU0FBUyxDQUFDLGFBQWEsRUFBRTtnQkFDMUMsTUFBTSxJQUFJLEtBQUssQ0FBQyxnQkFBZ0IsS0FBSyxDQUFDLE1BQU0sWUFBWSxTQUFTLENBQUMsYUFBYSxFQUFFLENBQUMsQ0FBQzthQUNwRjtZQUNELElBQUksQ0FBQyxRQUFRO2dCQUNYLEtBQUssQ0FBQyxNQUFNLEtBQUssU0FBUyxDQUFDLGFBQWE7b0JBQ3RDLENBQUMsQ0FBQyxLQUFLO29CQUNQLENBQUMsQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxTQUFTLENBQUMsYUFBYSxHQUFHLEtBQUssQ0FBQyxNQUFNLENBQUMsRUFBRSxLQUFLLENBQUMsQ0FBQyxDQUFDO1NBQ3BGO2FBQU0sSUFBSSxPQUFPLEtBQUssS0FBSyxRQUFRLElBQUksT0FBTyxLQUFLLEtBQUssUUFBUSxJQUFJLE9BQU8sS0FBSyxLQUFLLFNBQVMsRUFB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