/// <reference types="node" resolution-mode="require"/>
import { BufferReader } from '../serialize/buffer_reader.js';
/**
 * Base field class.
 * Conversions from Buffer to BigInt and vice-versa are not cheap.
 * We allow construction with either form and lazily convert to other as needed.
 * We only check we are within the field modulus when initializing with bigint.
 * If NODE_ENV === 'test', we will always initialize both types to check the modulus.
 * This is also necessary in test environment as a lot of tests just use deep equality to check equality.
 * WARNING: This could lead to a bugs in production that don't reveal in tests, but it's low risk.
 */
declare abstract class BaseField {
    static SIZE_IN_BYTES: number;
    private asBuffer?;
    private asBigInt?;
    /**
     * Return bigint representation.
     * @deprecated Just to get things compiling. Use toBigInt().
     * */
    get value(): bigint;
    protected constructor(value: number | bigint | boolean | BaseField | Buffer);
    protected abstract modulus(): bigint;
    /**
     * We return a copy of the Buffer to ensure this remains immutable.
     */
    toBuffer(): Buffer;
    toString(): `0x${string}`;
    toBigInt(): bigint;
    toShortString(): string;
    equals(rhs: BaseField): boolean;
    isZero(): boolean;
    toFriendlyJSON(): string;
    toField(): this;
}
/**
 * Branding to ensure fields are not interchangeable types.
 */
export interface Fr {
    /** Brand. */
    _branding: 'Fr';
}
/**
 * Fr field class.
 */
export declare class Fr extends BaseField {
    static ZERO: Fr;
    static MODULUS: bigint;
    constructor(value: number | bigint | boolean | Fr | Buffer);
    protected modulus(): bigint;
    static random(): Fr;
    static zero(): Fr;
    static fromBuffer(buffer: Buffer | BufferReader): Fr;
    static fromBufferReduce(buffer: Buffer): Fr;
    static fromString(buf: string): Fr;
}
/**
 * Branding to ensure fields are not interchangeable types.
 */
export interface Fq {
    /** Brand. */
    _branding: 'Fq';
}
/**
 * Fq field class.
 */
export declare class Fq extends BaseField {
    static ZERO: Fq;
    static MODULUS: bigint;
    private static HIGH_SHIFT;
    private static LOW_MASK;
    get low(): Fr;
    get high(): Fr;
    constructor(value: number | bigint | boolean | Fq | Buffer);
    protected modulus(): bigint;
    static random(): Fq;
    static zero(): Fq;
    static fromBuffer(buffer: Buffer | BufferReader): Fq;
    static fromBufferReduce(buffer: Buffer): Fq;
    static fromString(buf: string): Fq;
    static fromHighLow(high: Fr, low: Fr): Fq;
}
/**
 * GrumpkinScalar is an Fq.
 * @remarks Called GrumpkinScalar because it is used to represent elements in Grumpkin's scalar field as defined in
 *          the Aztec Yellow Paper.
 */
export type GrumpkinScalar = Fq;
export declare const GrumpkinScalar: typeof Fq;
export {};
//# sourceMappingURL=fields.d.ts.map