import { Fr } from '../fields/index.js';
import { isAddressStruct } from './utils.js';
/**
 * Encodes arguments for a function call.
 * Missing support for integer and string.
 */
class ArgumentEncoder {
    constructor(abi, args) {
        this.abi = abi;
        this.args = args;
        this.flattened = [];
    }
    static typeSize(abiType) {
        switch (abiType.kind) {
            case 'field':
            case 'boolean':
            case 'integer':
                return 1;
            case 'string':
                return abiType.length;
            case 'array':
                return abiType.length * ArgumentEncoder.typeSize(abiType.type);
            case 'struct':
                return abiType.fields.reduce((acc, field) => acc + ArgumentEncoder.typeSize(field.type), 0);
            default: {
                const exhaustiveCheck = abiType;
                throw new Error(`Unhandled abi type: ${exhaustiveCheck}`);
            }
        }
    }
    /**
     * Encodes a single argument from the given type to field.
     * @param abiType - The abi type of the argument.
     * @param arg - The value to encode.
     * @param name - Name.
     */
    encodeArgument(abiType, arg, name) {
        if (arg === undefined || arg == null) {
            throw new Error(`Undefined argument ${name ?? 'unnamed'} of type ${abiType.kind}`);
        }
        switch (abiType.kind) {
            case 'field':
                if (typeof arg === 'number') {
                    this.flattened.push(new Fr(BigInt(arg)));
                }
                else if (typeof arg === 'bigint') {
                    this.flattened.push(new Fr(arg));
                }
                else if (typeof arg === 'boolean') {
                    this.flattened.push(new Fr(arg ? 1n : 0n));
                }
                else if (typeof arg === 'object') {
                    if (Buffer.isBuffer(arg)) {
                        this.flattened.push(Fr.fromBuffer(arg));
                    }
                    else if (typeof arg.toField === 'function') {
                        this.flattened.push(arg.toField());
                    }
                    else {
                        throw new Error(`Argument for ${name} cannot be serialized to a field`);
                    }
                }
                else {
                    throw new Error(`Invalid argument "${arg}" of type ${abiType.kind}`);
                }
                break;
            case 'boolean':
                this.flattened.push(new Fr(arg ? 1n : 0n));
                break;
            case 'array':
                for (let i = 0; i < abiType.length; i += 1) {
                    this.encodeArgument(abiType.type, arg[i], `${name}[${i}]`);
                }
                break;
            case 'struct':
                // If the abi expects a struct like { address: Field } and the supplied arg does not have
                // an address field in it, we try to encode it as if it were a field directly.
                if (isAddressStruct(abiType) && typeof arg.address === 'undefined') {
                    this.encodeArgument({ kind: 'field' }, arg, `${name}.address`);
                    break;
                }
                for (const field of abiType.fields) {
                    this.encodeArgument(field.type, arg[field.name], `${name}.${field.name}`);
                }
                break;
            case 'integer':
                this.flattened.push(new Fr(arg));
                break;
            default:
                throw new Error(`Unsupported type: ${abiType.kind}`);
        }
    }
    /**
     * Encodes all the arguments for the given function ABI.
     * @returns The encoded arguments.
     */
    encode() {
        for (let i = 0; i < this.abi.parameters.length; i += 1) {
            const parameterAbi = this.abi.parameters[i];
            this.encodeArgument(parameterAbi.type, this.args[i], parameterAbi.name);
        }
        return this.flattened;
    }
}
/**
 * Encodes all the arguments for a function call.
 * @param abi - The function ABI entry.
 * @param args - The arguments to encode.
 * @returns The encoded arguments.
 */
export function encodeArguments(abi, args) {
    return new ArgumentEncoder(abi, args).encode();
}
/**
 * Returns the size of the arguments for a function ABI.
 * @param abi - The function ABI entry.
 * @returns The size of the arguments.
 */
export function countArgumentsSize(abi) {
    return abi.parameters.reduce((acc, parameter) => acc + ArgumentEncoder.typeSize(parameter.type), 0);
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZW5jb2Rlci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9hYmkvZW5jb2Rlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsRUFBRSxFQUFFLE1BQU0sb0JBQW9CLENBQUM7QUFFeEMsT0FBTyxFQUFFLGVBQWUsRUFBRSxNQUFNLFlBQVksQ0FBQztBQUU3Qzs7O0dBR0c7QUFDSCxNQUFNLGVBQWU7SUFHbkIsWUFBb0IsR0FBZ0IsRUFBVSxJQUFXO1FBQXJDLFFBQUcsR0FBSCxHQUFHLENBQWE7UUFBVSxTQUFJLEdBQUosSUFBSSxDQUFPO1FBRmpELGNBQVMsR0FBUyxFQUFFLENBQUM7SUFFK0IsQ0FBQztJQUU3RCxNQUFNLENBQUMsUUFBUSxDQUFDLE9BQWdCO1FBQzlCLFFBQVEsT0FBTyxDQUFDLElBQUksRUFBRTtZQUNwQixLQUFLLE9BQU8sQ0FBQztZQUNiLEtBQUssU0FBUyxDQUFDO1lBQ2YsS0FBSyxTQUFTO2dCQUNaLE9BQU8sQ0FBQyxDQUFDO1lBQ1gsS0FBSyxRQUFRO2dCQUNYLE9BQU8sT0FBTyxDQUFDLE1BQU0sQ0FBQztZQUN4QixLQUFLLE9BQU87Z0JBQ1YsT0FBTyxPQUFPLENBQUMsTUFBTSxHQUFHLGVBQWUsQ0FBQyxRQUFRLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDO1lBQ2pFLEtBQUssUUFBUTtnQkFDWCxPQUFPLE9BQU8sQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUMsR0FBRyxFQUFFLEtBQUssRUFBRSxFQUFFLENBQUMsR0FBRyxHQUFHLGVBQWUsQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO1lBQzlGLE9BQU8sQ0FBQyxDQUFDO2dCQUNQLE1BQU0sZUFBZSxHQUFVLE9BQU8sQ0FBQztnQkFDdkMsTUFBTSxJQUFJLEtBQUssQ0FBQyx1QkFBdUIsZUFBZSxFQUFFLENBQUMsQ0FBQzthQUMzRDtTQUNGO0lBQ0gs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