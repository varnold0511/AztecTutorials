import { toBigIntBE, toBufferBE } from '@aztec/foundation/bigint-buffer';
import { BufferReader } from '@aztec/foundation/serialize';
import { keccak } from '../crypto/keccak/index.js';
import { Fr } from '../fields/index.js';
import { decodeFunctionSignature } from './decoder.js';
/**
 * A function selector is the first 4 bytes of the hash of a function signature.
 */
export class FunctionSelector {
    constructor(/** number representing the function selector */ value) {
        this.value = value;
        if (value > 2 ** (FunctionSelector.SIZE * 8) - 1) {
            throw new Error(`Function selector must fit in ${FunctionSelector.SIZE} bytes.`);
        }
    }
    /**
     * Checks if the function selector is empty (all bytes are 0).
     * @returns True if the function selector is empty (all bytes are 0).
     */
    isEmpty() {
        return this.value === 0;
    }
    /**
     * Serialize as a buffer.
     * @param bufferSize - The buffer size.
     * @returns The buffer.
     */
    toBuffer(bufferSize = FunctionSelector.SIZE) {
        return toBufferBE(BigInt(this.value), bufferSize);
    }
    /**
     * Serialize as a hex string.
     * @returns The string.
     */
    toString() {
        return this.toBuffer().toString('hex');
    }
    /**
     * Checks if this function selector is equal to another.
     * @param other - The other function selector.
     * @returns True if the function selectors are equal.
     */
    equals(other) {
        return this.value === other.value;
    }
    /**
     * Deserializes from a buffer or reader, corresponding to a write in cpp.
     * @param buffer - Buffer  or BufferReader to read from.
     * @returns The FunctionSelector.
     */
    static fromBuffer(buffer) {
        const reader = BufferReader.asReader(buffer);
        const value = Number(toBigIntBE(reader.readBytes(FunctionSelector.SIZE)));
        return new FunctionSelector(value);
    }
    /**
     * Returns a new field with the same contents as this EthAddress.
     *
     * @returns An Fr instance.
     */
    toField() {
        return new Fr(BigInt(this.value));
    }
    /**
     * Converts a field to function selector.
     * @param fr - The field to convert.
     * @returns The function selector.
     */
    static fromField(fr) {
        return new FunctionSelector(Number(fr.toBigInt()));
    }
    /**
     * Creates a function selector from a signature.
     * @param signature - Signature of the function to generate the selector for (e.g. "transfer(field,field)").
     * @returns Function selector.
     */
    static fromSignature(signature) {
        // throw if signature contains whitespace
        if (/\s/.test(signature)) {
            throw new Error('Function Signature cannot contain whitespace');
        }
        return FunctionSelector.fromBuffer(keccak(Buffer.from(signature)).subarray(0, FunctionSelector.SIZE));
    }
    /**
     * Creates a function selector for a given function name and parameters.
     * @param name - The name of the function.
     * @param parameters - An array of ABIParameter objects, each containing the type information of a function parameter.
     * @returns A Buffer containing the 4-byte function selector.
     */
    static fromNameAndParameters(name, parameters) {
        const signature = decodeFunctionSignature(name, parameters);
        const selector = FunctionSelector.fromSignature(signature);
        // If using the debug logger here it kill the typing in the `server_world_state_synchronizer` and jest tests.
        // console.log(`Function selector for ${signature} is ${selector}`);
        return selector;
    }
    /**
     * Create an AztecAddress instance from a hex-encoded string.
     * The input 'address' should be prefixed with '0x' or not, and have exactly 64 hex characters.
     * Throws an error if the input length is invalid or address value is out of range.
     *
     * @param selector - The hex-encoded string representing the Aztec address.
     * @returns An AztecAddress instance.
     */
    static fromString(selector) {
        const buf = Buffer.from(selector.replace(/^0x/i, ''), 'hex');
        if (buf.length !== FunctionSelector.SIZE) {
            throw new Error(`Invalid FunctionSelector length ${buf.length}.`);
        }
        return FunctionSelector.fromBuffer(buf);
    }
    /**
     * Creates an empty function selector.
     * @returns An empty function selector.
     */
    static empty() {
        return new FunctionSelector(0);
    }
}
/**
 * The size of the function selector in bytes.
 */
FunctionSelector.SIZE = 4;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZnVuY3Rpb25fc2VsZWN0b3IuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvYWJpL2Z1bmN0aW9uX3NlbGVjdG9yLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxVQUFVLEVBQUUsVUFBVSxFQUFFLE1BQU0saUNBQWlDLENBQUM7QUFDekUsT0FBTyxFQUFFLFlBQVksRUFBRSxNQUFNLDZCQUE2QixDQUFDO0FBRTNELE9BQU8sRUFBRSxNQUFNLEVBQUUsTUFBTSwyQkFBMkIsQ0FBQztBQUNuRCxPQUFPLEVBQUUsRUFBRSxFQUFFLE1BQU0sb0JBQW9CLENBQUM7QUFFeEMsT0FBTyxFQUFFLHVCQUF1QixFQUFFLE1BQU0sY0FBYyxDQUFDO0FBRXZEOztHQUVHO0FBQ0gsTUFBTSxPQUFPLGdCQUFnQjtJQU0zQixZQUFZLGdEQUFnRCxDQUFRLEtBQWE7UUFBYixVQUFLLEdBQUwsS0FBSyxDQUFRO1FBQy9FLElBQUksS0FBSyxHQUFHLENBQUMsSUFBSSxDQUFDLGdCQUFnQixDQUFDLElBQUksR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLEVBQUU7WUFDaEQsTUFBTSxJQUFJLEtBQUssQ0FBQyxpQ0FBaUMsZ0JBQWdCLENBQUMsSUFBSSxTQUFTLENBQUMsQ0FBQztTQUNsRjtJQUNILENBQUM7SUFFRDs7O09BR0c7SUFDSSxPQUFPO1FBQ1osT0FBTyxJQUFJLENBQUMsS0FBSyxLQUFLLENBQUMsQ0FBQztJQUMxQixDQUFDO0lBRUQ7Ozs7T0FJRztJQUNILFFBQVEsQ0FBQyxVQUFVLEdBQUcsZ0JBQWdCLENBQUMsSUFBSTtRQUN6QyxPQUFPLFVBQVUsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxFQUFFLFVBQVUsQ0FBQyxDQUFDO0lBQ3BELENBQUM7SUFFRDs7O09BR0c7SUFDSCxRQUFRO1FBQ04sT0FBTyxJQUFJLENBQUMsUUFBUSxFQUFFLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxDQUFDO0lB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