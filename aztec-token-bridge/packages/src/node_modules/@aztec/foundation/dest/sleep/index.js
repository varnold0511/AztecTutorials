import { InterruptError } from '../errors/index.js';
/**
 * InterruptibleSleep is a utility class that allows you to create an interruptible sleep function.
 * The sleep function can be interrupted at any time by calling the `interrupt` method, which can
 * also specify whether the sleep should throw an error or just return. This is useful when you need
 * to terminate long-running processes or perform cleanup tasks in response to external events.
 *
 * @example
 * const sleeper = new InterruptibleSleep();
 *
 * async function longRunningTask() \{
 *   try \{
 *     await sleeper.sleep(3000);
 *     console.log('Task completed after 3 seconds');
 *   \} catch (e) \{
 *     console.log('Task was interrupted');
 *   \}
 * \}
 *
 * setTimeout(() =\> sleeper.interrupt(true), 1500); // Interrupt the sleep after 1.5 seconds
 */
export class InterruptibleSleep {
    constructor() {
        this.interruptResolve = () => { };
        this.interruptPromise = new Promise(resolve => (this.interruptResolve = resolve));
        this.timeouts = [];
    }
    /**
     * Sleep for a specified amount of time in milliseconds.
     * The sleep function will pause the execution of the current async function
     * for the given time period, allowing other tasks to run before resuming.
     *
     * @param ms - The number of milliseconds to sleep.
     * @returns A Promise that resolves after the specified time has passed.
     */
    async sleep(ms) {
        let timeout;
        const promise = new Promise(resolve => (timeout = setTimeout(() => resolve(false), ms)));
        this.timeouts.push(timeout);
        const shouldThrow = await Promise.race([promise, this.interruptPromise]);
        clearTimeout(timeout);
        this.timeouts.splice(this.timeouts.indexOf(timeout), 1);
        if (shouldThrow) {
            throw new InterruptError('Interrupted.');
        }
    }
    /**
     * Interrupts the current sleep operation and optionally throws an error if specified.
     * By default, when interrupted, the sleep operation will resolve without throwing.
     * If 'sleepShouldThrow' is set to true, the sleep operation will throw an InterruptError instead.
     *
     * @param sleepShouldThrow - A boolean value indicating whether the sleep operation should throw an error when interrupted. Default is false.
     */
    interrupt(sleepShouldThrow = false) {
        this.interruptResolve(sleepShouldThrow);
        this.interruptPromise = new Promise(resolve => (this.interruptResolve = resolve));
    }
}
/**
 * Puts the current execution context to sleep for a specified duration.
 * This simulates a blocking sleep operation by using an asynchronous function and a Promise that resolves after the given duration.
 * The sleep function can be interrupted by the 'interrupt' method of the InterruptibleSleep class.
 *
 * @param ms - The duration in milliseconds for which the sleep operation should last.
 * @returns A Promise that resolves after the specified duration, allowing the use of 'await' to pause execution.
 */
export function sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvc2xlZXAvaW5kZXgudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLGNBQWMsRUFBRSxNQUFNLG9CQUFvQixDQUFDO0FBRXBEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBbUJHO0FBQ0gsTUFBTSxPQUFPLGtCQUFrQjtJQUEvQjtRQUNVLHFCQUFnQixHQUFtQyxHQUFHLEVBQUUsR0FBRSxDQUFDLENBQUM7UUFDNUQscUJBQWdCLEdBQUcsSUFBSSxPQUFPLENBQVUsT0FBTyxDQUFDLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQyxnQkFBZ0IsR0FBRyxPQUFPLENBQUMsQ0FBQyxDQUFDO1FBQ3RGLGFBQVEsR0FBcUIsRUFBRSxDQUFDO0lBaUMxQyxDQUFDO0lBL0JDOzs7Ozs7O09BT0c7SUFDSSxLQUFLLENBQUMsS0FBSyxDQUFDLEVBQVU7UUFDM0IsSUFBSSxPQUF3QixDQUFDO1FBQzdCLE1BQU0sT0FBTyxHQUFHLElBQUksT0FBTyxDQUFVLE9BQU8sQ0FBQyxFQUFFLENBQUMsQ0FBQyxPQUFPLEdBQUcsVUFBVSxDQUFDLEdBQUcsRUFBRSxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDbEcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUM7UUFDNUIsTUFBTSxXQUFXLEdBQUcsTUFBTSxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUMsT0FBTyxFQUFFLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDLENBQUM7UUFDekUsWUFBWSxDQUFDLE9BQU8sQ0FBQyxDQUFDO1FBQ3RCLElBQUksQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO1FBQ3hELElBQUksV0FBVyxFQUFFO1lBQ2YsTUFBTSxJQUFJLGNBQWMsQ0FBQyxjQUFjLENBQUMsQ0FBQztTQUMxQztJQUNILENBQUM7SUFFRDs7Ozs7O09BTUc7SUFDSSxTQUFTLENBQUMsZ0JBQWdCLEdBQUcsS0FBSztRQUN2QyxJQUFJLENBQUMsZ0JBQWdCLENBQUMsZ0JBQWdCLENBQUMsQ0FBQztRQUN4QyxJQUFJLENBQUMsZ0JBQWdCLEdBQUcsSUFBSSxPQUFPLENBQUMsT0FBTyxDQUFDLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQyxnQkFBZ0IsR0FBRyxPQUFPLENBQUMsQ0FBQyxDQUFDO0lBQ3BGLENBQUM7Q0FDRjtBQUVEOzs7Ozs7O0dBT0c7QUFDSCxNQUFNLFVBQVUsS0FBSyxDQUFDLEVBQVU7SUFDOUIsT0FBTyxJQUFJLE9BQU8sQ0FBQyxPQUFPLENBQUMsRUFBRSxDQUFDLFVBQVUsQ0FBQyxPQUFPLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQztBQUN6RCxDQUFDIn0=