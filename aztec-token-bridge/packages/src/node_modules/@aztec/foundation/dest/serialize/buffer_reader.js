/**
 * The BufferReader class provides a utility for reading various data types from a buffer.
 * It supports reading numbers, booleans, byte arrays, Fr and Fq field elements,
 * vectors, arrays, objects, strings, and maps. It maintains an internal index to
 * keep track of the current reading position in the buffer.
 *
 * Usage:
 * Create a new instance of BufferReader with a buffer and an optional offset.
 * Use the provided methods to read desired data types from the buffer.
 * The reading methods automatically advance the internal index.
 *
 * @example
 * const reader = new BufferReader(someBuffer);
 * const num = reader.readNumber();
 * const bool = reader.readBoolean();
 * const byteArray = reader.readBytes(4);
 */
export class BufferReader {
    constructor(buffer, offset = 0) {
        this.buffer = buffer;
        this.index = offset;
    }
    /**
     * Creates a BufferReader instance from either a Buffer or an existing BufferReader.
     * If the input is a Buffer, it creates a new BufferReader with the given buffer.
     * If the input is already a BufferReader, it returns the input unchanged.
     *
     * @param bufferOrReader - A Buffer or BufferReader to initialize the BufferReader.
     * @returns An instance of BufferReader.
     */
    static asReader(bufferOrReader) {
        if (bufferOrReader instanceof BufferReader) {
            return bufferOrReader;
        }
        const buf = Buffer.isBuffer(bufferOrReader)
            ? bufferOrReader
            : Buffer.from(bufferOrReader.buffer, bufferOrReader.byteOffset, bufferOrReader.byteLength);
        return new BufferReader(buf);
    }
    /**
     * Reads a 32-bit unsigned integer from the buffer at the current index position.
     * Updates the index position by 4 bytes after reading the number.
     *
     * @returns The read 32-bit unsigned integer value.
     */
    readNumber() {
        this.index += 4;
        return this.buffer.readUint32BE(this.index - 4);
    }
    /**
     * Reads a 16-bit unsigned integer from the buffer at the current index position.
     * Updates the index position by 2 bytes after reading the number.
     *
     * @returns The read 16 bit value.
     */
    readUInt16() {
        this.index += 2;
        return this.buffer.readUInt16BE(this.index - 2);
    }
    /**
     * Reads and returns the next boolean value from the buffer.
     * Advances the internal index by 1, treating the byte at the current index as a boolean value.
     * Returns true if the byte is non-zero, false otherwise.
     *
     * @returns A boolean value representing the byte at the current index.
     */
    readBoolean() {
        this.index += 1;
        return Boolean(this.buffer.at(this.index - 1));
    }
    /**
     * Reads a specified number of bytes from the buffer and returns a new Buffer containing those bytes.
     * Advances the reader's index by the number of bytes read. Throws an error if there are not enough
     * bytes left in the buffer to satisfy the requested number of bytes.
     *
     * @param n - The number of bytes to read from the buffer.
     * @returns A new Buffer containing the read bytes.
     */
    readBytes(n) {
        this.index += n;
        return Buffer.from(this.buffer.subarray(this.index - n, this.index));
    }
    /**
     * Reads a vector of numbers from the buffer and returns it as an array of numbers.
     * The method utilizes the 'readVector' method, passing a deserializer that reads numbers.
     *
     * @returns An array of numbers representing the vector read from the buffer.
     */
    readNumberVector() {
        return this.readVector({
            fromBuffer: (reader) => reader.readNumber(),
        });
    }
    /**
     * Reads a vector of fixed size from the buffer and deserializes its elements using the provided itemDeserializer object.
     * The 'itemDeserializer' object should have a 'fromBuffer' method that takes a BufferReader instance and returns the deserialized element.
     * The method first reads the size of the vector (a number) from the buffer, then iterates through its elements,
     * deserializing each one using the 'fromBuffer' method of 'itemDeserializer'.
     *
     * @param itemDeserializer - Object with 'fromBuffer' method to deserialize vector elements.
     * @returns An array of deserialized elements of type T.
     */
    readVector(itemDeserializer) {
        const size = this.readNumber();
        const result = new Array(size);
        for (let i = 0; i < size; i++) {
            result[i] = itemDeserializer.fromBuffer(this);
        }
        return result;
    }
    /**
     * Read an array of a fixed size with elements of type T from the buffer.
     * The 'itemDeserializer' object should have a 'fromBuffer' method that takes a BufferReader instance as input,
     * and returns an instance of the desired deserialized data type T.
     * This method will call the 'fromBuffer' method for each element in the array and return the resulting array.
     *
     * @param size - The fixed number of elements in the array.
     * @param itemDeserializer - An object with a 'fromBuffer' method to deserialize individual elements of type T.
     * @returns An array of instances of type T.
     */
    readArray(size, itemDeserializer) {
        const result = Array.from({ length: size }, () => itemDeserializer.fromBuffer(this));
        return result;
    }
    /**
     * Read a variable sized Buffer array where elements are represented by length + data.
     * The method consecutively looks for a number which is the size of the proceeding buffer,
     * then reads the bytes until it reaches the end of the reader's internal buffer.
     * NOTE: if `size` is not provided, this will run to the end of the reader's buffer.
     * @param size - Size of the buffer array in bytes (full remaining buffer length if left empty).
     * @returns An array of variable sized buffers.
     */
    readBufferArray(size = -1) {
        const result = [];
        const end = size >= 0 ? this.index + size : this.buffer.length;
        while (this.index < end) {
            const item = this.readBuffer();
            result.push(item);
        }
        // Ensure that all bytes have been read.
        if (this.index !== end) {
            throw new Error(`Reader buffer was not fully consumed. Consumed up to ${this.index} bytes. End of data: ${end} bytes.`);
        }
        return result;
    }
    /**
     * Reads a serialized object from a buffer and returns the deserialized object using the given deserializer.
     *
     * @typeparam T - The type of the deserialized object.
     * @param deserializer - An object with a 'fromBuffer' method that takes a BufferReader instance and returns an instance of the deserialized object.
     * @returns The deserialized object of type T.
     */
    readObject(deserializer) {
        return deserializer.fromBuffer(this);
    }
    /**
     * Returns a Buffer containing the next n bytes from the current buffer without modifying the reader's index position.
     * If n is not provided or exceeds the remaining length of the buffer, it returns all bytes from the current position till the end of the buffer.
     *
     * @param n - The number of bytes to peek from the current buffer. (Optional).
     * @returns A Buffer with the next n bytes or the remaining bytes if n is not provided or exceeds the buffer length.
     */
    peekBytes(n) {
        return this.buffer.subarray(this.index, n ? this.index + n : undefined);
    }
    /**
     * Reads a string from the buffer and returns it.
     * The method first reads the size of the string, then reads the corresponding
     * number of bytes from the buffer and converts them to a string.
     *
     * @returns The read string from the buffer.
     */
    readString() {
        return this.readBuffer().toString();
    }
    /**
     * Reads a buffer from the current position of the reader and advances the index.
     * The method first reads the size (number) of bytes to be read, and then returns
     * a Buffer with that size containing the bytes. Useful for reading variable-length
     * binary data encoded as (size, data) format.
     *
     * @returns A Buffer containing the read bytes.
     */
    readBuffer() {
        const size = this.readNumber();
        return this.readBytes(size);
    }
    /**
     * Reads and constructs a map object from the current buffer using the provided deserializer.
     * The method reads the number of entries in the map, followed by iterating through each key-value pair.
     * The key is read as a string, while the value is obtained using the passed deserializer's `fromBuffer` method.
     * The resulting map object is returned, containing all the key-value pairs read from the buffer.
     *
     * @param deserializer - An object with a `fromBuffer` method to deserialize the values in the map.
     * @returns A map object with string keys and deserialized values based on the provided deserializer.
     */
    readMap(deserializer) {
        const numEntries = this.readNumber();
        const map = {};
        for (let i = 0; i < numEntries; i++) {
            const key = this.readString();
            const value = this.readObject(deserializer);
            map[key] = value;
        }
        return map;
    }
    /**
     * Get the length of the reader's buffer.
     * @returns The length of the underlying reader's buffer.
     */
    getLength() {
        return this.buffer.length;
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYnVmZmVyX3JlYWRlci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9zZXJpYWxpemUvYnVmZmVyX3JlYWRlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFFQTs7Ozs7Ozs7Ozs7Ozs7OztHQWdCRztBQUNILE1BQU0sT0FBTyxZQUFZO0lBRXZCLFlBQW9CLE1BQWMsRUFBRSxNQUFNLEdBQUcsQ0FBQztRQUExQixXQUFNLEdBQU4sTUFBTSxDQUFRO1FBQ2hDLElBQUksQ0FBQyxLQUFLLEdBQUcsTUFBTSxDQUFDO0lBQ3RCLENBQUM7SUFFRDs7Ozs7OztPQU9HO0lBQ0ksTUFBTSxDQUFDLFFBQVEsQ0FBQyxjQUFrRDtRQUN2RSxJQUFJLGNBQWMsWUFBWSxZQUFZLEVBQUU7WUFDMUMsT0FBTyxjQUFjLENBQUM7U0FDdkI7UUFFRCxNQUFNLEdBQUcsR0FBRyxNQUFNLENBQUMsUUFBUSxDQUFDLGNBQWMsQ0FBQztZQUN6QyxDQUFDLENBQUMsY0FBYztZQUNoQixDQUFDLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxjQUFjLENBQUMsTUFBTSxFQUFFLGNBQWMsQ0FBQyxVQUFVLEVBQUUsY0FBYyxDQUFDLFVBQVUsQ0FBQyxDQUFDO1FBRTdGLE9BQU8sSUFBSSxZQUFZLENBQUMsR0FBRyxDQUFDLENBQUM7SUFDL0IsQ0FBQztJQUVEOzs7OztPQUtHO0lBQ0ksVUFBVTtRQUNmLElBQUksQ0FBQyxLQUFLLElBQUksQ0FBQyxDQUFDO1FBQ2hCLE9BQU8sSUFBSSxDQUFDLE1BQU0sQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLEtBQUssR0FBRyxDQUFDLENBQUMsQ0FBQztJQUNsRCxDQUFDO0lBRUQ7Ozs7O09BS0c7SUFDSSxVQUFVO1FBQ2YsSUFBSSxDQUFDLEtBQUssSUFBSSxDQUFDLENBQUM7UUFDaEIsT0FBTyxJQUFJLENBQUMsTUFBTSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsS0FBSyxHQUFHLENBQUMsQ0FBQyxDQUFDO0lBQ2xELENBQUM7SUFFRDs7Ozs7O09BTUc7SUFDSSxXQUFXO1FBQ2hCLElBQUksQ0FBQyxLQUFLLElBQUksQ0FBQyxDQUFDO1FBQ2hCLE9BQU8sT0FBTyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxLQUFLLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUNqRCxDQUFDO0lBRUQ7Ozs7Ozs7T0FPRztJQUNJLFNBQVMsQ0FBQyxDQUFTO1FBQ3hCLElBQUksQ0FBQyxLQUFLLElBQUksQ0FBQyxDQUFDO1FBQ2hCLE9BQU8sTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsS0FBSyxHQUFHLENBQUMsRUFBRSxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQztJQUN2RSxDQUFDO0lBRUQ7Ozs7O09BS0c7SUFDSSxnQkFBZ0I7UUFDckIsT0FBTyxJQUFJLENBQUMsVUFBVSxDQUFDO1lBQ3JCLFVBQVUsRUFBRSxDQUFDLE1BQW9CLEVBQUUsRUFBRSxDQUFDLE1BQU0sQ0FBQyxVQUFVLEVBQUU7U0FDMUQsQ0FBQyxDQUFDO0lBQ0wsQ0FBQztJQUVEOzs7Ozs7OztPQVFHO0lBQ0ksVUFBVSxDQUFJLGdCQUtwQjtRQUNDLE1BQU0sSUFBSSxHQUFHLElBQUksQ0FBQyxVQUFVLEVBQUUsQ0FBQztRQUMvQixNQUFNLE1BQU0sR0FBRyxJQUFJLEtBQUssQ0FBSSxJQUFJLENBQUMsQ0FBQztRQUNsQyxLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsSUFBSSxFQUFFLENBQUMsRUFBRSxFQUFFO1lBQzdCLE1BQU0sQ0FBQyxDQUFDLENBQUMsR0FBRyxnQkFBZ0IsQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLENBQUM7U0FDL0M7UUFDRCxPQUFPLE1BQU0sQ0FBQztJQUNoQixDQUFDO0lBRUQ7Ozs7Ozs7OztPQVNHO0lBQ0ksU0FBUyxDQUNkLElBQU8sRUFDUCxnQkFLQztRQUVELE1BQU0sTUFBTSxHQUFHLEtBQUssQ0FBQyxJQUFJLENBQUMsRUFBRSxNQUFNLEVBQUUsSUFBSSxFQUFFLEVBQUUsR0FBRyxFQUFFLENBQUMsZ0JBQWdCLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7UUFDckYsT0FBTyxNQUFxQixDQUFDO0lBQy9CLENBQUM7SUFFRDs7Ozs7OztPQU9HO0lBQ0ksZUFBZSxDQUFDLElBQUksR0FBRyxDQUFDLENBQUM7UUFDOUIsTUFBTSxNQUFNLEdBQWEsRUFBRSxDQUFDO1FBQzVCLE1BQU0sR0FBRyxHQUFHLElBQUksSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxLQUFLLEdBQUcsSUFBSSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQztRQUMvRCxPQUFPLElBQUksQ0FBQyxLQUFLLEdBQUcsR0FBRyxFQUFFO1lBQ3ZCLE1BQU0sSUFBSSxHQUFHLElBQUksQ0FBQyxVQUFVLEVBQUUsQ0FBQztZQUMvQixNQUFNLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO1NBQ25CO1FBQ0Qsd0NBQXdDO1FBQ3hDLElBQUksSUFBSSxDQUFDLEtBQUssS0FBSyxHQUFHLEVBQUU7WUFDdEIsTUFBTSxJQUFJLEtBQUssQ0FDYix3REFBd0QsSUFBSSxDQUFDLEtBQUssd0JBQXdCLEdBQUcsU0FBUyxDQUN2RyxDQUFDO1NBQ0g7UUFDRCxPQUFPLE1BQU0sQ0FBQztJQUNoQixDQUFDO0lBRUQ7Ozs7OztPQU1HO0lBQ0ksVUFBVSxDQUFJLFlBS3BCO1FBQ0MsT0FBTyxZQUFZLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxDQUFDO0lBQ3ZDLENBQUM7SUFFRDs7Ozs7O09BTUc7SUFDSSxTQUFTLENBQUMsQ0FBVTtRQUN6QixPQUFPLElBQUksQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxLQUFLLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsS0FBSyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLENBQUM7SUFDMUUsQ0FBQztJQUVEOzs7Ozs7T0FNRztJQUNJLFVBQVU7UUFDZixPQUFPLElBQUksQ0FBQyxVQUFVLEVBQUUsQ0FBQyxRQUFRLEVBQUUsQ0FBQztJQUN0QyxDQUFDO0lBRUQ7Ozs7Ozs7T0FPRztJQUNJLFVBQVU7UUFDZixNQUFNLElBQUksR0FBRyxJQUFJLENBQUMsVUFBVSxFQUFFLENBQUM7UUFDL0IsT0FBTyxJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxDQUFDO0lBQzlCLENBQUM7SUFFRDs7Ozs7Ozs7T0FRRztJQUNJLE9BQU8sQ0FBSSxZQUtqQjtRQUNDLE1BQU0sVUFBVSxHQUFHLElBQUksQ0FBQyxVQUFVLEVBQUUsQ0FBQztRQUNyQyxNQUFNLEdBQUcsR0FBeUIsRUFBRSxDQUFDO1FBQ3JDLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxVQUFVLEVBQUUsQ0FBQyxFQUFFLEVBQUU7WUFDbkMsTUFBTSxHQUFHLEdBQUcsSUFBSSxDQUFDLFVBQVUsRUFBRSxDQUFDO1lBQzlCLE1BQU0sS0FBSyxHQUFHLElBQUksQ0FBQyxVQUFVLENBQUksWUFBWSxDQUFDLENBQUM7WUFDL0MsR0FBRyxDQUFDLEdBQUcsQ0FBQyxHQUFHLEtBQUssQ0FBQztTQUNsQjtRQUNELE9BQU8sR0FBRyxDQUFDO0lBQ2IsQ0FBQztJQUVEOzs7T0FHRztJQUNJLFNBQVM7UUFDZCxPQUFPLElBQUksQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDO0lBQzVCLENBQUM7Q0FDRiJ9