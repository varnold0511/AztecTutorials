import { keccak256String } from '../crypto/keccak/index.js';
import { randomBytes } from '../crypto/random/index.js';
import { Fr } from '../fields/index.js';
import { BufferReader } from '../serialize/index.js';
/**
 * Represents an Ethereum address as a 20-byte buffer and provides various utility methods
 * for converting between different representations, generating random addresses, validating
 * checksums, and comparing addresses. EthAddress can be instantiated using a buffer or string,
 * and can be serialized/deserialized from a buffer or BufferReader.
 */
export class EthAddress {
    constructor(buffer) {
        this.buffer = buffer;
        if (buffer.length === 32) {
            if (!buffer.slice(0, 12).equals(Buffer.alloc(12))) {
                throw new Error(`Invalid address buffer: ${buffer.toString('hex')}`);
            }
            else {
                this.buffer = buffer.slice(12);
            }
        }
        else if (buffer.length !== EthAddress.SIZE_IN_BYTES) {
            throw new Error(`Expect buffer size to be ${EthAddress.SIZE_IN_BYTES}. Got ${buffer.length}.`);
        }
    }
    /**
     * Creates an EthAddress instance from a valid Ethereum address string.
     * The input 'address' can be either in checksum format or lowercase, and it can be prefixed with '0x'.
     * Throws an error if the input is not a valid Ethereum address.
     *
     * @param address - The string representing the Ethereum address.
     * @returns An EthAddress instance.
     */
    static fromString(address) {
        if (!EthAddress.isAddress(address)) {
            throw new Error(`Invalid address string: ${address}`);
        }
        return new EthAddress(Buffer.from(address.replace(/^0x/i, ''), 'hex'));
    }
    /**
     * Create a random EthAddress instance with 20 random bytes.
     * This method generates a new Ethereum address with a randomly generated set of 20 bytes.
     * It is useful for generating test addresses or unique identifiers.
     *
     * @returns A randomly generated EthAddress instance.
     */
    static random() {
        return new EthAddress(randomBytes(20));
    }
    /**
     * Determines if the given string represents a valid Ethereum address.
     * A valid address should meet the following criteria:
     * 1. Contains exactly 40 hex characters (excluding an optional '0x' prefix).
     * 2. Is either all lowercase, all uppercase, or has a valid checksum based on EIP-55.
     *
     * @param address - The string to be checked for validity as an Ethereum address.
     * @returns True if the input string represents a valid Ethereum address, false otherwise.
     */
    static isAddress(address) {
        if (!/^(0x)?[0-9a-f]{40}$/i.test(address)) {
            // Does not have the basic requirements of an address.
            return false;
        }
        else if (/^(0x|0X)?[0-9a-f]{40}$/.test(address) || /^(0x|0X)?[0-9A-F]{40}$/.test(address)) {
            // It's ALL lowercase or ALL uppercase.
            return true;
        }
        else {
            return EthAddress.checkAddressChecksum(address);
        }
    }
    /**
     * Checks if the EthAddress instance represents a zero address.
     * A zero address consists of 20 bytes filled with zeros and is considered an invalid address.
     *
     * @returns A boolean indicating whether the EthAddress instance is a zero address or not.
     */
    isZero() {
        return this.equals(EthAddress.ZERO);
    }
    /**
     * Checks if the given Ethereum address has a valid checksum.
     * The input 'address' should be prefixed with '0x' or not, and have exactly 40 hex characters.
     * Returns true if the address has a valid checksum, false otherwise.
     *
     * @param address - The hex-encoded string representing the Ethereum address.
     * @returns A boolean value indicating whether the address has a valid checksum.
     */
    static checkAddressChecksum(address) {
        address = address.replace(/^0x/i, '');
        const addressHash = keccak256String(address.toLowerCase());
        for (let i = 0; i < 40; i++) {
            // The nth letter should be uppercase if the nth digit of casemap is 1.
            if ((parseInt(addressHash[i], 16) > 7 && address[i].toUpperCase() !== address[i]) ||
                (parseInt(addressHash[i], 16) <= 7 && address[i].toLowerCase() !== address[i])) {
                return false;
            }
        }
        return true;
    }
    /**
     * Converts an Ethereum address to its checksum format.
     * The input 'address' should be prefixed with '0x' or not, and have exactly 40 hex characters.
     * The checksum format is created by capitalizing certain characters in the hex string
     * based on the hash of the lowercase address.
     * Throws an error if the input address is invalid.
     *
     * @param address - The Ethereum address as a hex-encoded string.
     * @returns The Ethereum address in its checksum format.
     */
    static toChecksumAddress(address) {
        if (!EthAddress.isAddress(address)) {
            throw new Error('Invalid address string.');
        }
        address = address.toLowerCase().replace(/^0x/i, '');
        const addressHash = keccak256String(address);
        let checksumAddress = '0x';
        for (let i = 0; i < address.length; i++) {
            // If ith character is 9 to f then make it uppercase.
            if (parseInt(addressHash[i], 16) > 7) {
                checksumAddress += address[i].toUpperCase();
            }
            else {
                checksumAddress += address[i];
            }
        }
        return checksumAddress;
    }
    /**
     * Checks whether the given EthAddress instance is equal to the current instance.
     * Equality is determined by comparing the underlying byte buffers of both instances.
     *
     * @param rhs - The EthAddress instance to compare with the current instance.
     * @returns A boolean value indicating whether the two instances are equal (true) or not (false).
     */
    equals(rhs) {
        return this.buffer.equals(rhs.buffer);
    }
    /**
     * Converts the Ethereum address to a hex-encoded string.
     * The resulting string is prefixed with '0x' and has exactly 40 hex characters.
     * This method can be used to represent the EthAddress instance in the widely used hexadecimal format.
     *
     * @returns A hex-encoded string representation of the Ethereum address.
     */
    toString() {
        return `0x${this.buffer.toString('hex')}`;
    }
    /**
     * Returns the Ethereum address as a checksummed string.
     * The output string will have characters in the correct upper or lowercase form, according to EIP-55.
     * This provides a way to verify if an address is typed correctly, by checking the character casing.
     *
     * @returns A checksummed Ethereum address string.
     */
    toChecksumString() {
        return EthAddress.toChecksumAddress(this.buffer.toString('hex'));
    }
    /**
     * Alias for toBuffer32.
     * @returns A 32-byte Buffer containing the padded Ethereum address.
     */
    toBuffer() {
        return this.toBuffer32();
    }
    /**
     * Returns the internal Buffer representation of the Ethereum address.
     * This method is useful when working with raw binary data or when
     * integrating with other modules that require a Buffer as input.
     *
     * @returns A Buffer instance containing the 20-byte Ethereum address.
     */
    toBuffer20() {
        return this.buffer;
    }
    /**
     * Returns a 32-byte buffer representation of the Ethereum address, with the original 20-byte address
     * occupying the last 20 bytes and the first 12 bytes being zero-filled.
     * This format is commonly used in smart contracts when handling addresses as 32-byte values.
     *
     * @returns A 32-byte Buffer containing the padded Ethereum address.
     */
    toBuffer32() {
        const buffer = Buffer.alloc(32);
        this.buffer.copy(buffer, 12);
        return buffer;
    }
    /**
     * Returns a new field with the same contents as this EthAddress.
     *
     * @returns An Fr instance.
     */
    toField() {
        return Fr.fromBuffer(this.toBuffer32());
    }
    /**
     * Converts a field to a eth address.
     * @param fr - The field to convert.
     * @returns The eth address.
     */
    static fromField(fr) {
        return new EthAddress(fr.toBuffer().slice(-EthAddress.SIZE_IN_BYTES));
    }
    /**
     * Deserializes from a buffer or reader, corresponding to a write in cpp.
     * @param buffer - Buffer to read from.
     * @returns The EthAddress.
     */
    static fromBuffer(buffer) {
        const reader = BufferReader.asReader(buffer);
        return new EthAddress(reader.readBuffer());
    }
    /**
     * Friendly representation for debugging purposes.
     * @returns A hex string representing the address.
     */
    toFriendlyJSON() {
        return this.toString();
    }
}
/**
 * The size of an Ethereum address in bytes.
 */
EthAddress.SIZE_IN_BYTES = 20;
/**
 * Represents a zero Ethereum address with 20 bytes filled with zeros.
 */
EthAddress.ZERO = new EthAddress(Buffer.alloc(EthAddress.SIZE_IN_BYTES));
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvZXRoLWFkZHJlc3MvaW5kZXgudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLGVBQWUsRUFBRSxNQUFNLDJCQUEyQixDQUFDO0FBQzVELE9BQU8sRUFBRSxXQUFXLEVBQUUsTUFBTSwyQkFBMkIsQ0FBQztBQUN4RCxPQUFPLEVBQUUsRUFBRSxFQUFFLE1BQU0sb0JBQW9CLENBQUM7QUFDeEMsT0FBTyxFQUFFLFlBQVksRUFBRSxNQUFNLHVCQUF1QixDQUFDO0FBRXJEOzs7OztHQUtHO0FBQ0gsTUFBTSxPQUFPLFVBQVU7SUFVckIsWUFBb0IsTUFBYztRQUFkLFdBQU0sR0FBTixNQUFNLENBQVE7UUFDaEMsSUFBSSxNQUFNLENBQUMsTUFBTSxLQUFLLEVBQUUsRUFBRTtZQUN4QixJQUFJLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRTtnQkFDakQsTUFBTSxJQUFJLEtBQUssQ0FBQywyQkFBMkIsTUFBTSxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDLENBQUM7YUFDdEU7aUJBQU07Z0JBQ0wsSUFBSSxDQUFDLE1BQU0sR0FBRyxNQUFNLENBQUMsS0FBSyxDQUFDLEVBQUUsQ0FBQyxDQUFDO2FBQ2hDO1NBQ0Y7YUFBTSxJQUFJLE1BQU0sQ0FBQyxNQUFNLEtBQUssVUFBVSxDQUFDLGFBQWEsRUFBRTtZQUNyRCxNQUFNLElBQUksS0FBSyxDQUFDLDRCQUE0QixVQUFVLENBQUMsYUFBYSxTQUFTLE1BQU0sQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDO1NBQ2hHO0lBQ0gsQ0FBQztJQUVEOzs7Ozs7O09BT0c7SUFDSSxNQUFNLENBQUMsVUFBVSxDQUFDLE9BQWU7UUFDdEMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxTQUFTLENBQUMsT0FBTyxDQUFDLEVBQUU7WUFDbEMsTUFBTSxJQUFJLEtBQUssQ0FBQywyQkFBMkIsT0FBTyxFQUFFLENBQUMsQ0FBQztTQUN2RDtRQUNELE9BQU8sSUFBSSxVQUFVLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLE1BQU0sRUFBRSxFQUFFLENBQUMsRUFBRSxLQUFLLENBQUMsQ0FBQyxDQUFDO0lBQ3pFLENBQUM7SUFFRDs7Ozs7O09BTUc7SUFDSSxNQUFNLENBQUMsTUFBTTtRQUNsQixPQUFPLElBQUksVUFBVSxDQUFDLFdBQVcsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO0lBQ3pDLENBQUM7SUFFRDs7Ozs7Ozs7T0FRRztJQUNJLE1BQU0sQ0FBQyxTQUFTLENBQUMsT0FBZTtRQUNyQyxJQUFJLENBQUMsc0JBQXNCLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxFQUFFO1lBQ3pDLHNEQUFzRDtZQUN0RCxPQUFPLEtBQUssQ0FBQztTQUNkO2FBQU0sSUFBSSx3QkFBd0IsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLElBQUksd0JBQXdCLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxFQUFFO1lBQzNGLHVDQUF1QztZQUN2QyxPQUFPLElBQUksQ0FBQztTQUNiO2FBQU07WUFDTCxPQUFPLFVBQVUsQ0FBQyxvQkFBb0IsQ0FBQyxPQUFPLENBQUMsQ0FBQztTQUNqRDtJQUNILENBQUM7SUFFRDs7Ozs7T0FLRztJQUNJLE1BQU07UUFDWCxPQUFPLElBQUksQ0FBQyxNQUFNLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxDQUFDO0lBQ3RDLENBQUM7SUFFRDs7Ozs7OztPQU9HO0lBQ0ksTUFBTSxDQUFDLG9CQUFvQixDQUFDLE9BQWU7UUFDaEQsT0FBTyxHQUFHLE9BQU8sQ0FBQyxPQUFPLENBQUMsTUFBTSxFQUFFLEVBQUUsQ0FBQyxDQUFDO1FBQ3RDLE1BQU0sV0FBVyxHQUFHLGVBQWUsQ0FBQyxPQUFPLENBQUMsV0FBVyxFQUFFLENBQUMsQ0FBQztRQUUzRCxLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsRUFBRSxFQUFFLENBQUMsRUFBRSxFQUFFO1lBQzNCLHVFQUF1RTtZQUN2RSxJQUNFLENBQUMsUUFBUSxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsR0FBRyxDQUFDLElBQUksT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLFdBQVcsRUFBRSxLQUFLLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQztnQkFDN0UsQ0FBQyxRQUFRLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxJQUFJLENBQUMsSUFBSSxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsV0FBVyxFQUFFLEtBQUssT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQzlFO2dCQUNBLE9BQU8sS0FBSyxDQUFDO2FBQ2Q7U0FDRjtRQUNELE9BQU8sSUFBSSxDQUFDO0lBQ2QsQ0FBQztJQUVEOzs7Ozs7Ozs7T0FTRztJQUNJLE1BQU0sQ0FBQyxpQkFBaUIsQ0FBQyxPQUFlO1FBQzdDLElBQUksQ0FBQyxVQUFVLENBQUMsU0FBUyxDQUFDLE9BQU8sQ0FBQyxFQUFFO1lBQ2xDLE1BQU0sSUFBSSxLQUFLLENBQUMseUJBQXlCLENBQUMsQ0FBQztTQUM1QztRQUVELE9BQU8sR0FBRyxPQUFPLENBQUMsV0FBVyxFQUFFLENBQUMsT0FBTyxDQUFDLE1BQU0sRUFBRSxFQUFFLENBQUMsQ0FBQztRQUNwRCxNQUFNLFdBQVcsR0FBRyxlQUFlLENBQUMsT0FBTyxDQUFDLENBQUM7UUFDN0MsSUFBSSxlQUFlLEdBQUcsSUFBSSxDQUFDO1FBRTNCLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxPQUFPLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxFQUFFO1lBQ3ZDLHFEQUFxRDtZQUNyRCxJQUFJLFFBQVEsQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLEdBQUcsQ0FBQyxFQUFFO2dCQUNwQyxlQUFlLElBQUksT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLFdBQVcsRUFBRSxDQUFDO2FBQzdDO2lCQUFNO2dCQUNMLGVBQWUsSUFBSSxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUM7YUFDL0I7U0FDRjtRQUNELE9BQU8sZUFBZSxDQUFDO0lBQ3pCLENBQUM7SUFFRDs7Ozs7O09BTUc7SUFDSSxNQUFNLENBQUMsR0FBZTtRQUMzQixPQUFPLElBQUksQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsQ0FBQztJQUN4QyxDQUFDO0lBRUQ7Ozs7OztPQU1HO0lBQ0ksUUFBUTtRQUNiLE9BQU8sS0FBSyxJQUFJLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsRUFBbUIsQ0FBQztJQUM3RCxDQUFDO0lBRUQ7Ozs7OztPQU1HO0lBQ0ksZ0JBQWdCO1FBQ3JCLE9BQU8sVUFBVSxDQUFDLGlCQUFpQixDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUM7SUFDbkUsQ0FBQztJQUVEOzs7T0FHRztJQUNJLFFBQVE7UUFDYixPQUFPLElBQUksQ0FBQyxVQUFVLEVBQUUsQ0FBQztJQUMzQixDQUFDO0lBRUQ7Ozs7OztPQU1HO0lBQ0ksVUFBVTtRQUNmLE9BQU8sSUFBSSxDQUFDLE1BQU0sQ0FBQztJQUNyQixDQUFDO0lBRUQ7Ozs7OztPQU1HO0lBQ0ksVUFBVTtRQUNmLE1BQU0sTUFBTSxHQUFHLE1BQU0sQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDLENBQUM7UUFDaEMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFLEVBQUUsQ0FBQyxDQUFDO1FBQzdCLE9BQU8sTUFBTSxDQUFDO0lBQ2hCLENBQUM7SUFFRDs7OztPQUlHO0lBQ0ksT0FBTztRQUNaLE9BQU8sRUFBRSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsVUFBVSxFQUFFLENBQUMsQ0FBQztJQUMxQyxDQUFDO0lBRUQ7Ozs7T0FJRztJQUNILE1BQU0sQ0FBQyxTQUFTLENBQUMsRUFBTTtRQUNyQixPQUFPLElBQUksVUFBVSxDQUFDLEVBQUUsQ0FBQyxRQUFRLEVBQUUsQ0FBQyxLQUFLLENBQUMsQ0FBQyxVQUFVLENBQUMsYUFBYSxDQUFDLENBQUMsQ0FBQztJQUN4RSxDQUFDO0lBRUQ7Ozs7T0FJRztJQUNILE1BQU0sQ0FBQyxVQUFVLENBQUMsTUFBNkI7UUFDN0MsTUFBTSxNQUFNLEdBQUcsWUFBWSxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsQ0FBQztRQUM3QyxPQUFPLElBQUksVUFBVSxDQUFDLE1BQU0sQ0FBQyxVQUFVLEVBQUUsQ0FBQyxDQUFDO0lBQzdDLENBQUM7SUFFRDs7O09BR0c7SUFDSCxjQUFjO1FBQ1osT0FBTyxJQUFJLENBQUMsUUFBUSxFQUFFLENBQUM7SUFDekIsQ0FBQzs7QUF2T0Q7O0dBRUc7QUFDVyx3QkFBYSxHQUFHLEVBQUUsQ0FBQztBQUNqQzs7R0FFRztBQUNXLGVBQUksR0FBRyxJQUFJLFVBQVUsQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLFVBQVUsQ0FBQyxhQUFhLENBQUMsQ0FBQyxDQUFDIn0=