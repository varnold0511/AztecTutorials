{
    "name": "Counter",
    "functions": [
        {
            "name": "compute_note_hash_and_nullifier",
            "functionType": "unconstrained",
            "isInternal": false,
            "parameters": [
                {
                    "name": "contract_address",
                    "type": {
                        "kind": "field"
                    },
                    "visibility": "private"
                },
                {
                    "name": "nonce",
                    "type": {
                        "kind": "field"
                    },
                    "visibility": "private"
                },
                {
                    "name": "storage_slot",
                    "type": {
                        "kind": "field"
                    },
                    "visibility": "private"
                },
                {
                    "name": "preimage",
                    "type": {
                        "kind": "array",
                        "length": 3,
                        "type": {
                            "kind": "field"
                        }
                    },
                    "visibility": "private"
                }
            ],
            "returnTypes": [
                {
                    "kind": "array",
                    "length": 4,
                    "type": {
                        "kind": "field"
                    }
                }
            ],
            "bytecode": "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",
            "verificationKey": "0000000200000800000000740000000f00000003515f3109623eb3c25aa5b16a1a79fd558bac7a7ce62c4560a8c537c77ce80dd339128d1d37b6582ee9e6df9567efb64313471dfa18f520f9ce53161b50dbf7731bc5f900000003515f322bc4cce83a486a92c92fd59bd84e0f92595baa639fc2ed86b00ffa0dfded2a092a669a3bdb7a273a015eda494457cc7ed5236f26cee330c290d45a33b9daa94800000003515f332729426c008c085a81bd34d8ef12dd31e80130339ef99d50013a89e4558eee6d0fa4ffe2ee7b7b62eb92608b2251ac31396a718f9b34978888789042b790a30100000003515f342be6b6824a913eb7a57b03cb1ee7bfb4de02f2f65fe8a4e97baa7766ddb353a82a8a25c49dc63778cd9fe96173f12a2bc77f3682f4c4448f98f1df82c75234a100000003515f351f85760d6ab567465aadc2f180af9eae3800e6958fec96aef53fd8a7b195d7c000c6267a0dd5cfc22b3fe804f53e266069c0e36f51885baec1e7e67650c62e170000000c515f41524954484d455449430d9d0f8ece2aa12012fa21e6e5c859e97bd5704e5c122064a66051294bc5e04213f61f54a0ebdf6fee4d4a6ecf693478191de0c2899bcd8e86a636c8d3eff43400000003515f43224a99d02c86336737c8dd5b746c40d2be6aead8393889a76a18d664029096e90f7fe81adcc92a74350eada9622ac453f49ebac24a066a1f83b394df54dfa0130000000c515f46495845445f42415345060e8a013ed289c2f9fd7473b04f6594b138ddb4b4cf6b901622a14088f04b8d2c83ff74fce56e3d5573b99c7b26d85d5046ce0c6559506acb7a675e7713eb3a00000007515f4c4f4749430721a91cb8da4b917e054f72147e1760cfe0ef3d45090ac0f4961d84ec1996961a25e787b26bd8b50b1a99450f77a424a83513c2b33af268cd253b0587ff50c700000003515f4d05dbd8623b8652511e1eb38d38887a69eceb082f807514f09e127237c5213b401b9325b48c6c225968002318095f89d0ef9cf629b2b7f0172e03bc39aacf6ed800000007515f52414e474504b57a3805e41df328f5ca9aefa40fad5917391543b7b65c6476e60b8f72e9ad07c92f3b3e11c8feae96dedc4b14a6226ef3201244f37cfc1ee5b96781f48d2b000000075349474d415f3125001d1954a18571eaa007144c5a567bb0d2be4def08a8be918b8c05e3b27d312c59ed41e09e144eab5de77ca89a2fd783be702a47c951d3112e3de02ce6e47c000000075349474d415f3223994e6a23618e60fa01c449a7ab88378709197e186d48d604bfb6931ffb15ad11c5ec7a0700570f80088fd5198ab5d5c227f2ad2a455a6edeec024156bb7beb000000075349474d415f3300cda5845f23468a13275d18bddae27c6bb189cf9aa95b6a03a0cb6688c7e8d829639b45cf8607c525cc400b55ebf90205f2f378626dc3406cc59b2d1b474fba000000075349474d415f342d299e7928496ea2d37f10b43afd6a80c90a33b483090d18069ffa275eedb2fc2f82121e8de43dc036d99b478b6227ceef34248939987a19011f065d8b5cef5c0000000010000000000000000100000002000000030000000400000005000000060000000700000008000000090000000a0000000b0000000c0000000d0000000e0000000f"
        },
        {
            "name": "constructor",
            "functionType": "secret",
            "isInternal": false,
            "parameters": [
                {
                    "name": "headstart",
                    "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 120
                    },
                    "visibility": "private"
                },
                {
                    "name": "owner",
                    "type": {
                        "kind": "field"
                    },
                    "visibility": "private"
                }
            ],
            "returnTypes": [],
            "bytecode": "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",
            "verificationKey": "0000000200000800000000740000000f00000003515f3109623eb3c25aa5b16a1a79fd558bac7a7ce62c4560a8c537c77ce80dd339128d1d37b6582ee9e6df9567efb64313471dfa18f520f9ce53161b50dbf7731bc5f900000003515f322bc4cce83a486a92c92fd59bd84e0f92595baa639fc2ed86b00ffa0dfded2a092a669a3bdb7a273a015eda494457cc7ed5236f26cee330c290d45a33b9daa94800000003515f332729426c008c085a81bd34d8ef12dd31e80130339ef99d50013a89e4558eee6d0fa4ffe2ee7b7b62eb92608b2251ac31396a718f9b34978888789042b790a30100000003515f342be6b6824a913eb7a57b03cb1ee7bfb4de02f2f65fe8a4e97baa7766ddb353a82a8a25c49dc63778cd9fe96173f12a2bc77f3682f4c4448f98f1df82c75234a100000003515f351f85760d6ab567465aadc2f180af9eae3800e6958fec96aef53fd8a7b195d7c000c6267a0dd5cfc22b3fe804f53e266069c0e36f51885baec1e7e67650c62e170000000c515f41524954484d455449430d9d0f8ece2aa12012fa21e6e5c859e97bd5704e5c122064a66051294bc5e04213f61f54a0ebdf6fee4d4a6ecf693478191de0c2899bcd8e86a636c8d3eff43400000003515f43224a99d02c86336737c8dd5b746c40d2be6aead8393889a76a18d664029096e90f7fe81adcc92a74350eada9622ac453f49ebac24a066a1f83b394df54dfa0130000000c515f46495845445f42415345060e8a013ed289c2f9fd7473b04f6594b138ddb4b4cf6b901622a14088f04b8d2c83ff74fce56e3d5573b99c7b26d85d5046ce0c6559506acb7a675e7713eb3a00000007515f4c4f4749430721a91cb8da4b917e054f72147e1760cfe0ef3d45090ac0f4961d84ec1996961a25e787b26bd8b50b1a99450f77a424a83513c2b33af268cd253b0587ff50c700000003515f4d05dbd8623b8652511e1eb38d38887a69eceb082f807514f09e127237c5213b401b9325b48c6c225968002318095f89d0ef9cf629b2b7f0172e03bc39aacf6ed800000007515f52414e474504b57a3805e41df328f5ca9aefa40fad5917391543b7b65c6476e60b8f72e9ad07c92f3b3e11c8feae96dedc4b14a6226ef3201244f37cfc1ee5b96781f48d2b000000075349474d415f3125001d1954a18571eaa007144c5a567bb0d2be4def08a8be918b8c05e3b27d312c59ed41e09e144eab5de77ca89a2fd783be702a47c951d3112e3de02ce6e47c000000075349474d415f3223994e6a23618e60fa01c449a7ab88378709197e186d48d604bfb6931ffb15ad11c5ec7a0700570f80088fd5198ab5d5c227f2ad2a455a6edeec024156bb7beb000000075349474d415f3300cda5845f23468a13275d18bddae27c6bb189cf9aa95b6a03a0cb6688c7e8d829639b45cf8607c525cc400b55ebf90205f2f378626dc3406cc59b2d1b474fba000000075349474d415f342d299e7928496ea2d37f10b43afd6a80c90a33b483090d18069ffa275eedb2fc2f82121e8de43dc036d99b478b6227ceef34248939987a19011f065d8b5cef5c0000000010000000000000000100000002000000030000000400000005000000060000000700000008000000090000000a0000000b0000000c0000000d0000000e0000000f"
        },
        {
            "name": "get_counter",
            "functionType": "unconstrained",
            "isInternal": false,
            "parameters": [
                {
                    "name": "owner",
                    "type": {
                        "kind": "field"
                    },
                    "visibility": "private"
                }
            ],
            "returnTypes": [
                {
                    "kind": "field"
                }
            ],
            "bytecode": "H4sIAAAAAAAA/+2dB5gc1bWte2YkjXp6NAqjPEE9ylkzo5xbOeecUJYQEsiAyEEGDBiTTM45g4kmmpyzA8bXxjgAxhhjjG2C3/V7914/V2svzVKpGKsfp6Slx6nvk2b3X9Vn/+dU6F3d1V35iUQiL7FjKqCYJ7CM/a3+alNNnru2qtk3/1//3kzviJP2mKdGFGcc5W/kfnyq2R1/G/7rX2Girm+J0PwS618Dx+sqyFWQ2HUKbyMZihvQWDd061KdIpeGlKcwhj43Sux5n5E/Rc9jv2QMfo1z8EuSX+MIv1QMfkU5+KXob1GEX5MY/Ipz8GtCLiVuXbLbNFxKKE+zGPrcNLHnfUb+FD2P/VrE4Nc8B78W5Nc8wq9lDH6lOfi1JD88j7fp1jH4tcrBrzX5tYrwaxuDX5sc/NqSX5sIv/Yx+LXLwa89+bWL8CuPwa8sB79y8iuL8KuMwa8iB79K8quI8EvH4NchB780+XWI8OsYg19VDn4dya8qwq9zDH6dcvDrTH6dIvy6xuDXJQe/ruTXJcKvewx+3XLw605+3SL8esbg1yMHv57k1yPCr7dbv9rAr1cOfr3JpZ9blwGBS58cXPqRS1+3LjVBm9Vu28w2V0P+6CvypGg+r/Max33Lo5xoF4/Zz7t+vV0Dl14hzyQt10vAD6xvjC7JkEsw1XdcivLjddnfrV/2GF6bg19/chnk1KV/9j22ATm4DCKXgU5ddhzDB7ttM7s6h5A/+oo8KZrP63yI477lUU60i8fs5129q3f1rt7Vu3pX7+pdvat39a7e1bt6V+/qXb2rd/Wu3tW7elfv6l29q3f1rt7Vu3pX966BS23IM0nL1Qr4gQ2M0SUZcgmm+q4TifLjdTnMrV/2mpqhOfgNI5eRTl1qs9fUDM/BZSS5jHDqsuOamlFu28xeUzOa/NFX5EnRfF7nox33LY9yol08Zj/v6l29q3f1rt7Vu3pX7+pdvat39a7e1bt6V+/qXb2rd91fXAOXoSHPJC03VMAPbESMLsmQSzDV9z57lB+vyzFu/bKfSWRy8BtDLuPdumR/q2FsDi7jyWWcW5fsZxIT3LaZ/UxiIvmjr8iTovm8zic67lse5US7eMx+3vXr7ZqifPBMJnbfL/alH9i4GF2SIZdgqu+4FOXH63KyW7/sMXxSDn6TyWWaU5ea7OfKU3JwmUYuU5267DiGT3fbZvYYPoP80VfkSdF8XuczHPctj3KiXTxmP+/qXb2rd/Wu3tW7elfv+vV2DVwmhTyTtNwkAT+wqTG6JEMuwVTfeUqUH6/LWW79sud0M3Pwm0Uuc5267Dinm52Dy1xymePUZcc53Ty3bWbP6eaTP/qKPCmaz+t8vuO+5VFOtIvH7Oddvat39a7e1bt6V+/qXb/eroHLzJBnkpabKeAHNidGl2TIJZjqO0+J8uN1udCtX/acbkEOfgvJZUkMLotycFlCLovdumTP6Za6bTN7TreM/NFX5EnRfF7nyxz3LY9yol08Zr/9xTVwWRDyTNJyCwT8wBbH6JIMuQRTfftPlB+vyxVu/bL79/Ic/FaQy6oYXA7IwWUVuax065I91qx222b2WLOG/NFX5EnRfF7naxz3LY9yol08Zr/9xTVwWR7yTNJyywX8wFbG6JIMuQRTfftPlB+vy3Ux+K3NwW8d+a2N8NsQg9/6HPw2kN/6CL8DY/DbmIPfgeS3McLvoBj8NuXgdxD5bYrw2xKD3+Yc/LaQ3+YIv0Ni8Ds4B79DyO/gCL9vxOC3NQe/b5Df1gi/w2LwOzQHv8PI79AIv20x+B2eg9828js8wu/IGPyOyMHvSPI7IsLv6Bj8jsrB72jyOyrC79gY/I7Jwe9Y8jsmwu/4GPyOy8HvePI7LsLvxBj8TsjB70Tyw/P4fuHfjMFvew5+3yS/7RF+J8fgd1IOfieT30kRft+Kwe+UHPy+RX54Hm9/p8Xgd2oOfqeR36kRft+Owe/0HPy+TX6nR/h9Jwa/M3Lw+w75nRHhd1YMfmfm4HcW+Z0Z4XdODH5n5+B3DvmdHeH33Rj8zs3B77vkd26E3/kx+J2Xg9/55HdehN+FMfhdkIPfheR3QYTfxTH4XZSD38Xkd1GE36Ux+F2Sg9+l5HdJhN/lMfhdloPf5eR3WYTflTH4XZGD35Xkd0WE39Ux+F2Vg9/V5HdVhN+1Mfhdk4PfteR3TYTf9TH4XZeD3/Xkd12E341u/bLv79+Qg9+N5HKLW5fsd8hvysHlFnK52a1L9rOGW922mf2s4TbyR1+RJ0XzeZ3f5rhveZQT7eIx+3nXr7dr4HJDyDNJy90g4Ad2c4wuyZBLMNV3XIry43V5h1u/7DH89hz87iCXu5y67Pht8u/l4HIXudzp1GXHMfxut21mj+H3kD/6ijwpms/r/B7HfcujnGgXj9nPu3pX7+pdvat39a7e1bt6V+/qXb2rd/Wu3tW7elfv6l33F9fA5faQZ5KWu13AD+zOGF2SIZdgqu999ig/Xpf3ufXLfiZxbw5+95HLA05ddnwm8f0cXB4gl/uduuz4TOJBt21WB208RP7oK/KkaD6v84cc9y2PcqJdPGY/7+pdvat39a7e1bt6V+/qXb2rd/Wu3tW7elfv6l29q3fdX1wDl3tDnkla7l4BP7D7Y3RJhlyCqb732aP8eF0+4tYv+5nEwzn4PUIujzl12XFfhh/k4PIYuTzq1GXHZxKPu20z+5nEE+SPviJPiubzOn/Ccd/yKCfaxWP2867e1bt6V+/qXb2rd/WuX2/XwOXhkGeSlntYwA/s0RhdkiGXYKrvPCXKj9flU279sud0T+bg9xS5POvUZcc53dM5uDxLLs84ddlxTvec2zaz53TPkz/6ijwpms/r/HnHfcujnGgXj9nPu3pX7+pdvat39a7e1bt+vV0DlydDnkla7kkBP7BnYnRJhlyCqb7zlCg/XpcvuvXLntO9kIPfi+TyilOXHed0L+Xg8gq5vOzUZcc53atu28ye071G/ugr8qRoPq/z1xz3LY9yol08Zj/v6l29q3f1rt7Vu3pX7/r1dg1cXgh5Jmm5FwT8wF6O0SUZcgmm+s5Tovx4Xf7QrV/2nO71HPx+SC4/ceuSvc/Aj3Jw+Qm5/NitS/ac7g23bWbP6X5K/ugr8qRoPq/znzruWx7lRLt4zH7e9evtGri8HvJM0nKvC/iB/ThGl2TIJZjqOy5F+fG6/Jlbv+wx/M0c/H5GLr9w65I9hv9HDi6/IJefu3XJHsPfcttm9hj+S/JHX5EnRfN5nf/Scd/yKCfaxWP2865fb9fA5c2QZ5KWe1PAD+znMbokQy7BVN9xKcqP1+Wv3Pplj+Fv5+D3K3L5bQwuv87B5bfk8hu3Ltlj+Dtu28wew98lf/QVeVI0n9f5u477lkc50S4es9/+4hq4vB3yTNJybwv4gf0mRpdkyCWY6tt/ovx4Xf4uBr/3cvD7Hfm9F+H3+xj83s/B7/fk936E3x9i8PsgB78/kN8HEX5/jMHvwxz8/kh+H0b4/SkGv49y8PsT+X0U4ffnGPw+zsHvz+T3cYTfX2Lw+yQHv7+Q3ycRfp+69cvWD3/Nwe9Tcvmb47EK2vzMbZvVQZufO/YM2viCxgTj9xmtO8z/nMbrC8ceeZQT7eIx++2pa/4+do1r/f/dbZu1xf9qozGN5d9DY8rj/b/sbwPivD//I4Zx/k9rK8/+/SPkEuT93zHk/Qf1jz2Qq4CWadFox98msYxDbW3Q5v9x22b/oM3/ctvmgKDN/3bb5sCgzf9x2+agoM1/um1zcCNspO7aHJJK1E1N7W+QJ89pnh3bO08ZipGLXa4TcnlQyOUiIZczhFxOEHI5VMhlvZDLPCGXT4RcRgm5vCfk0kPI5XUhlwohl4eFXJoLudwg5FIg5HKJkMuZQi7bhVwOF3LZKOSyQMjlCyGXjJDL+0IuvYRc3hBy6SDk8riQS6mQy61CLo2EXC4TcjlbyOUkIZcjhFw2CbksFXKZIOTygZBLtZDLm0IuVUIuTwq5tBJyuV3IpbGQyxVCLucKuZwi5HKUkMtmIZflQi6ThFw+FHKpFXJ5S8ilk5DLc0IubYRc7hZyKRJyuUrI5Twhl1OFXI4RcjlYyGW1kMt0IZePhFwGC7m8LeTSRcjlBSGXdkIu9wq5FAu5XCPkcoGQy+lCLscJuWwVclkr5DJTyOVjIZehQi7vCLl0E3J5VcilTMglbx+7JMkBU5LmlxDLN3YEsQJjRxFrYOwYYg2NHUeskbETiBUa206ssbGTiCWNnUKsyNipxFLGTidWbOwMYk2MnUmsxNjZxJoaO5dYM2PnEWtu7AJiLYxdRKzU2CXEWhq7jFgrY1cQa23sKmJtjF1DrK2x64i1M3YDsfbGbiVWZux2YuXG7iZWYexeYpXGHiTWwdjDxNLGHidWZexJYh2NPUesk7EXiHU29iqxLsZeJ9bV2BvEuhl7k1h3Y28R62HsbWI9jb1DrJex94j1NvY+sT7GPiDW19iHxPoZ+4hYtbGPiWHn/4RYbcQ+3d9YAbEBxhoRG2isMbFBxoqIDTZWTGyIsabEhhprTmyYsVJiw421IjbCWBtiI421IzbKWBmx0cYqiGWMdSA2xlgVsbHGOhEbZ6wLsfHGuhGbYKwHsYnGehGbZKya2GRjtcSmGBtMbKqxocSmGRtFbHrodSZgM4xNIDbT2CRis4xNJzbb2Exic4zNIzbX2AJi84wtJTbf2HJiC4ytJrbQ2Fpii4ytJ7bY2EZiS4xtIrbU2GZiy4wdTGy5sa3EVhg7lNgBxg4nttLYF8RWGfsHsdXG/g+xNcb+i9haY/9NbJ2x/yG23tg/iW3ACz/VAvlAxHBsyCfWwFgBMXwfvgExHEMaEis01ogYjiuFxJLGGhPbeawhhnqqiBiOPyliTYwVE8OxsAkxHKdKiDUz1pQYjl3NiLUw1pwYjmctiLU0VkoMx7iWxFoba0UMx73WxNoaa0MMx8K2xNoba0cMx8f2xMqNlRHDMbOcWKWxCmI4jlYSSxvrQKzKWJpYR2NVxHC87Uiss7FOxHAM7kysq7EuxHBc7kqsu7FuxHoY606sp7EexHD87kmst7FexPoY602sr7E+xPoZ60sMrwf9iNUYqyaG14gaYv2N1RIbYKw/sYHGBhAbZGwgMbzmDCI2xNhgYngdGkJsmLGhxIYbG0ZshLHhxEYaG0EMr2sjiY02NopYxthoYmOMZYiNNTaG2DhjY4mNNzaOGF47xxObaGwCMbyeTiQ22dgkYlOMTSY21dgUYtOMTSWG1+dpxGYYm04Mr9kziM0yNpPYbGOziM0xNpvYXGNziKEGmEtsvrF5xFAXzCe20NgCYouMLSS22NgiYkuMLSaGOmMJsWXGlhJD7bGM2Apjy4kdYGwFsZXGDiC2ythKYquNrSK2xthqYqhv1hBbZ2wtMdQ864htMLaeGOogvP4Hr9tVSWrHOGoBrhW4HcQoIxpR7oyx6q82ZQ9jnCdDj5GriBwwb1+6lAm5vCrk0k3I5R0hl6FCLh8LucwUclkr5LJVyOU4IZfThVwuEHK5RsilWMjlXiGXdkIuLwi5dBFyeVvIZbCQy0dCLtOFXFYLuRws5HKMkMupQi7nCblcJeRSJORyt5BLGyGX54RcOgm5vCXkUivk8qGQyyQhl+VCLpuFXI4ScjlFyOVcIZcrhFwaC7ncLuTSSsjlSSGXKiGXN4VcqoVcPhBymSDkslTIZZOQyxFCLicJuZwt5HKZkEsjIZdbhVxKhVweF3LpIOTyhpBLLyGX94VcMkIuXwi5LBBy2SjkcriQy3YhlzOFXC4RcikQcrlByKW5kMvDQi4VQi6vC7n0EHJ5T8hllJDLJ0Iu84Rc1gu5HCrkcoKQyxlCLhcJuTwo5HKdkEvTkAt/x3cDsfzErs8tNO8DE069q/n3S5AzyLPJbZ56f78EudhltJDLUCGX/kIufYRcugm5rBNyqRJyOUDIpUzIZbGQSyshl7lCLk2FXKYLuSSFXCYKuRQIuWSEXIYJuQwQcukr5NJdyGW9kEtHIZeVQi7lQi5LhFxaC7nME3JpJuQyQ8ilSMhlkpBLAyGXMUIuw4VcBgq59BNy6SHkskHIpZOQyyohlwohl6VCLm2EXOYLuTQXcpkp5JIScpks5NJQyGWskMsIIZdBQi7VQi49hVw2Crl0FnJZLeRSKeSyTMilrZDLAiGXFkIus4RcioVcpgi5NBJyGSfkMlLIZbCQS42QSy8hly5CLmuEXDoIuSwXcmkn5LJQyKVUyGW2kEsTIZepQi6FQi7jhVxGCbkMEXKpFXLpLeTSVchlrZBLWshlhZBLeyGXRUIuLYVc5gi5lAi5TBNyaSzkMkHIJW8fuyQT0fchx/x8YgdZzPcs3mxxA2JbLG5I7GDqJ9ghFhcSwz12+H7H36AYf/EdZ74H8mEWp4jht1z4vsjbLG5CDL9Zx/doPtJivn8yfg+3GbGjLeZ7KuO39lsQO9Zivs8y7uPTktjxFvO9l/E96tbETrSY78eM34tpS+ybFvM9mk+yuD2xky3m+zbjN3fLiX3LYr6XM37Pv5LYaRbz/Z1xr6A0sW9bXEXsDIs7EvuOxXwf6DMt7kzsLIv53tD47b2uxM6xmO8Xjd/17U7suxb3IIZ7BvQkdr7FvYjhfkS9iV1ocR9i+D54X2IXW9yPGH73hu9TfanFNcTw+3587+rLLe5PDL8dPIDYlRYPJIb7EgwidrXFfC9s3PNoCLFrLeb7Y19n8TBi11s8nBh+z2YEsRstHknsJov5fts3Wzya2C0WZ4jhN//GELvN4rHEbrd4HLE7LB5P7HsW8z2977R4IrG7LOb7fOM+B5OJ3WPxFGK4h9JUYvdZPI3Y9y3m+4bfb/EMYg9YzPcSx+8CzCL2kMWzieG3deYQe8TiucR+YDHfm/xRi+cTe8xivl85fn9wIbEnLF5EDL9tvJjYUxYvIfa0xXz/82csXkbsWYv5nui458IKYs9bfACxFyxeSexFi1cRe8ni1cRetngNsVcs5vuuv2rxOmKvWcz3Ysfv/Gwg9kOL+f7sP7L4QGKoATYRQw1wEDHUAJuJoQbYQgw1AN/bHTXAIcRQA/D93lEDcE2AGoDvAY8a4DBiqAH4vvCoAbYRQw1wBDHUAEcSQw1wFDHUAEcTQw1wDDHUAMcSQw1wHDHUAMcTQw1wAjHUACcSQw2wnRhqgG8SQw1wEjHUACcTQw1wCjHUAN8ihhrgVGKoAU4jlrb4dGKoAb5NDDXAGcRQA3yHGGqAM4mhBjiLGGqAs4mhBjiHGGqAc4n1sPi7xFADnEcMNcD5xFADXEAMNcCFxFADXEQMNcDFxFADXEIMNcClxFADXEYMNcDlxFADXEEMNcCVxFADXEUMNcDVxFADXEMMNcC1xFADXEcMNcD1xFAD3EAMNcCNxFAD3EQMNcDNxDIW30IMNcCtxFAD3EYMNcDtxFAD3EEMNcD3iKEGuJMYaoC7iKEGuJvYFIvvIYYa4F5iqAHuI4Ya4PvEUAPcTww1wAPEUAM8SAw1wEPEUAM8TAw1wCPEUAP8gBhqgEeJoQZ4jBhqgMeJoQZ4ghhqgCeJoQZ4ihhqgKeJoQZ4hhhqgGeJoQZ4jhhqgOeJoQZ4gdgqi18khhrgJWKoAV4mhhrgFWKoAV4lhhrgNWKoAV4nhhrgh8RQA6AmCF7L1xTXzcey/B7BjyLaQczvdSB3xv5Wf7Up+14H58nQY+Ti+5X/UMBlgpBLYyGXaUIuJUIuc4RcWgq5LBJyaS/kskLIJS3kslbIpauQS28hl1ohlyFCLqOEXMYLuRQKuUwVcmki5DJbyKVUyGWhkEs7IZflQi4dhFzWCLl0EXLpJeRSI+QyWMhlpJDLOCGXRkIuU4RcioVcZgm5tBByWSDk0lbIZZmQS6WQy2ohl85CLhuFXHoKuVQLuQwSchkh5DJWyKWhkMtkIZeUkMtMIZfmQi7zhVzaCLksFXKpEHJZJeTSSchlg5BLDyGXfkIuA4Vchgu5jBFyaSDkMknIpUjIZYaQSzMhl3lCLq2FXJYIuZQLuawUcuko5LJeyKW7kEtfIZcBQi7DhFwyQi4FQi4ThVySQi7ThVyaCrnMFXJpJeSyWMilTMjlACGXKiGXdUIu+M6rgksfIZf+Qi5DhVxGC7nkh1z4Nw5+RCw/9NxC897s2DvIdVBi1ykv9DhD8WYawy1uXapT5LKF8hziNk9t0OeDE3ve50PI5RtuXbLjvzUHl2+Qy2ExjMuhObgcRi7bYhiXw3Nw2UYuR8bgckQOLkeSy9ExuByVg8vR5HKcW5ehgcsxObgcRy7HOh6XoM3j3bZZHbR5guM2gzZOpDHB+ME9RfNPoPE60fF45VFOtIvHJ8aXN9v/7f+m/9sjPLbvxf6z3566btmPXE/Yj1z9NhCPq98G4nHd19tA4HJwyDNJyx0s4Ad2LLGtEeP3Tbd+Q5Mhv2Cqr175ZoxjFbR5kts2s6+tJ5M/+noSjTPm8/5/suO+5VFOtIvH7LenrifuY9cY8mbX1Sn/pv+nRHicshf7z3576nrCfuR64n7k6reBeFz9NrDnroHLoSHPJC13qIAfGNcbeB+JawvHr72rgzx4j4jXHd6rOZByn+o2d7au4W0omOqra04ll2+5dcnWNae5bTP7Wnk6+aOvp9E4Yz4fe0533Lc8yol28Zj99tT1xP3Idct+5Oq3gXhc/TYQj6vfBvbcNcj7bbd5s6+fnDeY6nv9/HaMYxC0eYbbNrOvn98hf/QVeVI0n/eb7zjuWx7lRLt4zH576nrifuR68n7k6reBeFz9NhCPq98G9tyV7+GWTy6OX3Nq6nv9PCPCZbSQy1Ahl/5CLn2EXLoJuawTcqkScjlAyKVMyGWxkEsrIZe5Qi5NhVymC7kkhVwmCrkUCLlkhFyGCbkMEHLpK+TSXchlvZBLRyGXlUIu5UIuS4RcWgu5zBNyaSbkMkPIpUjIZZKQSwMhlzFCLsOFXAYKufQTcukh5LJByKWTkMsqIZcKIZelQi5thFzmC7k0F3KZKeSSEnKZLOTSUMhlrJDLCCGXQUIu1UIuPYVcNgq5dBZyWS3kUinkskzIpa2QywIhlxZCLrOEXIqFXKYIuTQSchkn5HKQkMtIIZfBQi41Qi69hFwOFHLpIuSyRsilg5DLciGXdkIuC4VcSoVcZgu5NBFymSrkUijkMl7IZZOQyyghlyFCLrVCLr2FXLoKuawVckkLuawQcmkv5LJIyKWlkMscIZcSIZdpQi6NhVwmCLnk7WOXZGL33zRI0vx8YviuaAGxMy1uQOwsixsSO5v6CXaOxYXEzrW4MbHvUoy/51lcROx8i1PELrC4mNiFFjchdpHFJcQutrgpsUssbkbsUoubE7vM4hbELre4lNgVFrckdqXFrYhdZXFrYldb3IbYNRa3JXatxe2IXWdxe2LXW1xG7AaLy4ndaHEFsZssriR2s8UdiN1icZrYrRZXEbvN4o7Ebre4E7E7LO5M7HsWdyF2p8Vdid1lcTdid1vcndg9Fvcgdq/FPYndZ3EvYt+3uDex+y3uQ+wBi/sSe9DifsQesria2MMW1xB7xOJaYj+wuD+xRy0eQOwxiwcSe9ziQcSesHgwsSctHkLsKYuHEnva4mHEnrF4OLFnLR5B7DmLRxJ73uJRxF6weDSxFy3OEHvJ4jHEXrZ4LLFXLB5H7FWLxxN7zeIJxHC/jonEcK+PScRwr4/JxH5s8RRiP7F4KrE3LJ5G7KcWTyf2psUziP3M4pnE/sPiWcR+bvFsYr+weA6xtyyeS+yXFs8j9rbF84n9yuIFxH5t8UJiv7F4EbHfWryY2DsWLyH2rsVLib1n8TJiv7N4ObH3LV5B7PcWH0DsA4tXEvuDxauIfWjxamJ/tHgNsY8sXkvsTxavI/axxeuJ/dniDcQ+sXgjsb9YfAqxv1r8LWJ/s3gLsU8tPo3YZxafTuzziOd+YfFJxP5u8YHEUI+cQQz1yHeIoR45kxjqkbOIoR45mxjqkXOIoR45lxjqEa5PUI+cRwz1yPnEUI9cQAz1yIXEUI9cRAz1yMXEUI9cQgz1yKXEUI9cRgz1yOXEUI9cQQz1yJXEUI9cRQz1yNXEUI9cQwz1yLXEUI9cRwz1yPXEUI/cQAz1yI3EUI/cRAz1yM3E0hbfQgz1yK3EUI/cRgz1yO3EUI/cQQz1yPeIoR65kxjqkbuIoR65m1gPi+8hhnrkXmKoR+4jhnrk+8RQj9xPDPXIA8RQjzxIDPXIQ8RQjzxMDPXII8RQj/yAGOqRR4mhHnmMGOqRx4mhHnmCGOqRJ4mhHnmKGOqRp4mhHnmGGOqRZ4mhHnmOGOqR54mhHnmBWMbiF4mhHnmJGOqRl4mhHnmFGOqRV4mhHnmNGOqR14mF70sfMNQjfC+yKRb/mBjqkZ8QQz3yBjHUIz8lhnrkTWKoR35GDPXIfxBDPfJzYqhHfkEM9chbxFCP/JIY6pG3iaEe+RUx1CO/JoZ65DfEUI/8lhjqkXeIoR55lxjqkfeIoR75HTHUI+8TQz3ye2KoRz4gtsriPxBDPfIhMdQjfySGeuQjYqhH/kQM9cjHxFCP/JkY6pFPiKEG+AuxTRb/lRiuOfobsc0Wf0oMtcdnxHAPjM+J4R5vXxDDPSlQnwR1RZuWdfPxfH7vBHn4vZO/R+T7IsILMb9XhOdk7G/1V5uy7xVxngw9Rq4icvhMwGWCkEtjIZdpQi4lQi5zhFxaCrksEnJpL+SyQsglLeSyVsilq5BLbyGXWiGXIUIuo4RcNgm5jBdyKRRymSrk0kTIZbaQS6mQy0Ihl3ZCLsuFXDoIuawRcuki5HKgkEsvIZcaIZfBQi4jhVwOEnIZJ+TSSMhlipBLsZDLLCGXFkIuC4Rc2gq5LBNyqRRyWS3k0lnIZaOQS08hl2ohl0FCLiOEXMYKuTQUcpks5JIScpkp5NJcyGW+kEsbIZelQi4VQi6rhFw6CblsEHLpIeTST8hloJDLcCGXMUIuDYRcJgm5FAm5zBByaSbkMk/IpbWQyxIhl3Ihl5VCLh2FXNYLuXQXcukr5DJAyGWYkEtGyKVAyGWikEtSyGW6kEtTIZe5Qi6thFwWC7mUCbkcIORSJeSyTsilm5BLHyGX/kIuQ4VcRgu55O8lF3znFO1+EXL5/yhvNX9vGG0H7/9d1Kwu52duc67OC/Vpe2L3734U0DIFLeu8LovNa0D2azn4TnQw/T3kVEROn0Z4Xt2szvOfpbs/56BEXO71bz+8v3zqNu9q3neDKZ2ou1b5U8r7Nzd5axAEef9K7VeRx99o3WCZW2zdBN8Z4d8bzHfvuNM1L7HrlKEYudhlqJBLHyGXdUIuVUIui4VcWgm5TBdySQq5ZIRcBgi5dBdyWSnkUi7kMk/IpZmQyyQhlwZCLsOFXPoJuWwQcukk5PK5kMtSIZc2Qi4zhVxSQi5jhVwGCbn0FHJZLeRSKeSyQMilhZDLFCGXRkIuI4VcaoRcugi5bBJyWS7k0k7IZbaQSxMhl/FCLkOEXHoLuawVckkLuSwScmkp5DJNyKWxkMtoIZf+Qi7dhFwOEHIpE3KZK+TSVMhlopBLgZDLMCGXvkIu64VcOgq5LBFyaS3kMkPIpUjIZYyQy0Ahlx5CLquEXCqEXOYLuTQXcpks5NJQyGWEkEu1kMtGIZfOQi6fCbm0FXJZJuQyS8ilWMjlICGXcUIug4Vcegm5rBFy6SDkslDIpVTIZaqQS6GQyyghl1ohl65CLiuEXNoLucwRcikRcpkg5JK3j12S5JAghvn5xPAdVr5XMu773IAY7g/dkNifqZ9guN90IbE/WdyY2EcU4y/uc11EDPfDThHDfbOLiX1gcRNiuA93CTHcr7spMdzXuxmx9yxuTuxdi1sQe8fiUmK473hLYrg/eStiuI95a2K433kbYrgveltiuH96O2K4z3p7Yrgfexkx3Le9nBju715BDPeBryT2psUdiP3U4jQx3H++ithPLO5IDPez70QM973vTOyHFnch9rrFXYm9ZnE3Yq9a3J3YKxb3IPayxT2JvWRxL2IvWtyb2AsW9yH2vMV9iT1ncT9iz1pcTewZi2uIPW1xLbGnLO5P7EmLBxB7wuKBxB63eBCxxyweTOxRi4cQ+4HFQ4k9YvEwYg9bPJzYQxaPIPagxSOJPWDxKGL3Wzya2PctzhC7z+IxxO61eCyxeyweR+xui8cTu8viCcTutHgise9ZPInYHRZPJna7xVOI3WbxVGK3WjyN2C0WTyd2s8UziN1k8UxiN1o8i9gNFs8mdr3Fc4hdZ/FcYtdaPI/YNRbPJ3a1xQuIXWXxQmJXWryI2BUWLyZ2ucVLiF1m8VJil1q8jNglFi8ndrHFK4hdZPEBxC60eCWxCyxeRex8i1cTO8/iNcS+a/FaYudavI7YORavJ3a2xRuInWXxRmJnWvwZMdQAXDOgBvgrMdQAfyGGGuATYqgB/kwMNcDHxFAD/IkYagCuCVAD/JEYaoAPiaEG+AMx1AAfEEMN8HtiqAHeJ4Ya4HfEUAO8Rww1wLvEUAO8Qww1wG+JoQb4DTHUAL8mhhrgV8RQA7xNDDXAL4mhBniLGGqAXxBDDfBzYqgB/oMYaoCfEUMN8CaxtMU/JYYa4A1iqAF+Qgw1wI+JoQb4ETHUAD8khhrgdWKoAV4jhhrgVWI9LH6FGGqAl4mhBniJGGqAF4mhBniBGGqA54mhBniOGGqAZ4mhBniGGGqAp4mhBniKGGqAJ4mhBniCGGqAx4mhBniMGGqAR4mhBvgBMdQAjxBDDfAwMdQADxFDDfAgMdQADxBDDXA/sYzF3yeGGuA+YqgB7iWGGuAeYqgB7iaGGuAuYqgB7iSGGuB7xFAD3EFsisW3E0MNcBsx1AC3EkMNcAsx1AA3E0MNcBMx1AA3EkMNcAMx1ADXE0MNcB0x1ADXEkMNcA0x1ABXE0MNcBUx1ABXEkMNcAUx1ACXE0MNcBkx1ACXEkMNcAkx1AAXE0MNcBEx1AAXEltl8QXEUAOcTww1wHnEUAN8lxhqgHOJoQY4hxhqgLOJoQY4ixh+Pws1QfBavqa4bj6W5fcIzoxoBzG/14HcGftb/dWm7HsdnCdDj5GriBzOEnCZIORSIuQyR8ilvZDLCiGXrkIuqG8UXEYJuRQKuUwVcikVclko5NJByGWNkEsvIZfBQi7jhFwOEnIpFnKZJeSyTMilrZDLZ0IunYVcNgq5VAu5jBByaSjkMlnIpbmQy3whlwohl1VCLj2EXAYKuYwRcikScpkh5NJayGWJkEtHIZf1Qi59hVyGCbkUCLlMFHJpKuQyV8ilTMjlACGXbkIu/YVcRgu5NBZymSbk0lLIZZGQS1rIZa2QS28hlyFCLuOFXJoIucwWcmkn5LJcyGWTkEsXIZcaIZeRQi6NhFymCLm0EHJZIORSKeSyWsilp5DLICGXsUIuKSGXmUIubYRclgq5fC7k0knIZYOQSz8hl+FCLg2EXCYJuTQTcpkn5FIu5LJSyKW7kMsAIZeMkEtSyGW6kEsrIZfFQi5VQi7rhFz6CLkMFXLJD7nw/GDCeQK+vxqcZx4UWi6ox/5ZWtfmZuNYLjiGbbF4MzHkxrxCG4vP3I7FEO5HkBPvIyNPMP2N4r+H+h706dPQcgXEki3rxqG0Zd1zPg+NQyN6TsZh3z6L6NunlPOvbnPW8Dhw/r8S+ySx+3j+jcbzLxHLcYyxw3K83WE5Hu8Ytpsa9gim8HaTJPY5OV3UrM7pG46d8ign2sVj5Ior75ZQ3i2hvPz7ffkxuyRCLol6XEYLuQwVcukv5NJHyGWzkMsWIZduQi7rhFyqhFwOEHIpE3JZLOTSSshlrpBLUyGX6UIuSSGXiUIuBUIuGSGXYUIuA4Rc+gq5HCzk0l3IZb2QS0chl5VCLuVCLkuEXFoLucwTcmkm5DJDyKVIyGWSkEsDIZcxQi7DhVwGCrn0E3I5RMilh5DLBiGXTkIuq4RcKoRclgq5tBFymS/k0lzIZaaQS0rIZbKQS0Mhl7FCLiOEXAYJuVQLuWwVcukp5LJRyKWzkMtqIZdKIZdlQi5thVwWCLm0EHKZJeRSLOQyRcilkZDLOCGXkUIug4VcaoRcegm5HCjksknIpYuQyxohlw5CLsuFXNoJuSwUcikVcpkt5NJEyGWqkEuhkMt4IZdRQi5DhFxqhVx6C7kcJOTSVchlrZBLWshlhZBLeyGXRUIuLYVc5gi5lAi5TBNyaSzkMkHIJW8fuyTJIUEM81cRO9Ti1cQOs3gNscMtXktsm8XriB1h8XpiR1q8gdhRFm8kdrTFBxI7xuJNxI61mH+L4TiLNxM73uItxE6w+GBiJ1p8CLHtFm8llm8xjzO+r3MoMVzreRgxXCdwODG8x7yNGM5PjiCG/exIYvj+1FHEcO3t0cSwXR5DDO/5H0sM54vHEcNx73hi+D7bCcSaWXwiMVxHg3EM+v9u67r5eH4+PQd5Cohtj8h3YoQXYt738JyM/a3+alN23+M8GXqMXHzf+eMFXCYIuTQWcpkm5FIi5DJHyKWlkMsiIZf2Qi4rhFzSQi5rhVy6CrkcJOTSW8ilVshliJDLKCGX8UIuhUIuU4Vcmgi5zBZyKRVyWSjk0k7IZbmQSwchlzVCLl2EXDYJuRwo5NJLyKVGyGWwkMtIIZdxQi6NhFymCLkUC7nMEnJpIeSyQMilrZDLMiGXSiGX1UIunYVcNgq59BRy2SrkUi3kMkjIZYSQy1ghl4ZCLpOFXFJCLjOFXJoLucwXcmkj5LJUyKVCyGWVkEsnIZcNQi49hFwOEXLpJ+QyUMhluJDLGCGXBkIuk4RcioRcZgi5NBNymSfk0lrIZYmQS7mQy0ohl45CLuuFXLoLuRws5NJXyGWAkMswIZeMkEuBkMtEIZekkMt0IZemQi5zhVxaCbksFnIpE3I5QMilSshlnZBLNyGXLUIum4Vc+gi59BdyGSrkMlrIJT/kwt+L3k4M38nm71fnh9rj76Jj+ULrX4sY+he+TyQe8+/sxpG3JJS3JJT3y+7XHodLIuSSqMeluZBLEyGXEiGXpJBLIyGXAiGXpkIuRUIuKSGXQiGXBkIuzYRcioVcGgu5NBRyydvHLl/2O1KYX0SsNOQfMPx+RzExvB/UhBg++yshhuu8mhLLj/DDa1MpMezzLYlhvbYihtfY1sRw7EL+4HlvlNfNx/s2+fQcm73L7xZVWNyAWCW1Cca/dw2WtriQGN4XaUysI8X4i+udeN2gL2XE0OdyYhibCmIYw0piGOsOxLBO0sTwHYwqYvi+Lbvj90w6RfSD9wE8J2N/q7/alN0HOE+GHiMX/55TJwGXhkIujYVcioVcmgm5NBByKRRySQm5FAm5NBVyKRByaSTkkhRyKRFyaSLk0lzIJX8vuaB+RLutQi5x5S0N5S3dS3nbhvK23Ut524fytt9Lef363Tt5/frdO3mV12/aad6B1fx+Aab63gNKk0uVU5fqmqDNDm7brA7arHTcZtBGBY0Jxg/uKZrP96OtcDxeeZQT7eJxRXx5s/0v/zf9L4/wKN+L/Wc/7+pdveu+da30rrG4+u3Vu3pX7+qPr/G4+u3Vu3pX7+qPr/G4+u3Vu3pX7+qPr/G4+u3Vu3pX7+qPr/G4+u3Vu3pX7+qPr/G4+u3Vu3pX7+qPr/G4+u3Vu3pX7+qPr/G4+u3Vu3pX7+qPr/G4+u3Vu3pX77qvj1lB3jKnedcNSIbyBlN9380ri3EMgjY7u20z+z2yLuSPviJPiubzttjFcd/yKCfaxWP2867e1bt6V+/qXb2rd/Wu3tW7elfv6l29q3f1rt7Vu3pX7+pdvat39a7e1bt6V+/qXb2rd/Wu3tW7elfv6l29q3f1rt7Vu3pX7+pdvat39a7e1bt6V+/qXb2rd/Wu3tW7elfv6l29q3f1rt7Vu3pX7+pdvat39a7e1bt6V+/qXb2rd/Wu3tW7elfv6l29q3f1rt7Vu3pX7+pdvat39a7e1bt6V+/qXb2rd/Wu3tW7elfv6l29q3f1rt7Vu3pX7+pdvat39a7e1bt6V+/qXb2rd/Wu3tW7elfv6l29q3f1rt7Vu3rX/cU1RfPzyaVzDC6JkEsiYlwwtRFyaSHk0lbIpVDIpYGQS0shl1Ihl+ZCLkkhl0ZCLgVCLq2FXFoJubQTcmkv5NJMyKWxkEtDIZe8feySJIcEMczPJ4YauYBYV4sbEOtmcUNi3amfYD0sLiTW0+LGxHpRjL+9LW5DrI/FrYn1tbgVsX4WtyRWbXEpsRqLWxCrtbgtsf4WtyM2wOL2xAZa3IzYIIubExtscUdiQyyuIjbU4g7EhllcTgzrkNc51mEXYliHXYlhHXYjhnXYnRjWYQ9iWIc9iWEd8jotsrg3MewjfYgVW9yXWBOL+xErsbiaWFOLa4hhPdQSw3roTwzrfwAxbCcDiWF7GkQM291gYtg+hxDDdjyUGLYxrNNgXSyrrJuP5/M+ijy8jw6LyDc0wgsxH5PwnIz9rf5qU/aYxHky9Bi5ishhsIBLQyGXxkIuzYRc2gu5tBNyaSXk0lrIpUDIpZGQS1LIpbmQS6mQS0shlwZCLoVCLm2FXFoIubQRcskPuXBNPYwY6nmuzfND7fE5FZYvtP6lHPePz5kS1E+eMhQjf+BS7NalOkUuxZSnxG2eWj7X25M+l5BLc7cu/fl8ck9c+H3+Zm5daoI2W7htM3vaXEr+6CvypGg+r/NSx33Lo5xoF4/Zz7u6dw1cmoQ8+b2QJgJ+YM3ic6lNhlyCqb59nT9fbO3WpT+/x7QnLvx5USu3LtnjThu3bVYHbbZ13GbQRjsaE4wf3FM0n68laOd4vPIoJ9rFY/bzru5d+VjB7/ljuRYCfmD8OUXj0PgF51rFdoFU0C7XFdtpeZyTFdAy71bUzWtaUfc8x/VILb+Hjqm+YxQfux3XpjnXaTHWrzUxnAdUx/B6lz1e8msMxi9FfzGfX+taOh6vvMSun5Nm6DH7eVf3rsHj5iFP/kyuuYAfWEl8LrXJkEsw1Xf84OvcHNdG/fmzxD1x4etFHdehNXHUaTG89maPZe1pTDB+cE/RfL6GqL3j8cqjnGgXj9nPu7p35WMF11bsuq/9wPh8zfX+xddecD05kepJrsW20/J4X72AljmU6skpFvNnwkX0F68heM+Ar+WI+30E5EG7eFxKfngNKSaGmK/9aRlicZxX5yV2rRMy9LgV+cG/JTHEfC1R6xCL4bUp69w65IzHbcgP/q2JIU6Rc9S+Gcd52Zftm+3ID/5tI/z4Oi48h+sl7OMlxMosLiaGa7X42jN8D4bPV+3Sn12OY7j2i695S1vM18blR/QDn1fwdWs4d+Tr1nD9SxkxfGbN15nhOFFBDOeklcRwXOHr1nC8SNtffHbi+v3yPHJHu3jMx7+mbvPW8vVmmOqr3/j8AM/j6ylLIpwdnz9nx6ok5Bc+VqYSu9bgcbkkQy7/bvyi/Pj7OY7PFaoDl9KQC7ZzPi9w/HpRHfV6gX62onHi6/Uzid1fP+J+XWgY8kCuAlrm23bgaJKIpQbKXtKJXPmJ3euhYOK6Fvsbv161Cy0XeJY5HrewB/KXEauI8GxPnuWh5QLPSreetWEPeFYSS0d4VpBnh9BywfaAMb6YasxfU42J9rnOKQuxuOp5XgcZesxjj/6VkYvj+qV/DPtHdrvDftmA+tGW1g3mX0vr5vqK3ddDJbVzb8R8TPUdw/ncMc7jJo6JrSLyxnFO0pL6zq8b4AUU30M7GL++hGtBrqW/7PPmstBz+PPm1jH3md+7ytBj5Aq2k5tom7qXPqNwvR9zf3lckjQumF9OrHnE8tgf+Ljjer+s7zMkPlcC42MRfx4H53YhFsd7hHmJXT8fzNBjfj0Nn3PFsK/3j+N96qAN3nbRD96HMf9Z2q6fr9h9PfAx982I+ZjqO1Zyfef43KWazwNwrGwakTfO8w8cK5EDvIDin9Kxkt/3wfjCmd+n4uU4Dp/Pp2h+3Odc/Jllhh4jV7CdvETb1Jt0rHS9H3N/eVz4WIn5HYilIpbna3fgG8fnR+HzsPDra9TrHteYMexDu40jxo/fLwJrRk4TycnxdYzZsSpI7DpWeBzjNYv/z9cI8GtwPo1b0whn15/f17dflpAfWEGMLrle1xDlx78P4vq6hKj33RuTA/K6vnYh6rNj9LOUxok/X88kdn2vCDzO9/UbhjyQi+v+/wy9F+L6WsIE5cqn9cN1Mb8vgv2NP28I16BxvE8f9kB+ro3KIjzbkmf70HKBZ7lbz9qwBzzLiVVGeJaRZ0VoOT7fbmQw2J4XVdY9B+3zZ2vtQiyuc5Ivq+957NE//kyFY/i53r7j2IeDNrBeGyR2P5/m/bc5ra9S+s42xqac2ukYMR/Tnl7f67g2qA5/HpyhHJzXdZ3EeVHzIwc4fw5dRTsVvyZifOHMn5nychy3DT2HXy9LY+4z10OZxO7XXwXbSWvaprDNxPG+PfeXx4XfN8B8vo6hSWh5/sycj0X74jNzvr6OP5MOf6bPn5nz5/xxvCf2ZZ+Z87UJ9X1mzsdPxzV6/7jOgVCLNqC+cc2M+QNpWx9Mx8fwuVz2HCliPqY9vfY4jhq4ktrPUA7O28Ft3hrOi+MncnBdgXgCHT871IW7nCsHE18Tw8txHD6/T9H84pj7/GXXjCJXsJ0Mo21qIh0/XZ9Xc395XPhaF8yvIBb+jhN/5s3Hojhef77sc35+/wuMX1NLKIZfHNds8Ot048ReuP6hZtfzyUaJXd9rQK4CWmaBbVNNjBWFxpBr9zjGidcNxonHiK/HaU5OxfQek+vzolw/8+PPW8L1NV8Xxedyjj/Xzm5vFSG/8LlZihjXwxUxuHzZNYwVMef9smNC3HmbhfI220t5v+w7p3Hn/bLrEPm1AVN+zC6JkEuiHpd2Qi4thVyaCrk0E3IpEnIpFHJpIOTSXsiljZBLWyGXUiGXJkIuJUIuSSGXRkIuBUIuZUIurYRc4j6fycWFP9Pf1y4thFxSQi7FQi6NhVwaCrnk7WOXZCL6d+Yxn6/nwXssRcT42jKwtMX8Xboqi/nz8I4W8/fwOlnM11/h99H5/TL8Pjp/16CrxfyZEX4fnd+7xe+j83f4eljM383raTF/bobx4PHDayd/lw7nDvxdOmx3aWKoAaqI4RyoIzHsP52IoZbh34/HuuHfj8e66UoM64Z/Px7rhn8/HuumBzGsG4xP0K/H03Xz8XzedpCHf/+8Z0S+HhFeiHlfwXMy9rf6q03ZfYXzZOgxcvHvn3cTcGko5NJYyKVYyCUl5NJCyKW5kEtrIZdWQi5lQi4FQi6NhFySQi4lQi5NhFxKhVzaCrm0EXJpL+TSQMilUMilSMilmZBLUyGXlkIu7YRc8veSC86f0W6PkEuQt6vbvNnf8+P7iOO8viv1H/m7kIfj+ypmrwtjjzTl7Ux5Ozke96CNjhH970T9R/6O5NHRsUd91y7ze0nYL7B+gtebTIc6r25uvVbnJXbd/rYndt83C2iZmR3qvMZ3qBtDXIPG3/OvDLG4r91Fu3iMXFHfE2I//j0uPIffQ8yPeG5BKEdhIpb1U83rJ5jSid3XDx/nGiV23bf4/qNYZh6tw3PTdc9z7J69zSO/3xh1zHe8v2e/U4Z9J0Ht8xhWURx1POwYWg5j6tCzJuyB/GlilRGeVeQZvkY9hs8pqsP7F18bz9d7VkT0pRN5Ob5Gtt7X03LK28tt3lr+7UEek0TIBVMvcunr1iX7+8a9c3DpSy593Lpkf9+4n9s2s79vXO24zaCNGhoTjB/cUzS/msarxvF45VFOtIvH7Odd3bsGLuUhzyQtVy7gB8b3cm4fGr/g9fvE+GrD/lG1Yfi9GK4NL0jXeZ1MtWH30Ljy58E81q5r/7zErrVAJrH7a1MR9aUruTg+D9vlXBTt+rzO13l21+C6Ctser2/kj7u+6xDhkSYP5O9AHo7rt2w93CvCI+r3JLlW6e14PJIhj2Cqr1bpTS6O66asS58cXLhuclyP1PDrzp648GtnbQwuNTm41JLLgBhc+ufgMoBcBsXgMjAHl0HkMiQGl8E5uCB/UFNg/+tKDPtBFTFsj3z9GLaLzsSwfjoSwzjlE4MvX6M21GJ+v2h4iAXjNyLUp+qvNmVfl5AH7eLxCPLDvWyHx+cyhNvn90dGUM6RjvvfiNpy0+bA7HnaGMeeQRtjra3s99AtRp4Cmv8kvZ/1tMXB9jTK5g+ldn4cMR9TfftRhtbJeLd9zb7HMoHaz0TkCPhEt3lrOG+e/UMO8AKKf0QFzcS6cOf4wjnYf8ZFLMfxqNBzUjR/XMx9Hk8eGXqMXMF28hxtUz+mc6zRjn24vzwuw2lcMH8kLTeWYiybpnEb59Rzxz7ueLvP9n0CjTnGFnl423uL1sfbtA+PCY1bMP+jiPmY6tvHebub5Lav2X18MrWfoRycd4rbvDWcF/s4coAXUPxH2sen1IU7xxfOwT4+MWI5jseEnpOi+RNj7vMk8sjQY+QKtpPf0Db1Ee3jGcc+3F8el7E0LpjflZabQDGWTdO4uT027tjHHW/32b5PpjFHu8jD295ntD6+oH14fGjcgvkN0rvPx1TfPs7b3VS3fc3u49Oo/Qzl4LzT3eat4bzYx5EDvIDjdGLnNL0u3Dm+cA728SkRy3E8PvScFM2fEnOfp5JHhh4jV7Cd/CdtU9hm3L8+7tjOp0SMywQaF8zn96cmU4xl0zRubo+NO/Zxx9t9tu/TaMwxtsjD216TdN1yTS0O9uFJoXEL5ldGzMdU3z7O290Mt33N7uMzqf0M5eC8s9zmreG82MeRA7yA4op0Yuc0qy7cOb5wDvbx6RHLcTwp9JwUzZ8ec59nkEeGHiNXsJ20SNfF2GbiOHfg/vK4TKZxwXx+73caxVg2TePm9ti4Yx93vN1n+z6Txhxjizy87XVL1y3Xw+JgH54aGrdg/pCI+Zjq28d5u5vttq/ZfXwOtZ+hHJx3rtu8NZwX+zhygBdQPDid2DnNrQt3ji+cg318VsRyHE8NPSdF82fF3OfZ5JGhx8gVbCe903Uxtpk4zh24vzwu02hcML8zLTeTYiybpnFze2zcsY873u6zfZ9DY46xRR7e9sak65YbZ3GwD88IjVswf27EfEz17eO83c1z29fsPj6f2s9QDs67wG3eGs6LfRw5wAsonpNO7JwW1IU7xxfOwT4+N2I5jmeEnpOi+XNj7vM88sjQY+TKvqak62JsM3GcO3B/eVxm0rhgfkdabg7FWDZN4+b22LhjH3e83Wf7Pp/GHGOLPLztLUvXLbfC4mAfnh0at2D+loj5mOrbx3m7W+i2r9l9fBG1n6EcnHex27w1nBf7OHKAF1C8OZ3YOS2uC3eOL5yDfXxBxHIczw49J0XzF8Tc54XkkaHHyBVsJ6vSdTG2mTjOHbi/PC5zaFwwP5+Wm08xlk3TuLk9Nu7Yxx1v99m+L6Ixx9giD297R6TrljvK4mAfnhcat2D+aRHzMdW3j/N2t8RtX7P7+FJqP0M5OO8yt3lrOC/2ceQAL6D41HRi57SsLtw5vnAO9vHFEctxPC/0nBTNXxxzn5eQR4YeI1ewnRybrouxzcRx7sD95XGZT+OC+fwbxGWh5YPtGfsDX3vger/k1wW0i8d8vAbj858Yv6eRHUf+fkT4exr8vaTu5JTZj6/xDMe4rpW/x8Dv00Z9T6RTaLmgf46/39Q/hu8wZNc3rq9rQGODPAU0/9p03XLXW8y/GcXbw70R8zHV9/rA1z86vtavmq+3xutD34i8rq/r47x4fUAO8AKK70kndk7VdeHO8YVzsN31iViO46rQc1I0v0/Mfe5LHhl6zNes35Sui7HNxHUNbp+IceH772A+f1cpzv2N8/cij/KQI38XkY+frr+3w9/nQrt43If8wvec5+8j8LGEv48Q9z0tMond73MVV96GobwN91LewlDewr2UNxnKm9xLeb/snjRx593729W6AUGbpY7bzPU+sfy72C2culTXNE7U/fbcxvXbZm7dtv7wPHKC55v2t4i8+Jy8gJ7TIII1imCNI1hRiAUT3yekCcV8P72SkCffo41/4xK/D8a/cYl+8O9ZIj+WL0zsvo6cbtyJUALE+YldBwhTcxtRXIg8b9vWw1ZvXJ8+fMvWbenq9CH/+n/1li1bj1q/rm+a5x2ePviIw7elD9+2+rBt6Q2HbT04XdOX273ZRhUvaKu3bVt/8De2pbdtTa9ety591KZtB6a3Hrn+sA3/apufN79yz5/3fwGIK72/IVkFAA==",
            "verificationKey": "0000000200000800000000740000000f00000003515f3109623eb3c25aa5b16a1a79fd558bac7a7ce62c4560a8c537c77ce80dd339128d1d37b6582ee9e6df9567efb64313471dfa18f520f9ce53161b50dbf7731bc5f900000003515f322bc4cce83a486a92c92fd59bd84e0f92595baa639fc2ed86b00ffa0dfded2a092a669a3bdb7a273a015eda494457cc7ed5236f26cee330c290d45a33b9daa94800000003515f332729426c008c085a81bd34d8ef12dd31e80130339ef99d50013a89e4558eee6d0fa4ffe2ee7b7b62eb92608b2251ac31396a718f9b34978888789042b790a30100000003515f342be6b6824a913eb7a57b03cb1ee7bfb4de02f2f65fe8a4e97baa7766ddb353a82a8a25c49dc63778cd9fe96173f12a2bc77f3682f4c4448f98f1df82c75234a100000003515f351f85760d6ab567465aadc2f180af9eae3800e6958fec96aef53fd8a7b195d7c000c6267a0dd5cfc22b3fe804f53e266069c0e36f51885baec1e7e67650c62e170000000c515f41524954484d455449430d9d0f8ece2aa12012fa21e6e5c859e97bd5704e5c122064a66051294bc5e04213f61f54a0ebdf6fee4d4a6ecf693478191de0c2899bcd8e86a636c8d3eff43400000003515f43224a99d02c86336737c8dd5b746c40d2be6aead8393889a76a18d664029096e90f7fe81adcc92a74350eada9622ac453f49ebac24a066a1f83b394df54dfa0130000000c515f46495845445f42415345060e8a013ed289c2f9fd7473b04f6594b138ddb4b4cf6b901622a14088f04b8d2c83ff74fce56e3d5573b99c7b26d85d5046ce0c6559506acb7a675e7713eb3a00000007515f4c4f4749430721a91cb8da4b917e054f72147e1760cfe0ef3d45090ac0f4961d84ec1996961a25e787b26bd8b50b1a99450f77a424a83513c2b33af268cd253b0587ff50c700000003515f4d05dbd8623b8652511e1eb38d38887a69eceb082f807514f09e127237c5213b401b9325b48c6c225968002318095f89d0ef9cf629b2b7f0172e03bc39aacf6ed800000007515f52414e474504b57a3805e41df328f5ca9aefa40fad5917391543b7b65c6476e60b8f72e9ad07c92f3b3e11c8feae96dedc4b14a6226ef3201244f37cfc1ee5b96781f48d2b000000075349474d415f3125001d1954a18571eaa007144c5a567bb0d2be4def08a8be918b8c05e3b27d312c59ed41e09e144eab5de77ca89a2fd783be702a47c951d3112e3de02ce6e47c000000075349474d415f3223994e6a23618e60fa01c449a7ab88378709197e186d48d604bfb6931ffb15ad11c5ec7a0700570f80088fd5198ab5d5c227f2ad2a455a6edeec024156bb7beb000000075349474d415f3300cda5845f23468a13275d18bddae27c6bb189cf9aa95b6a03a0cb6688c7e8d829639b45cf8607c525cc400b55ebf90205f2f378626dc3406cc59b2d1b474fba000000075349474d415f342d299e7928496ea2d37f10b43afd6a80c90a33b483090d18069ffa275eedb2fc2f82121e8de43dc036d99b478b6227ceef34248939987a19011f065d8b5cef5c0000000010000000000000000100000002000000030000000400000005000000060000000700000008000000090000000a0000000b0000000c0000000d0000000e0000000f"
        },
        {
            "name": "increment",
            "functionType": "secret",
            "isInternal": false,
            "parameters": [
                {
                    "name": "owner",
                    "type": {
                        "kind": "field"
                    },
                    "visibility": "private"
                }
            ],
            "returnTypes": [],
            "bytecode": "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",
            "verificationKey": "0000000200000800000000740000000f00000003515f3109623eb3c25aa5b16a1a79fd558bac7a7ce62c4560a8c537c77ce80dd339128d1d37b6582ee9e6df9567efb64313471dfa18f520f9ce53161b50dbf7731bc5f900000003515f322bc4cce83a486a92c92fd59bd84e0f92595baa639fc2ed86b00ffa0dfded2a092a669a3bdb7a273a015eda494457cc7ed5236f26cee330c290d45a33b9daa94800000003515f332729426c008c085a81bd34d8ef12dd31e80130339ef99d50013a89e4558eee6d0fa4ffe2ee7b7b62eb92608b2251ac31396a718f9b34978888789042b790a30100000003515f342be6b6824a913eb7a57b03cb1ee7bfb4de02f2f65fe8a4e97baa7766ddb353a82a8a25c49dc63778cd9fe96173f12a2bc77f3682f4c4448f98f1df82c75234a100000003515f351f85760d6ab567465aadc2f180af9eae3800e6958fec96aef53fd8a7b195d7c000c6267a0dd5cfc22b3fe804f53e266069c0e36f51885baec1e7e67650c62e170000000c515f41524954484d455449430d9d0f8ece2aa12012fa21e6e5c859e97bd5704e5c122064a66051294bc5e04213f61f54a0ebdf6fee4d4a6ecf693478191de0c2899bcd8e86a636c8d3eff43400000003515f43224a99d02c86336737c8dd5b746c40d2be6aead8393889a76a18d664029096e90f7fe81adcc92a74350eada9622ac453f49ebac24a066a1f83b394df54dfa0130000000c515f46495845445f42415345060e8a013ed289c2f9fd7473b04f6594b138ddb4b4cf6b901622a14088f04b8d2c83ff74fce56e3d5573b99c7b26d85d5046ce0c6559506acb7a675e7713eb3a00000007515f4c4f4749430721a91cb8da4b917e054f72147e1760cfe0ef3d45090ac0f4961d84ec1996961a25e787b26bd8b50b1a99450f77a424a83513c2b33af268cd253b0587ff50c700000003515f4d05dbd8623b8652511e1eb38d38887a69eceb082f807514f09e127237c5213b401b9325b48c6c225968002318095f89d0ef9cf629b2b7f0172e03bc39aacf6ed800000007515f52414e474504b57a3805e41df328f5ca9aefa40fad5917391543b7b65c6476e60b8f72e9ad07c92f3b3e11c8feae96dedc4b14a6226ef3201244f37cfc1ee5b96781f48d2b000000075349474d415f3125001d1954a18571eaa007144c5a567bb0d2be4def08a8be918b8c05e3b27d312c59ed41e09e144eab5de77ca89a2fd783be702a47c951d3112e3de02ce6e47c000000075349474d415f3223994e6a23618e60fa01c449a7ab88378709197e186d48d604bfb6931ffb15ad11c5ec7a0700570f80088fd5198ab5d5c227f2ad2a455a6edeec024156bb7beb000000075349474d415f3300cda5845f23468a13275d18bddae27c6bb189cf9aa95b6a03a0cb6688c7e8d829639b45cf8607c525cc400b55ebf90205f2f378626dc3406cc59b2d1b474fba000000075349474d415f342d299e7928496ea2d37f10b43afd6a80c90a33b483090d18069ffa275eedb2fc2f82121e8de43dc036d99b478b6227ceef34248939987a19011f065d8b5cef5c0000000010000000000000000100000002000000030000000400000005000000060000000700000008000000090000000a0000000b0000000c0000000d0000000e0000000f"
        }
    ],
    "events": [],
    "debug": {
        "debugSymbols": [
            "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TGbnZTI7L5PZeZnMzstkdl4ms/MymZ2Xyey8TGbnZTI7L5PZeZnMzstkdl4ms/MymZ2Xyey8TGbnZTI7L5PZeZnMzstkdl4ms/MymZ2Xyey8TGbnZTI7L5PZeZnMzstkdl4ms/MymZ2Xyey8TGbnZTI7L5PZeZnMzstkdl4ms/MymZ2Xyey8TGbnZTI7L5PZeZnMzstkdl4ms/MymZ2Xyey8TGbnZTI7L5PZeZnMzstkdl4ms/MymZ2Xyey8TGbnZTI7L5PZeZnMzstkdl4ms/MymZ2Xyey8TGbnZTI7L5PZeZnMzstkdl4ms/MymZ2Xyey8TGbnZTI7L5PZeZnMzstkdl4ms/MymZ2Xyey8TGbn1WV2Xl1m59Vldl5dZufVP1TO2C6z8+oyO68us/PqMjuvLrPz6jI7ry6z8+oyO68us/PqMjuvLrPz6jI7ry6z8+oyO68us/PqMjuvLrPz6jI7ry6z8+oyO68us/PqMjuvLrPz6jI7ry6z8+oyO68us/PqMjuvLrPz6jI7ry6z8+oyO68us/PqMjuvLrPz6jI7ry6z8+oyO68us/PqMjuvLrPz6jI7ry6z8+oyO68us/PqMjuvLrPz6jI7ry6z8+oyO68us/PqMjuvLrPz6jI7ry6z8+oyO68us/PqMjuvLrPz6jI7ry6z8+oyO68us/PqMjuvLrPz6jI7ry6z8+oyO68us/PqMjuvLrPz6jI7ry6z8+oyO68us/PqMjuvLrPz6jI7ry6z8+oyO68us/PqMjuvLrPz6jI7ry6z8+oyO68us/PqMjuvLrPz6jI7ry6z8+oyO68us/PqMjuvLrPzcpmdl8vsvFxm5+UyOy//UDljXWbn5TI7L5fZebnMzstldl4us/NymZ2Xy+y8XGbn5TI7L5fZebnMzstldl4us/NymZ2Xy+y8XGbn5TI7L5fZebnMzstldl4us/NymZ2Xy+y8XGbn5TI7L5fZebnMzstldl4us/NymZ2Xy+y8XGbn5TI7L5fZebnMzstldl4us/NymZ2Xy+y8XGbn5TI7L5fZebnMzstldl4us/NymZ2Xy+y8XGbn5TI7L5fZebnMzstldl4us/NymZ2Xy+y8XGbn5TI7L5fZebnMzstldl4us/NymZ2Xy+y8XGbn5TI7L5fZebnMzstldl4us/NymZ2Xy+y8XGbn5TI7L5fZebnMzstldl4us/NymZ2Xy+y8XGbn5TI7L5fZebnMzstldl4us/NymZ2Xy+y8XGbn5TI7L5fZebnMzstldl4us/NymZ3XkNl5DZmd15DZeQ2Zndf4UDljh8zOa8jsvIbMzmvI7LyGzM5ryOy8hszOa8jsvIbMzmvI7LyGzM5ryOy8hszOa8jsvIbMzmvI7LyGzM5ryOy8hszOa8jsvIbMzmvI7LyGzM5ryOy8hszOa8jsvIbMzmvI7LyGzM5ryOy8hszOa8jsvIbMzmvI7LyGzM5ryOy8hszOa8jsvIbMzmvI7LyGzM5ryOy8hszOa8jsvIbMzmvI7LyGzM5ryOy8hszOa8jsvIbMzmvI7LyGzM5ryOy8hszOa8jsvIbMzmvI7LyGzM5ryOy8hszOa8jsvIbMzmvI7LyGzM5ryOy8hszOa8jsvIbMzmvI7LyGzM5ryOy8hszOa8jsvIbMzmvI7LyGzM5ryOy8hszOa8jsvIbMzmvI7LyGzM5ryOy8hszOa8jsvIbMzmvI7LyGzM5ryOy8hszOa8jsvIbMzmvI7LyGzM4rZHZeIbPzCpmdV8jsvOJD5YwNmZ1XyOy8QmbnFTI7r5DZeYXMzitkdl4hs/MKmZ1XyOy8QmbnFTI7r5DZeYXMzitkdl4hs/MKmZ1XyOy8QmbnFTI7r5DZeYXMzitkdl4hs/MKmZ1XyOy8QmbnFTI7r5DZeYXMzitkdl4hs/MKmZ1XyOy8QmbnFTI7r5DZeYXMzitkdl4hs/MKmZ1XyOy8QmbnFTI7r5DZeYXMzitkdl4hs/MKmZ1XyOy8QmbnFTI7r5DZeYXMzitkdl4hs/MKmZ1XyOy8QmbnFTI7r5DZeYXMzitkdl4hs/MKmZ1XyOy8QmbnFTI7r5DZeYXMzitkdl4hs/MKmZ1XyOy8QmbnFTI7r5DZeYXMzitkdl4hs/MKmZ1XyOy8QmbnFTI7r5DZeYXMzitkdl4hs/MKmZ1XyOy8QmbnFTI7r5DZeYXMzitkdl4ps/NKmZ1Xyuy8UmbnlR8qZ2zK7LxSZueVMjuvlNl5pczOK2V2Ximz80qZnVfK7LxSZueVMjuvlNl5pczOK2V2Ximz80qZnVfK7LxSZueVMjuvlNl5pczOK2V2Ximz80qZnVfK7LxSZueVMjuvlNl5pczOK2V2Ximz80qZnVfK7LxSZueVMjuvlNl5pczOK2V2Ximz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TGdLZjpbMtPZkpnOlsx0tmSmsyUznS2Z6WzJTGdLZjpbMtPZkpnOlsx0tmSmsyUznS2Z6WzJTGdLZjpbMtPZkpnOlsx0tmSmsyUznS2Z6WzJTGdLZjpbMtPZkpnOlsx0tmSmsyUznS2Z6WzJTGdLZjpbMtPZkpnOlsx0tmSmsyUznS2Z6WzJTGdLZjpbMtPZkpnOlsx0tmSmsyUznS2Z6WzJTGdLZjpbMtPZkpnOlsx0tmSmsyUznS2Z6WzJTGdLZjpbMtPZkpnOlsx0tmSmsyUznS2Z6WzJTGdLZjpbMtPZkpnOlsx0tmSmsyUznS2Z6WzJTGdLZjpbMtPZkpnOlsx0tmSmsyUznS2Z6WzJTGdLZjpbMtPZkpnOlqzrbMm6zpas62zJus6WrH/InLZdZ0vWdbZkXWdL1nW2ZF1nS9Z1tmRdZ0vWdbZkXWdL1nW2ZF1nS9Z1tmRdZ0vWdbZkXWdL1nW2ZF1nS9Z1tmRdZ0vWdbZkXWdL1nW2ZF1nS9Z1tmRdZ0vWdbZkXWdL1nW2ZF1nS9Z1tmRdZ0vWdbZkXWdL1nW2ZF1nS9Z1tmRdZ0vWdbZkXWdL1nW2ZF1nS9Z1tmRdZ0vWdbZkXWdL1nW2ZF1nS9Z1tmRdZ0vWdbZkXWdL1nW2ZF1nS9Z1tmRdZ0vWdbZkXWdL1nW2ZF1nS9Z1tmRdZ0vWdbZkXWdL1nW2ZF1nS9Z1tmRdZ0vWdbZkXWdL1nW2ZF1nS9Z1tmRdZ0vWdbZkXWdL1nW2ZF1nS9Z1tmRdZ0vWdbZkXWdL1nW2ZF1nS9Z1tmRdZ0vWdbZkXWdL1nW2ZF1nS9Z1tmRdZ0vWdbZkXWdL1nW2ZF1nS+Y6WzLX2ZK5zpbMdbZk/iFz2rrOlsx1tmSusyVznS2Z62zJXGdL5jpbMtfZkrnOlsx1tmSusyVznS2Z62zJXGdL5jpbMtfZkrnOlsx1tmSusyVznS2Z62zJXGdL5jpbMtfZkrnOlsx1tmSusyVznS2Z62zJXGdL5jpbMtfZkrnOlsx1tmSusyVznS2Z62zJXGdL5jpbMtfZkrnOlsx1tmSusyVznS2Z62zJXGdL5jpbMtfZkrnOlsx1tmSusyVznS2Z62zJXGdL5jpbMtfZkrnOlsx1tmSusyVznS2Z62zJXGdL5jpbMtfZkrnOlsx1tmSusyVznS2Z62zJXGdL5jpbMtfZkrnOlsx1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asiDGvKghjyoIQ9qyIMa8qCGPKghD2rIgxryoIY8qCEPasiDGvKghjyoIQ9qyIMa8qCGPKghD2rIgxryoIY8qCEPasiDGvKghjyoIQ9qyIMa8qCGPKghD2rIgxryoIY8qCEPasiDGvKghjyoIQ9qyIMa8qCGPKghD2rIgxryoIY8qCEPasiDGvKghjyoIQ9qyIMa8qCGPKghD2rIgxryoIY8qCEPasiDGvKghjyoIQ9qyIMa8qCGPKghD2rIgxryoIY8qCEPasiDGvKghjyoIQ9qyIMa8qCGPKghD2rIgxryoIY8qCEPasiDGvKghjyoIQ9qyIMa8qCGPKghD2rIgxpyUEMOashBDTmoIQc15KCGHNSQgxpyUEMOashBDTmoIQc15KCGHNSQgxpyUEMOashBDTmoIQc15KCGHNSQgxpyUEMOashBDTmoIQc15KCGHNSQgxpyUEMOashBDTmoIQc15KCGHNSQgxpyUEMOashBDTmoIQc15KCGHNSQgxpyUEMOashBDTmoIQc15KCGHNSQgxpyUEMOashBDTmoIQc15KCGHNSQgxpyUEMOashBDTmoIQc15KCGHNSQgxpyUEMOashBDTmoIQc15KCGHNSQgxpyUEMOashBDTmoIQc15KCGHNSQgxpyUEMOashBDTmoIQc15KCGHNSQgxpyUEMOashBDTmoISc15KSGnNSQkxpyUkNOashJDTmpISc15KSGnNSQkxpyUkNOashJDTmpISc15KSGnNSQkxpyUkNOashJDTmpISc15KSGnNSQkxpyUkNOashJDTmpISc15KSGnNSQkxpyUkNOashJDTmpISc15KSGnNSQkxpyUkNOashJDTmpISc15KSGnNSQkxpyUkNOashJDTmpISc15KSGnNSQkxpyUkNOashJDTmpISc15KSGnNSQkxpyUkNOashJDTmpISc15KSGnNSQkxpyUkNOashJDTmpISc15KSGnNSQkxpyUkNOashJDTmpISc15KSGnNSQkxpyUkNOashJDTmpISc15KSGnNSQkxrypIY8qSFPasiTGvKkhjypIU9qyJMa8qSGPKkhT2rIkxrypIY8qSFPasiTGvKkhjypIU9qyJMa8qSGPKkhT2rIkxrypIY8qSFPasiTGvKkhjypIU9qyJMa8qSGPKkhT2rIkxrypIY8qSFPasiTGvKkhjypIU9q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huzUkJ0aslNDdmrITg3ZqSE7NWSnhuzUkJ0aslNDdmrITg3ZqSE7NWSnhuzUkJ0aslNDdmrITg3ZqSE7NWSnhuzUkJ0aslNDdmrITg3ZqSE7NWSnhuzUkJ0aslNDdmrITg3ZqSE7NWSnhuzUkJ0aslNDdmrIgxryoIY8qCEPasiDGvKghjyoIQ9qyIMa8qCGPKghD2rIgxryoIY8qCEPasiDGvKghjyoIQ9qyIMa8qCGPKghD2rIgxryoIY8qCEPasiDGvKghjyoIQ9qyIMa8qCGPKghD2rIgxryoIY8qCEPasiDGvKghjyoIQ9qyIMa8qCGPKghD2rIgxryoIY8qCEPasiDGvKghjyoIQ9qyIMa8qCGPKghD2rIgxryoIY8qCEPasiDGvKghjyoIQ9qyIMa8qCGPKghD2rIgxryoIY8qCEPasiDGvKghjyoIQ9qyIMa8qCGPKghD2rIgxryoIY8qCEPasiDGvKghjyoIQ9qyIMa8qCGPKghD2rIgxryoIY8qCEPashBDTmoIQc15KCGHNSQgxpyUEMOashBDTmoIQc15KCGHNSQgxpyUEMOashBDTmoIQc15KCGHNSQgxpyUEMOashBDTmoIQc15KCGHNSQgxpyUEMOashBDTmoIQc15KCGHNSQgxpyUEMOashBDTmoIQc15KCGHNSQgxpyUEMOashBDTmoIQc15KCGHNSQgxpyUEMOashBDTmoIQc15KCGHNSQgxpyUEMOashBDTmoIQc15KCGHNSQgxpyUEMOashBDTmoIQc15KCGHNSQgxpyUEMOashBDTmoIQc15KCGHNSQgxpyUEMOashBDTmoIQc15KCGHNSQgxpyUEMOashBDTmoIQc15KCGnNSQkxpyUkNOashJDTmpISc15KSGnNSQkxpyUkNOashJDTmpISc15KSGnNSQkxpyUkNOashJDTmpISc15KSGnNSQkxpyUkNOashJDTmpISc15KSGnNSQkxpyUkNOashJDTmpISc15KSGnNSQkxpyUkNOashJDTmpISc15KSGnNSQkxpyUkNOashJDTmpISc15KSGnNSQkxpyUkNOashJDTmpISc15KSGnNSQkxpyUkNOashJDTmpISc15KSGnNSQkxpyUkNOashJDTmpISc15KSGnNSQkxpyUkNOashJDTmpISc15KSGnNSQkxpyUkNOashJDTmp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"
        ],
        "fileMap": {
            "1": {
                "source": "contract Counter {\n    // docs:start:imports\n    use dep::aztec::{\n        context::{PrivateContext, Context},\n        note::{\n            note_header::NoteHeader,\n            utils as note_utils,\n        },\n        state_vars::map::Map,\n    };\n    use dep::value_note::{\n            balance_utils,\n            value_note::{\n                ValueNoteMethods,\n                VALUE_NOTE_LEN,\n            },\n    };\n    use dep::easy_private_state::easy_private_state::EasyPrivateUint;\n    // docs:end:imports\n\n    // docs:start:storage_struct\n\n    struct Storage {\n        counters: Map<EasyPrivateUint>,\n    }\n\n    // docs:end:storage_struct\n\n    // docs:start:storage_init\n    impl Storage {\n        fn init(context: Context) -> pub Self {\n            Storage {\n                counters: Map::new(\n                    context,\n                    1,\n                    |context, slot| {\n                        EasyPrivateUint::new(context, slot)\n                    },\n                ),\n            }\n        }\n    }\n    // docs:end:storage_init\n\n    // docs:start:constructor\n    #[aztec(private)]\n    fn constructor(headstart: u120, owner: Field) {\n        let counters = storage.counters;\n        counters.at(owner).add(headstart, owner);\n    }\n    // docs:end:constructor\n\n    // docs:start:increment\n    #[aztec(private)]\n      fn increment(owner: Field) {\n        let counters = storage.counters;\n        counters.at(owner).add(1, owner);\n    }\n    // docs:end:increment\n\n    // docs:start:get_counter\n    unconstrained fn get_counter(owner: Field) -> Field {\n        let counters = storage.counters;\n        balance_utils::get_balance(counters.at(owner).set)\n    }\n    // docs:end:get_counter\n\n    // docs:start:nullifier\n    unconstrained fn compute_note_hash_and_nullifier(contract_address: Field, nonce: Field, storage_slot: Field, preimage: [Field; VALUE_NOTE_LEN]) -> [Field; 4] {\n        let note_header = NoteHeader::new(contract_address, nonce, storage_slot);\n        note_utils::compute_note_hash_and_nullifier(ValueNoteMethods, note_header, preimage)\n    }\n    // docs:end:nullifier\n}\n",
                "path": "/usr/src/yarn-project/noir-contracts/src/contracts/counter_contract/src/main.nr"
            },
            "19": {
                "source": "struct GrumpkinScalar {\n    low: Field,\n    high: Field,\n}\n\nimpl GrumpkinScalar {\n    pub fn new(low: Field, high: Field) -> Self {\n        // TODO: check that the low and high value fit within the grumpkin modulus\n        GrumpkinScalar { low, high }\n    }\n}\n\nglobal GRUMPKIN_SCALAR_SERIALIZED_LEN: Field = 2;\n\npub fn deserialize_grumpkin_scalar(fields: [Field; GRUMPKIN_SCALAR_SERIALIZED_LEN]) -> GrumpkinScalar {\n    GrumpkinScalar { low: fields[0], high: fields[1] }\n}\n\npub fn serialize_grumpkin_scalar(scalar: GrumpkinScalar) -> [Field; GRUMPKIN_SCALAR_SERIALIZED_LEN] {\n    [scalar.low, scalar.high]\n}\n",
                "path": "std/grumpkin_scalar.nr"
            },
            "20": {
                "source": "use crate::grumpkin_scalar::GrumpkinScalar;\nuse crate::scalar_mul::fixed_base_embedded_curve;\n\npub fn grumpkin_fixed_base(scalar: GrumpkinScalar) -> [Field; 2] {\n    // TODO: this should use both the low and high limbs to do the scalar multiplication\n    fixed_base_embedded_curve(scalar.low, scalar.high)\n}\n",
                "path": "std/grumpkin_scalar_mul.nr"
            },
            "35": {
                "source": "struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::unsafe::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<U, Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n",
                "path": "std/option.nr"
            },
            "94": {
                "source": "use dep::protocol_types::constants::{\n    RETURN_VALUES_LENGTH,\n    MAX_READ_REQUESTS_PER_CALL,\n    MAX_PENDING_READ_REQUESTS_PER_CALL,\n    MAX_NEW_COMMITMENTS_PER_CALL,\n    MAX_NEW_NULLIFIERS_PER_CALL,\n    MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL,\n    MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n    MAX_NEW_L2_TO_L1_MSGS_PER_CALL,\n    NUM_FIELDS_PER_SHA256,\n    MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL,\n    MAX_PUBLIC_DATA_READS_PER_CALL,\n    GENERATOR_INDEX__FUNCTION_ARGS,\n    BLOCK_HEADER_LENGTH,\n    CONTRACT_DEPLOYMENT_DATA_LENGTH,\n    CALL_CONTEXT_LENGTH,\n    PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH,\n    PRIVATE_CIRCUIT_PUBLIC_INPUTS_HASH_INPUT_LENGTH,\n    CONTRACT_STORAGE_UPDATE_REQUEST_LENGTH,\n    CONTRACT_STORAGE_READ_LENGTH,\n    PUBLIC_CIRCUIT_PUBLIC_INPUTS_LENGTH,\n    PUBLIC_CIRCUIT_PUBLIC_INPUTS_HASH_INPUT_LENGTH,\n    GENERATOR_INDEX__BLOCK_HASH,\n    GENERATOR_INDEX__PUBLIC_CIRCUIT_PUBLIC_INPUTS,\n    GENERATOR_INDEX__FUNCTION_DATA,\n    GENERATOR_INDEX__PUBLIC_DATA_READ,\n    GENERATOR_INDEX__PUBLIC_DATA_UPDATE_REQUEST,\n    GENERATOR_INDEX__CALL_CONTEXT,\n    GENERATOR_INDEX__PRIVATE_CIRCUIT_PUBLIC_INPUTS,\n    GENERATOR_INDEX__CONTRACT_DEPLOYMENT_DATA,\n};\n\nuse crate::oracle::debug_log;\nuse crate::types::vec::BoundedVec;\nuse crate::types::point::Point;\nuse crate::hash::pedersen_hash;\n\n// docs:start:private-global-variables\nstruct PrivateGlobalVariables {\n    chain_id: Field,\n    version: Field,\n}\n// docs:end:private-global-variables\n\nimpl PrivateGlobalVariables {\n    fn serialize(self) -> [Field; 2] {\n        [self.chain_id, self.version]\n    }\n}\n\n// docs:start:public-global-variables\nstruct PublicGlobalVariables {\n    chain_id: Field,\n    version: Field,\n    block_number: Field,\n    timestamp: Field,\n}\n// docs:end:public-global-variables\n\nimpl PublicGlobalVariables {\n    fn serialize(self) -> [Field; 4] {\n        [self.chain_id, self.version, self.block_number, self.timestamp]\n    }\n}\n\n// docs:start:contract-deployment-data\nstruct ContractDeploymentData {\n    deployer_public_key: Point,\n    constructor_vk_hash : Field,\n    function_tree_root : Field,\n    contract_address_salt : Field,\n    portal_contract_address : Field,\n}\n// docs:end:contract-deployment-data\n\nimpl ContractDeploymentData {\n    fn serialize(self) -> [Field; CONTRACT_DEPLOYMENT_DATA_LENGTH] {\n        [\n            self.deployer_public_key.x,\n            self.deployer_public_key.y,\n            self.constructor_vk_hash,\n            self.function_tree_root,\n            self.contract_address_salt,\n            self.portal_contract_address,\n        ]\n    }\n\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__CONTRACT_DEPLOYMENT_DATA)\n    }\n}\n\n// PrivateContextInputs are expected to be provided to each private function\n// docs:start:private-context-inputs\nstruct PrivateContextInputs {\n    call_context : CallContext,\n    block_header: BlockHeader,\n    contract_deployment_data: ContractDeploymentData,\n    private_global_variables: PrivateGlobalVariables,\n}\n// docs:end:private-context-inputs\n\n// PublicContextInputs are expected to be provided to each public function\n// docs:start:public-context-inputs\nstruct PublicContextInputs {\n    call_context: CallContext,\n    block_header: BlockHeader,\n\n    public_global_variables: PublicGlobalVariables,\n}\n// docs:end:public-context-inputs\n\n// docs:start:call-context\nstruct CallContext {\n    msg_sender : Field,\n    storage_contract_address : Field,\n    portal_contract_address : Field,\n    function_selector: Field,\n\n    is_delegate_call : bool,\n    is_static_call : bool,\n    is_contract_deployment: bool,\n}\n// docs:end:call-context\n\nimpl CallContext {\n    fn serialize(self) -> [Field; CALL_CONTEXT_LENGTH] {\n        [\n            self.msg_sender,\n            self.storage_contract_address,\n            self.portal_contract_address,\n            self.function_selector,\n            self.is_delegate_call as Field,\n            self.is_static_call as Field,\n            self.is_contract_deployment as Field,\n        ]\n    }\n\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__CALL_CONTEXT)\n    }\n}\n\n// docs:start:block-header\nstruct BlockHeader {\n    note_hash_tree_root : Field,\n    nullifier_tree_root : Field,\n    contract_tree_root : Field,\n    l1_to_l2_messages_tree_root : Field,\n    archive_root: Field,\n    public_data_tree_root: Field,\n    global_variables_hash: Field,\n}\n// docs:end:block-header\n\nimpl BlockHeader {\n    // NOTE: this order must match the order in `private_circuit_public_inputs.hpp`\n    pub fn serialize(self) -> [Field; BLOCK_HEADER_LENGTH] {\n        [\n            self.note_hash_tree_root,\n            self.nullifier_tree_root,\n            self.contract_tree_root,\n            self.l1_to_l2_messages_tree_root,\n            self.archive_root,\n            self.public_data_tree_root,\n            self.global_variables_hash,\n        ]\n    }\n\n    pub fn deserialize(deserialized: [Field; BLOCK_HEADER_LENGTH]) -> Self {\n        BlockHeader {\n            note_hash_tree_root: deserialized[0],\n            nullifier_tree_root: deserialized[1],\n            contract_tree_root: deserialized[2],\n            l1_to_l2_messages_tree_root: deserialized[3],\n            archive_root: deserialized[4],\n            public_data_tree_root: deserialized[5],\n            global_variables_hash: deserialized[6],\n        }\n    }\n\n    pub fn empty() -> Self {\n        Self { note_hash_tree_root: 0, nullifier_tree_root: 0, contract_tree_root: 0, l1_to_l2_messages_tree_root: 0, archive_root: 0, public_data_tree_root: 0, global_variables_hash: 0 }\n    }\n\n    pub fn block_hash(self) -> Field {\n        // TODO(#3442): Unify the ordering in `BlockHeader::serialize` function and the ordering\n        // in the block hash preimage --> This requires changes in the circuits.\n        let inputs = [\n            self.global_variables_hash,\n            self.note_hash_tree_root,\n            self.nullifier_tree_root,\n            self.contract_tree_root,\n            self.l1_to_l2_messages_tree_root,\n            self.public_data_tree_root\n        ];\n        pedersen_hash(inputs, GENERATOR_INDEX__BLOCK_HASH)\n    }\n}\n\nstruct FunctionData {\n    function_selector: Field,\n    is_internal: bool,\n    is_private: bool,\n    is_constructor: bool,\n}\n\nimpl FunctionData {\n    fn hash(self) -> Field {\n        pedersen_hash([\n            self.function_selector,\n            self.is_internal as Field,\n            self.is_private as Field,\n            self.is_constructor as Field,\n        ], GENERATOR_INDEX__FUNCTION_DATA)\n    }\n}\n\nstruct PrivateCircuitPublicInputs {\n    call_context: CallContext,\n    args_hash: Field,\n    return_values: [Field; RETURN_VALUES_LENGTH],\n    read_requests: [Field; crate::abi::MAX_READ_REQUESTS_PER_CALL],\n    pending_read_requests: [Field; crate::abi::MAX_PENDING_READ_REQUESTS_PER_CALL],\n    new_commitments: [Field; MAX_NEW_COMMITMENTS_PER_CALL],\n    new_nullifiers: [Field; MAX_NEW_NULLIFIERS_PER_CALL],\n    nullified_commitments: [Field; MAX_NEW_NULLIFIERS_PER_CALL],\n    private_call_stack: [Field; MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL],\n    public_call_stack: [Field; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n    new_l2_to_l1_msgs: [Field; MAX_NEW_L2_TO_L1_MSGS_PER_CALL],\n    // Explore introducing a new type like uint256 (similar to Point), so it's more explicit that\n    // we're talking about a single number backed by two field elements.\n    encrypted_logs_hash: [Field; NUM_FIELDS_PER_SHA256],\n    unencrypted_logs_hash: [Field; NUM_FIELDS_PER_SHA256],\n    encrypted_log_preimages_length: Field,\n    unencrypted_log_preimages_length: Field,\n    block_header: BlockHeader,\n    contract_deployment_data: ContractDeploymentData,\n    chain_id: Field,\n    version: Field,\n}\n\nimpl PrivateCircuitPublicInputs {\n    fn hash(self) -> Field {\n        let mut fields: BoundedVec<Field, PRIVATE_CIRCUIT_PUBLIC_INPUTS_HASH_INPUT_LENGTH> = BoundedVec::new(0); \n        fields.push(self.call_context.hash());\n        fields.push(self.args_hash);\n        fields.push_array(self.return_values);\n        fields.push_array(self.read_requests);\n        fields.push_array(self.pending_read_requests);\n        fields.push_array(self.new_commitments);\n        fields.push_array(self.new_nullifiers);\n        fields.push_array(self.nullified_commitments);\n        fields.push_array(self.private_call_stack);\n        fields.push_array(self.public_call_stack);\n        fields.push_array(self.new_l2_to_l1_msgs);\n        fields.push_array(self.encrypted_logs_hash);\n        fields.push_array(self.unencrypted_logs_hash);\n        fields.push(self.encrypted_log_preimages_length);\n        fields.push(self.unencrypted_log_preimages_length);\n        fields.push_array(self.block_header.serialize());\n        fields.push(self.contract_deployment_data.hash());\n        fields.push(self.chain_id);\n        fields.push(self.version);\n\n        pedersen_hash(fields.storage, GENERATOR_INDEX__PRIVATE_CIRCUIT_PUBLIC_INPUTS)\n    }\n\n    fn serialize(self) -> [Field; PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH] {\n        let mut fields: BoundedVec<Field, PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH> = BoundedVec::new(0); \n        fields.push_array(self.call_context.serialize());\n        fields.push(self.args_hash);\n        fields.push_array(self.return_values);\n        fields.push_array(self.read_requests);\n        fields.push_array(self.pending_read_requests);\n        fields.push_array(self.new_commitments);\n        fields.push_array(self.new_nullifiers);\n        fields.push_array(self.private_call_stack);\n        fields.push_array(self.public_call_stack);\n        fields.push_array(self.new_l2_to_l1_msgs);\n        fields.push_array(self.encrypted_logs_hash);\n        fields.push_array(self.unencrypted_logs_hash);\n        fields.push(self.encrypted_log_preimages_length);\n        fields.push(self.unencrypted_log_preimages_length);\n        fields.push_array(self.block_header.serialize());\n        fields.push_array(self.contract_deployment_data.serialize());\n        fields.push(self.chain_id);\n        fields.push(self.version);\n        fields.storage\n    }\n}\n\nstruct ContractStorageRead {\n    storage_slot: Field,\n    value: Field,\n}\n\nimpl ContractStorageRead {\n    pub fn serialize(self) -> [Field; CONTRACT_STORAGE_READ_LENGTH] {\n        [self.storage_slot, self.value]\n    }\n\n    pub fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__PUBLIC_DATA_READ)\n    }\n\n    pub fn empty() -> Self {\n        Self { storage_slot: 0, value: 0 }\n    }\n}\n\nstruct ContractStorageUpdateRequest {\n    storage_slot: Field,\n    old_value: Field,\n    new_value: Field,\n}\n\nimpl ContractStorageUpdateRequest {\n    pub fn serialize(self) -> [Field; CONTRACT_STORAGE_UPDATE_REQUEST_LENGTH] {\n        [self.storage_slot, self.old_value, self.new_value]\n    }\n\n    pub fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__PUBLIC_DATA_UPDATE_REQUEST)\n    }\n\n    pub fn empty() -> Self {\n        Self { storage_slot: 0, old_value: 0, new_value: 0 }\n    }\n}\n\nstruct PublicCircuitPublicInputs {\n    call_context: CallContext,\n    args_hash: Field,\n    return_values: [Field; RETURN_VALUES_LENGTH],\n    contract_storage_update_requests: [ContractStorageUpdateRequest; MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL],\n    contract_storage_read: [ContractStorageRead; MAX_PUBLIC_DATA_READS_PER_CALL],\n    public_call_stack: [Field; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n    new_commitments: [Field; MAX_NEW_COMMITMENTS_PER_CALL],\n    new_nullifiers: [Field; crate::abi::MAX_NEW_NULLIFIERS_PER_CALL],\n    new_l2_to_l1_msgs: [Field; crate::abi::MAX_NEW_L2_TO_L1_MSGS_PER_CALL],\n    unencrypted_logs_hash: [Field; NUM_FIELDS_PER_SHA256],\n    unencrypted_log_preimages_length: Field,\n    block_header: BlockHeader,\n    prover_address: Field,\n}\n\nimpl PublicCircuitPublicInputs {\n    \n    pub fn hash(self) -> Field {\n        let mut inputs: BoundedVec<Field, PUBLIC_CIRCUIT_PUBLIC_INPUTS_HASH_INPUT_LENGTH> = BoundedVec::new(0);\n        inputs.push(self.call_context.hash());\n        inputs.push(self.args_hash);\n        inputs.push_array(self.return_values);\n        for i in 0..MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL {\n            inputs.push(self.contract_storage_update_requests[i].hash());\n        }\n        for i in 0..MAX_PUBLIC_DATA_READS_PER_CALL {\n            inputs.push(self.contract_storage_read[i].hash());\n        }\n        inputs.push_array(self.public_call_stack);\n        inputs.push_array(self.new_commitments);\n        inputs.push_array(self.new_nullifiers);\n        inputs.push_array(self.new_l2_to_l1_msgs);\n\n        inputs.push_array(self.unencrypted_logs_hash);\n        inputs.push(self.unencrypted_log_preimages_length);\n        inputs.push_array(self.block_header.serialize());\n        inputs.push(self.prover_address);\n\n        pedersen_hash(inputs.storage, GENERATOR_INDEX__PUBLIC_CIRCUIT_PUBLIC_INPUTS)\n    }\n\n    pub fn serialize(self) -> [Field; PUBLIC_CIRCUIT_PUBLIC_INPUTS_LENGTH] {\n        let mut fields: BoundedVec<Field, PUBLIC_CIRCUIT_PUBLIC_INPUTS_LENGTH> = BoundedVec::new(0); \n        fields.push_array(self.call_context.serialize());   \n        fields.push(self.args_hash);\n        fields.push_array(self.return_values);\n        for i in 0..MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL {\n            fields.push_array(self.contract_storage_update_requests[i].serialize());\n        }\n        for i in 0..MAX_PUBLIC_DATA_READS_PER_CALL {\n            fields.push_array(self.contract_storage_read[i].serialize());\n        }\n        fields.push_array(self.public_call_stack);\n        fields.push_array(self.new_commitments);\n        fields.push_array(self.new_nullifiers);\n        fields.push_array(self.new_l2_to_l1_msgs);\n        fields.push_array(self.unencrypted_logs_hash);\n        fields.push(self.unencrypted_log_preimages_length);\n        fields.push_array(self.block_header.serialize());\n        fields.push(self.prover_address);\n        fields.storage\n    }\n}\n\nstruct Hasher {\n    fields: [Field],\n}\n\nimpl Hasher {\n    pub fn new()-> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<N>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n\n    pub fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nglobal ARGS_HASH_CHUNK_LENGTH: u32 = 32;\nglobal ARGS_HASH_CHUNK_COUNT: u32 = 16;\n\npub fn hash_args<N>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        let mut chunks_hashes = [0; ARGS_HASH_CHUNK_COUNT];\n        for i in 0..ARGS_HASH_CHUNK_COUNT {\n            let mut chunk_hash = 0;\n            let start_chunk_index = i * ARGS_HASH_CHUNK_LENGTH;\n            if start_chunk_index < (args.len() as u32) {\n                let mut chunk_args = [0; ARGS_HASH_CHUNK_LENGTH];\n                for j in 0..ARGS_HASH_CHUNK_LENGTH {\n                    let item_index = i * ARGS_HASH_CHUNK_LENGTH + j;\n                    if item_index < (args.len() as u32) {\n                        chunk_args[j] = args[item_index];\n                    }\n                }\n                chunk_hash = pedersen_hash(chunk_args, GENERATOR_INDEX__FUNCTION_ARGS);\n            }\n            chunks_hashes[i] = chunk_hash;\n        }\n        pedersen_hash(chunks_hashes, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n",
                "path": "/aztec/abi.nr"
            },
            "95": {
                "source": "use dep::protocol_types::constants::GENERATOR_INDEX__CONTRACT_ADDRESS;\nuse crate::hash::pedersen_hash;\n\npub fn compute_address(pub_key_x: Field, pub_key_y: Field, partial_address: Field) -> Field {\n    pedersen_hash([pub_key_x, pub_key_y, partial_address],\n        GENERATOR_INDEX__CONTRACT_ADDRESS)\n}\n",
                "path": "/aztec/address.nr"
            },
            "96": {
                "source": "use dep::protocol_types::constants::{\n    EMPTY_NULLIFIED_COMMITMENT,\n    MAX_NEW_COMMITMENTS_PER_CALL,\n    MAX_NEW_L2_TO_L1_MSGS_PER_CALL,\n    MAX_NEW_NULLIFIERS_PER_CALL,\n    MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL,\n    MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n    MAX_PUBLIC_DATA_READS_PER_CALL,\n    MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL,\n    MAX_READ_REQUESTS_PER_CALL,\n    MAX_PENDING_READ_REQUESTS_PER_CALL,\n    NUM_FIELDS_PER_SHA256,\n    RETURN_VALUES_LENGTH,\n};\n\nuse crate::abi;\n\nuse crate::abi::{\n    hash_args,\n    CallContext,\n    ContractDeploymentData,\n    BlockHeader,\n    FunctionData,\n    PrivateCircuitPublicInputs,\n    PublicCircuitPublicInputs,\n};\n\n// TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n// use dep::std::collections::vec::Vec;\n\n// l1 to l2 messaging\nuse crate::messaging::process_l1_to_l2_message;\nuse crate::private_call_stack_item::PrivateCallStackItem;\nuse crate::public_call_stack_item::PublicCallStackItem;\n\nuse crate::types::{\n    vec::BoundedVec,\n    point::Point,\n};\n\nuse crate::utils::arr_copy_slice;\n\nuse crate::oracle::{\n    arguments,\n    call_private_function::call_private_function_internal,\n    public_call::call_public_function_internal,\n    enqueue_public_function_call::enqueue_public_function_call_internal,\n    context::get_portal_address,\n    get_block_header::get_block_header,\n};\n\nuse dep::std::option::Option;\n\n// When finished, one can call .finish() to convert back to the abi\nstruct PrivateContext {\n    // docs:start:private-context\n    inputs: abi::PrivateContextInputs,\n\n    args_hash : Field,\n    return_values : BoundedVec<Field, RETURN_VALUES_LENGTH>,\n\n    read_requests: BoundedVec<Field, MAX_READ_REQUESTS_PER_CALL>,\n    pending_read_requests: BoundedVec<Field, MAX_PENDING_READ_REQUESTS_PER_CALL>,\n\n    new_commitments: BoundedVec<Field, MAX_NEW_COMMITMENTS_PER_CALL>,\n    new_nullifiers: BoundedVec<Field, MAX_NEW_NULLIFIERS_PER_CALL>,\n    nullified_commitments: BoundedVec<Field, MAX_NEW_NULLIFIERS_PER_CALL>,\n\n    private_call_stack : BoundedVec<Field, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    public_call_stack : BoundedVec<Field, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\n    new_l2_to_l1_msgs : BoundedVec<Field, MAX_NEW_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    block_header: BlockHeader,\n\n    // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    // encrypted_logs_preimages: Vec<Field>,\n    // unencrypted_logs_preimages: Vec<Field>,\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: abi::PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs: inputs,\n\n            args_hash: args_hash,\n            return_values: BoundedVec::new(0),\n\n            read_requests: BoundedVec::new(0),\n            pending_read_requests: BoundedVec::new(0),\n\n            new_commitments: BoundedVec::new(0),\n            new_nullifiers: BoundedVec::new(0),\n            nullified_commitments: BoundedVec::new(0),\n\n            block_header: inputs.block_header,\n\n            private_call_stack: BoundedVec::new(0),\n            public_call_stack: BoundedVec::new(0),\n            new_l2_to_l1_msgs: BoundedVec::new(0),\n\n            // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n            // encrypted_logs_preimages: Vec::new(),\n            // unencrypted_logs_preimages: Vec::new(),\n        }\n    }\n\n    pub fn msg_sender(self) -> Field {\n        self.inputs.call_context.msg_sender\n    }\n\n    pub fn this_address(self) -> Field {\n        self.inputs.call_context.storage_contract_address\n    }\n\n    pub fn this_portal_address(self) -> Field {\n        self.inputs.call_context.portal_contract_address\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.inputs.private_global_variables.chain_id\n    }\n\n    pub fn version(self) -> Field {\n        self.inputs.private_global_variables.version\n    }\n\n    pub fn selector(self) -> Field {\n        self.inputs.call_context.function_selector\n    }\n\n    pub fn get_block_header(self, block_number: u32) -> BlockHeader {\n        get_block_header(block_number, self)\n    }\n\n    pub fn finish(self) -> abi::PrivateCircuitPublicInputs {\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n        let encrypted_logs_hash = [0; NUM_FIELDS_PER_SHA256];\n        let unencrypted_logs_hash = [0; NUM_FIELDS_PER_SHA256];\n        let encrypted_log_preimages_length = 0;\n        let unencrypted_log_preimages_length = 0;\n\n        let priv_circuit_pub_inputs = abi::PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            return_values: self.return_values.storage,\n            read_requests: self.read_requests.storage,\n            pending_read_requests: self.pending_read_requests.storage,\n            new_commitments: self.new_commitments.storage,\n            new_nullifiers: self.new_nullifiers.storage,\n            nullified_commitments: self.nullified_commitments.storage,\n            private_call_stack: self.private_call_stack.storage,\n            public_call_stack: self.public_call_stack.storage,\n            new_l2_to_l1_msgs: self.new_l2_to_l1_msgs.storage,\n            encrypted_logs_hash: encrypted_logs_hash,\n            unencrypted_logs_hash: unencrypted_logs_hash,\n            encrypted_log_preimages_length: encrypted_log_preimages_length,\n            unencrypted_log_preimages_length: unencrypted_log_preimages_length,\n            block_header: self.block_header,\n            contract_deployment_data: self.inputs.contract_deployment_data,\n            chain_id: self.inputs.private_global_variables.chain_id,\n            version: self.inputs.private_global_variables.version,\n        };\n        priv_circuit_pub_inputs\n    }\n\n    pub fn push_read_request(&mut self, read_request: Field) {\n        self.read_requests.push(read_request);\n    }\n\n    pub fn push_pending_read_request(&mut self, pending_read_request: Field) {\n        self.pending_read_requests.push(pending_read_request);\n    }\n\n    pub fn push_new_note_hash(&mut self, note_hash: Field) {\n        self.new_commitments.push(note_hash);\n    }\n\n    // We never push a zero nullified_commitment as zero is used to indicate the end\n    // of a field array in private kernel. This routine transparently replaces a\n    // zero value into the special placeholder: EMPTY_NULLIFIED_COMMITMENT.\n    pub fn push_new_nullifier(&mut self, nullifier: Field, nullified_commitment: Field) {\n        self.new_nullifiers.push(nullifier);\n        let mut non_zero_nullified = nullified_commitment;\n        if (non_zero_nullified == 0) {\n            non_zero_nullified = EMPTY_NULLIFIED_COMMITMENT;\n        }\n        self.nullified_commitments.push(non_zero_nullified);\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, content: Field) \n    // docs:end:context_message_portal\n    {\n        self.new_l2_to_l1_msgs.push(content);\n    }\n\n    // PrivateContextInputs must be temporarily passed in to prevent too many unknowns\n    // Note this returns self to get around an issue where mutable structs do not maintain mutations unless reassigned\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        msg_key: Field,\n        content: Field,\n        secret: Field\n    ) \n    // docs:end:context_consume_l1_to_l2_message\n    {\n        let nullifier = process_l1_to_l2_message(self.block_header.l1_to_l2_messages_tree_root, self.this_address(), self.this_portal_address(), self.chain_id(), self.version(), msg_key, content, secret);\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_new_nullifier(nullifier, EMPTY_NULLIFIED_COMMITMENT)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    pub fn accumulate_encrypted_logs<N>(&mut self, log: [Field; N]) {\n        let _void1 = self.inputs;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    pub fn accumulate_unencrypted_logs<T>(&mut self, log: T) {\n        let _void1 = self.inputs;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    pub fn call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: Field, \n        function_selector: Field, \n        args: [Field; ARGS_COUNT]\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash)\n    }\n\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: Field, \n        function_selector: Field, \n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0)\n    }\n\n    pub fn call_private_function_with_packed_args(\n        &mut self,\n        contract_address: Field,\n        function_selector: Field,\n        args_hash: Field\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let fields = call_private_function_internal(\n            contract_address, \n            function_selector, \n            args_hash\n        );\n        let item = PrivateCallStackItem {\n            contract_address: fields[0],\n            function_data: FunctionData {\n                function_selector: fields[1],\n                is_internal: fields[2] as bool,\n                is_private: fields[3] as bool,\n                is_constructor: fields[4] as bool,\n            },\n            public_inputs: PrivateCircuitPublicInputs {\n                call_context: CallContext {\n                    msg_sender : fields[5],\n                    storage_contract_address : fields[6],\n                    portal_contract_address : fields[7],\n                    function_selector: fields[8], // practically same as fields[1]\n                    is_delegate_call : fields[9] as bool,\n                    is_static_call : fields[10] as bool,\n                    is_contract_deployment: fields[11] as bool,\n                },\n                // TODO handle the offsets as a variable incremented during extraction?\n                args_hash: fields[12],\n                return_values: arr_copy_slice(fields, [0; RETURN_VALUES_LENGTH], 13),\n                read_requests: arr_copy_slice(fields, [0; MAX_READ_REQUESTS_PER_CALL], 17),\n                pending_read_requests: arr_copy_slice(fields, [0; MAX_READ_REQUESTS_PER_CALL], 49),\n                new_commitments: arr_copy_slice(fields, [0; MAX_NEW_COMMITMENTS_PER_CALL], 81),\n                new_nullifiers: arr_copy_slice(fields, [0; MAX_NEW_NULLIFIERS_PER_CALL], 97),\n                nullified_commitments: arr_copy_slice(fields, [0; MAX_NEW_NULLIFIERS_PER_CALL], 113),\n                private_call_stack: arr_copy_slice(fields, [0; MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL], 129),\n                public_call_stack: arr_copy_slice(fields, [0; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL], 133),\n                new_l2_to_l1_msgs: arr_copy_slice(fields, [0; MAX_NEW_L2_TO_L1_MSGS_PER_CALL], 137),\n                encrypted_logs_hash: arr_copy_slice(fields, [0; NUM_FIELDS_PER_SHA256], 139),\n                unencrypted_logs_hash: arr_copy_slice(fields, [0; NUM_FIELDS_PER_SHA256], 141),\n                encrypted_log_preimages_length: fields[143],\n                unencrypted_log_preimages_length: fields[144],\n                block_header: BlockHeader {\n                    // Must match order in `private_circuit_public_inputs.hpp`\n                    note_hash_tree_root : fields[145],\n                    nullifier_tree_root : fields[146],\n                    contract_tree_root : fields[147],\n                    l1_to_l2_messages_tree_root : fields[148],\n                    archive_root : fields[149],\n                    public_data_tree_root: fields[150],\n                    global_variables_hash: fields[151],\n                },\n                contract_deployment_data: ContractDeploymentData {\n                    deployer_public_key: Point::new(fields[152], fields[153]),\n                    constructor_vk_hash : fields[154],\n                    function_tree_root : fields[155],\n                    contract_address_salt : fields[156],\n                    portal_contract_address : fields[157],\n                },\n                chain_id: fields[158],\n                version: fields[159],\n            },\n            is_execution_request: fields[160] as bool,\n        };\n        assert(contract_address == item.contract_address);\n        assert(function_selector == item.function_data.function_selector);\n\n        assert(args_hash == item.public_inputs.args_hash);\n\n        assert(item.is_execution_request == false);\n\n        // Assert that the call context of the enqueued call generated by the oracle matches our request.\n        // We are issuing a regular call which is not delegate, static, or deployment. We also constrain\n        // the msg_sender in the nested call to be equal to our address, and the execution context address\n        // for the nested call to be equal to the address we actually called.\n        assert(item.public_inputs.call_context.is_delegate_call == false);\n        assert(item.public_inputs.call_context.is_static_call == false);\n        assert(item.public_inputs.call_context.is_contract_deployment == false);\n        assert(item.public_inputs.call_context.msg_sender == self.inputs.call_context.storage_contract_address);\n        assert(item.public_inputs.call_context.storage_contract_address == contract_address);\n\n        self.private_call_stack.push(item.hash());\n\n        item.public_inputs.return_values\n    }\n\n    pub fn call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: Field, \n        function_selector: Field, \n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash)\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: Field, \n        function_selector: Field,\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0)\n    }\n\n    pub fn call_public_function_with_packed_args(\n        &mut self,\n        contract_address: Field,\n        function_selector: Field,\n        args_hash: Field\n    ) {\n        let fields = enqueue_public_function_call_internal(\n            contract_address, \n            function_selector, \n            args_hash\n        );\n        let item = PublicCallStackItem {\n            contract_address: fields[0],\n            function_data: FunctionData {\n                function_selector: fields[1],\n                is_internal: fields[2] as bool,\n                is_private: fields[3] as bool,\n                is_constructor: fields[4] as bool,\n            },\n            public_inputs: PublicCircuitPublicInputs {\n                call_context: CallContext {\n                    msg_sender : fields[5],\n                    storage_contract_address : fields[6],\n                    portal_contract_address : fields[7],\n                    function_selector: fields[8], // practically same as fields[1]\n                    is_delegate_call : fields[9] as bool,\n                    is_static_call : fields[10] as bool,\n                    is_contract_deployment: fields[11] as bool,\n                },\n                args_hash: fields[12],\n                return_values: [0; RETURN_VALUES_LENGTH],\n                contract_storage_update_requests: [ContractStorageUpdateRequest::empty(); MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL],\n                contract_storage_read: [ContractStorageRead::empty(); MAX_PUBLIC_DATA_READS_PER_CALL],\n                public_call_stack: [0; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n                new_commitments: [0; MAX_NEW_COMMITMENTS_PER_CALL],\n                new_nullifiers: [0; MAX_NEW_NULLIFIERS_PER_CALL],\n                new_l2_to_l1_msgs:[0; MAX_NEW_L2_TO_L1_MSGS_PER_CALL],\n                unencrypted_logs_hash:[0; NUM_FIELDS_PER_SHA256],\n                unencrypted_log_preimages_length: 0,\n                block_header: BlockHeader::empty(),\n                prover_address: 0,\n            },\n            is_execution_request: true,\n        };\n\n        assert(contract_address == item.contract_address);\n        assert(function_selector == item.function_data.function_selector);\n        \n        assert(args_hash == item.public_inputs.args_hash);\n\n        // Assert that the call context of the enqueued call generated by the oracle matches our request.\n        // We are issuing a regular call which is not delegate, static, or deployment. We also constrain\n        // the msg_sender in the nested call to be equal to our address, and the execution context address\n        // for the nested call to be equal to the address we actually called.\n        assert(item.public_inputs.call_context.is_delegate_call == false);\n        assert(item.public_inputs.call_context.is_static_call == false);\n        assert(item.public_inputs.call_context.is_contract_deployment == false);\n        assert(item.public_inputs.call_context.msg_sender == self.inputs.call_context.storage_contract_address);\n        assert(item.public_inputs.call_context.storage_contract_address == contract_address);\n\n        self.public_call_stack.push(item.hash());\n    }\n}\n\nuse crate::abi::{\n    ContractStorageRead,\n    ContractStorageUpdateRequest\n};\n\nstruct PublicContext {\n    inputs: abi::PublicContextInputs,\n\n    args_hash : Field,\n    return_values : BoundedVec<Field, RETURN_VALUES_LENGTH>,\n\n    contract_storage_update_requests: BoundedVec<ContractStorageUpdateRequest, MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL>,\n    contract_storage_read: BoundedVec<ContractStorageRead, MAX_PUBLIC_DATA_READS_PER_CALL>,\n    public_call_stack: BoundedVec<Field, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\n\n    new_commitments: BoundedVec<Field, MAX_NEW_COMMITMENTS_PER_CALL>,\n    new_nullifiers: BoundedVec<Field, crate::abi::MAX_NEW_NULLIFIERS_PER_CALL>,\n\n    new_l2_to_l1_msgs: BoundedVec<Field, crate::abi::MAX_NEW_L2_TO_L1_MSGS_PER_CALL>,\n\n    unencrypted_logs_hash: BoundedVec<Field, NUM_FIELDS_PER_SHA256>,\n    unencrypted_logs_preimages_length: Field,\n\n    block_header: BlockHeader,\n    prover_address: Field,\n}\n\nimpl PublicContext {\n    pub fn new(inputs: abi::PublicContextInputs, args_hash: Field) -> PublicContext {\n        let empty_storage_read = ContractStorageRead::empty();\n        let empty_storage_update = ContractStorageUpdateRequest::empty();\n        PublicContext {\n            inputs: inputs,\n\n            args_hash: args_hash,\n            return_values: BoundedVec::new(0),\n\n            contract_storage_update_requests: BoundedVec::new(empty_storage_update),\n            contract_storage_read: BoundedVec::new(empty_storage_read),\n            public_call_stack: BoundedVec::new(0),\n\n            new_commitments: BoundedVec::new(0),\n            new_nullifiers: BoundedVec::new(0),\n\n            new_l2_to_l1_msgs: BoundedVec::new(0),\n\n            \n            unencrypted_logs_hash: BoundedVec::new(0),\n            unencrypted_logs_preimages_length: 0,\n\n            block_header: inputs.block_header,\n            prover_address: 0,\n\n            // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n            // encrypted_logs_preimages: Vec::new(),\n            // unencrypted_logs_preimages: Vec::new(),\n        }\n    }\n\n    pub fn msg_sender(self) -> Field {\n        self.inputs.call_context.msg_sender\n    }\n\n    pub fn this_address(self) -> Field {\n        self.inputs.call_context.storage_contract_address\n    }\n\n    pub fn this_portal_address(self) -> Field {\n        self.inputs.call_context.portal_contract_address\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.inputs.public_global_variables.chain_id\n    }\n\n    pub fn version(self) -> Field {\n        self.inputs.public_global_variables.version\n    }\n\n    pub fn selector(self) -> Field {\n        self.inputs.call_context.function_selector\n    }\n\n    pub fn block_number(self) -> Field {\n        self.inputs.public_global_variables.block_number\n    }\n\n    pub fn timestamp(self) -> Field {\n        self.inputs.public_global_variables.timestamp\n    }\n\n    pub fn finish(self) -> abi::PublicCircuitPublicInputs {\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n        let unencrypted_logs_hash = [0; NUM_FIELDS_PER_SHA256];\n        let unencrypted_log_preimages_length = 0;\n\n\n        // Compute the public call stack hashes\n        let pub_circuit_pub_inputs = abi::PublicCircuitPublicInputs {\n            call_context: self.inputs.call_context, // Done\n            args_hash: self.args_hash, // Done\n            contract_storage_update_requests: self.contract_storage_update_requests.storage,\n            contract_storage_read: self.contract_storage_read.storage,\n            return_values: self.return_values.storage,\n            new_commitments: self.new_commitments.storage,\n            new_nullifiers: self.new_nullifiers.storage,\n            public_call_stack: self.public_call_stack.storage,\n            new_l2_to_l1_msgs: self.new_l2_to_l1_msgs.storage,\n            unencrypted_logs_hash: unencrypted_logs_hash,\n            unencrypted_log_preimages_length: unencrypted_log_preimages_length,\n            block_header: self.inputs.block_header,\n            prover_address: self.prover_address,\n        };\n        pub_circuit_pub_inputs\n    }\n\n    pub fn push_new_note_hash(&mut self, note_hash: Field) {\n        self.new_commitments.push(note_hash);\n    }\n\n    pub fn push_new_nullifier(&mut self, nullifier: Field, _nullified_commitment: Field) {\n        self.new_nullifiers.push(nullifier);\n    }\n\n    pub fn message_portal(&mut self, content: Field) {\n        self.new_l2_to_l1_msgs.push(content);\n    }\n\n    // PrivateContextInputs must be temporarily passed in to prevent too many unknowns\n    // Note this returns self to get around an issue where mutable structs do not maintain mutations unless reassigned\n    pub fn consume_l1_to_l2_message(&mut self, msg_key: Field, content: Field, secret: Field) {\n        let this = (*self).this_address();\n        let nullifier = process_l1_to_l2_message(self.block_header.l1_to_l2_messages_tree_root, this, self.this_portal_address(), self.chain_id(), self.version(), msg_key, content, secret);\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_new_nullifier(nullifier, EMPTY_NULLIFIED_COMMITMENT)\n    }\n\n    pub fn accumulate_encrypted_logs<N>(&mut self, log: [Field; N]) {\n        let _void1 = self;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    pub fn accumulate_unencrypted_logs<T>(&mut self, log: T) {\n        let _void1 = self;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    pub fn call_public_function<ARGS_COUNT>(\n        _self: Self,\n        contract_address: Field, \n        function_selector: Field,\n        args: [Field; ARGS_COUNT],\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let args_hash = abi::hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        call_public_function_internal(\n            contract_address, \n            function_selector, \n            args_hash,\n        )\n    }\n\n    pub fn call_public_function_no_args(\n        _self: Self,\n        contract_address: Field, \n        function_selector: Field,\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        call_public_function_internal(\n            contract_address, \n            function_selector, \n            0,\n        )\n    }\n\n}\n\nstruct Context {\n    private: Option<&mut PrivateContext>,\n    public: Option<&mut PublicContext>,\n}\n\nimpl Context {\n    pub fn private(context: &mut PrivateContext) -> Context {\n        Context {\n            private: Option::some(context),\n            public: Option::none()\n        }\n    }\n\n    pub fn public(context: &mut PublicContext) -> Context {\n        Context {\n            public: Option::some(context),\n            private: Option::none()\n        }\n    }\n\n    pub fn none() -> Context {\n        Context {\n            public: Option::none(),\n            private: Option::none()\n        }\n    }\n}\n",
                "path": "/aztec/context.nr"
            },
            "97": {
                "source": "use dep::std::hash::{pedersen_hash_with_separator, sha256};\nuse dep::protocol_types::constants::{\n  GENERATOR_INDEX__SIGNATURE_PAYLOAD,\n  GENERATOR_INDEX__L1_TO_L2_MESSAGE_SECRET,\n};\n\npub fn sha256_to_field<N>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256(bytes_to_hash);\n\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (sha256_hashed[15 - i] as Field) * v;\n        low = low + (sha256_hashed[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    let hash_in_a_field = low + high * v;\n\n    hash_in_a_field\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    // TODO(#1205) This is probably not the right index to use\n    pedersen_hash([secret], GENERATOR_INDEX__L1_TO_L2_MESSAGE_SECRET)\n}\n\npub fn pedersen_hash<N>(inputs: [Field; N], hash_index: u32) -> Field {\n    pedersen_hash_with_separator(inputs, hash_index)\n}\n",
                "path": "/aztec/hash.nr"
            },
            "104": {
                "source": "use crate::context::{PrivateContext, PublicContext};\nuse crate::oracle;\nuse crate::types::point::Point;\n\npub fn emit_encrypted_log<N>(\n    context: &mut PrivateContext,\n    contract_address: Field,\n    storage_slot: Field,\n    encryption_pub_key: Point,\n    log: [Field; N]\n) {\n    let _ = oracle::logs::emit_encrypted_log(contract_address, storage_slot, encryption_pub_key, log);\n    context.accumulate_encrypted_logs(log);\n}\n\npub fn emit_unencrypted_log<T>(context: &mut PublicContext, log: T) {\n    let contract_address = context.this_address();\n    let event_selector = 5; // TODO: compute actual event selector.\n    let _ = oracle::logs::emit_unencrypted_log(contract_address, event_selector, log);\n    // context.accumulate_unencrypted_logs(log);\n}\n\n// TODO: We might want to remove this since emitting unencrypted logs from private functions is violating privacy.\n// --> might be a better approach to force devs to make a public function call that emits the log if needed then\n// it would be less easy to accidentally leak information.\n// If we decide to keep this function around would make sense to wait for traits and then merge it with emit_unencrypted_log.\npub fn emit_unencrypted_log_from_private<T>(context: &mut PrivateContext, log: T) {\n    let contract_address = context.this_address();\n    let event_selector = 5; // TODO: compute actual event selector.\n    let _ = oracle::logs::emit_unencrypted_log(contract_address, event_selector, log);\n    // context.accumulate_unencrypted_logs(log);\n}\n",
                "path": "/aztec/log.nr"
            },
            "109": {
                "source": "use crate::abi::PublicContextInputs;\nuse crate::context::{\n    PrivateContext,\n    PublicContext,\n};\nuse crate::note::{\n    note_header::NoteHeader,\n    note_interface::NoteInterface,\n    utils::compute_inner_note_hash,\n};\nuse crate::oracle::notes::{notify_created_note, notify_nullified_note};\nuse dep::protocol_types::constants::EMPTY_NULLIFIED_COMMITMENT;\n\npub fn create_note<Note, N>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    note: &mut Note,\n    note_interface: NoteInterface<Note, N>,\n    broadcast: bool\n) {\n    let contract_address = (*context).this_address();\n\n    let header = NoteHeader { contract_address, storage_slot, nonce: 0, is_transient: true };\n    let set_header = note_interface.set_header;\n    set_header(note, header);\n    let inner_note_hash = compute_inner_note_hash(note_interface, *note);\n\n    let serialize = note_interface.serialize;\n    let serialized_note = serialize(*note);\n    assert(notify_created_note(storage_slot, serialized_note, inner_note_hash) == 0);\n\n    context.push_new_note_hash(inner_note_hash);\n\n    if broadcast {\n        let broadcast = note_interface.broadcast;\n        broadcast(context, storage_slot, *note);\n    }\n}\n\npub fn create_note_hash_from_public<Note, N>(\n    context: &mut PublicContext,\n    storage_slot: Field,\n    note: &mut Note,\n    note_interface: NoteInterface<Note, N>\n) {\n    let contract_address = (*context).this_address();\n\n    let header = NoteHeader { contract_address, storage_slot, nonce: 0, is_transient: true };\n    let set_header = note_interface.set_header;\n    set_header(note, header);\n    let inner_note_hash = compute_inner_note_hash(note_interface, *note);\n\n    context.push_new_note_hash(inner_note_hash);\n}\n\npub fn destroy_note<Note, N>(context: &mut PrivateContext, note: Note, note_interface: NoteInterface<Note, N>) {\n    let mut nullifier = 0;\n    let mut nullified_commitment: Field = EMPTY_NULLIFIED_COMMITMENT;\n    let compute_nullifier = note_interface.compute_nullifier;\n    nullifier = compute_nullifier(note);\n\n    // We also need the note commitment corresponding to the \"nullifier\"\n    let get_header = note_interface.get_header;\n    let header = get_header(note);\n    // `nullified_commitment` is used to inform the kernel which pending commitment\n    // the nullifier corresponds to so they can be matched and both squashed/deleted.\n    // nonzero nonce implies \"persistable\" nullifier (nullifies a persistent/in-tree\n    // commitment) in which case `nullified_commitment` is not used since the kernel\n    // just siloes and forwards the nullifier to its output.\n    if (header.is_transient) {\n        // TODO(1718): Can we reuse the note commitment computed in `compute_nullifier`?\n        nullified_commitment = compute_inner_note_hash(note_interface, note);\n    }\n    assert(notify_nullified_note(nullifier, nullified_commitment) == 0);\n\n    context.push_new_nullifier(nullifier, nullified_commitment)\n}\n",
                "path": "/aztec/note/lifecycle.nr"
            },
            "110": {
                "source": "use dep::std::option::Option;\nuse dep::protocol_types::constants::{\n    MAX_READ_REQUESTS_PER_CALL,\n    GET_NOTE_ORACLE_RETURN_LENGTH,\n    GET_NOTES_ORACLE_RETURN_LENGTH,\n    MAX_NOTES_PER_PAGE,\n    VIEW_NOTE_ORACLE_RETURN_LENGTH,\n};\nuse crate::context::PrivateContext;\nuse crate::note::{\n    note_getter_options::{NoteGetterOptions, Select, Sort, SortOrder},\n    note_interface::NoteInterface,\n    note_viewer_options::NoteViewerOptions,\n    utils::compute_note_hash_for_read_or_nullify,\n};\nuse crate::oracle;\nuse crate::types::vec::BoundedVec;\n\nfn check_note_header<Note, N>(context: PrivateContext, storage_slot: Field, note_interface: NoteInterface<Note, N>, note: Note) {\n    let get_header = note_interface.get_header;\n    let header = get_header(note);\n    let contract_address = context.this_address();\n    assert(header.contract_address == contract_address);\n    assert(header.storage_slot == storage_slot);\n}\n\nfn check_note_fields<N>(fields: [Field; N], selects: BoundedVec<Option<Select>, N>) {\n    for i in 0..selects.len {\n        let select = selects.get_unchecked(i).unwrap_unchecked();\n        assert(fields[select.field_index] == select.value, \"Mismatch return note field.\");\n    }\n}\n\nfn check_notes_order<N>(fields_0: [Field; N], fields_1: [Field; N], sorts: BoundedVec<Option<Sort>, N>) {\n    for i in 0..sorts.len {\n        let sort = sorts.get_unchecked(i).unwrap_unchecked();\n        let eq = fields_0[sort.field_index] == fields_1[sort.field_index];\n        let lt = fields_0[sort.field_index] as u120 < fields_1[sort.field_index] as u120;\n        if sort.order == SortOrder.ASC {\n            assert(eq | lt, \"Return notes not sorted in ascending order.\");\n        } else if !eq {\n            assert(!lt, \"Return notes not sorted in descending order.\");\n        }\n    }\n}\n\npub fn get_note<Note, N>(context: &mut PrivateContext, storage_slot: Field, note_interface: NoteInterface<Note, N>) -> Note {\n    let note = get_note_internal(storage_slot, note_interface);\n\n    check_note_header(*context, storage_slot, note_interface, note);\n\n    let note_hash_for_read_request = compute_note_hash_for_read_or_nullify(note_interface, note);\n\n    context.push_read_request(note_hash_for_read_request);\n    note\n}\n\npub fn get_notes<Note, N, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    note_interface: NoteInterface<Note, N>,\n    options: NoteGetterOptions<Note, N, FILTER_ARGS>\n) -> [Option<Note>; MAX_READ_REQUESTS_PER_CALL] {\n    let opt_notes = get_notes_internal(storage_slot, note_interface, options);\n    let mut num_notes = 0;\n    let mut prev_fields = [0; N];\n    for i in 0..opt_notes.len() {\n        let opt_note = opt_notes[i];\n        if opt_note.is_some() {\n            let note = opt_note.unwrap_unchecked();\n            let serialize = note_interface.serialize;\n            let fields = serialize(note);\n            check_note_header(*context, storage_slot, note_interface, note);\n            check_note_fields(fields, options.selects);\n            if i != 0 {\n                check_notes_order(prev_fields, fields, options.sorts);\n            }\n            prev_fields = fields;\n\n            let note_hash_for_read_request = compute_note_hash_for_read_or_nullify(note_interface, note);\n            // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1410): test to ensure\n            // failure if malicious oracle injects 0 nonce here for a \"pre-existing\" note.\n            context.push_read_request(note_hash_for_read_request);\n\n            num_notes += 1;\n        };\n    }\n    if options.limit != 0 {\n        assert(num_notes <= options.limit, \"Invalid number of return notes.\");\n    }\n    opt_notes\n}\n\nunconstrained fn get_note_internal<Note, N>(storage_slot: Field, note_interface: NoteInterface<Note, N>) -> Note {\n    let placeholder_note = [Option::none()];\n    let placeholder_fields = [0; GET_NOTE_ORACLE_RETURN_LENGTH];\n    oracle::notes::get_notes(storage_slot,\n        note_interface,\n        0,\n        [],\n        [],\n        [],\n        [],\n        1, // limit\n        0, // offset\n        placeholder_note,\n        placeholder_fields)[0].unwrap() // Notice: we don't allow dummies to be returned from get_note (singular).\n}\n\nunconstrained fn get_notes_internal<Note, N, FILTER_ARGS>(\n    storage_slot: Field,\n    note_interface: NoteInterface<Note, N>,\n    options: NoteGetterOptions<Note, N, FILTER_ARGS>\n) -> [Option<Note>; MAX_READ_REQUESTS_PER_CALL] {\n    let (num_selects, select_by, select_values, sort_by, sort_order) = flatten_options(options.selects, options.sorts);\n    let placeholder_opt_notes = [Option::none(); MAX_READ_REQUESTS_PER_CALL];\n    let placeholder_fields = [0; GET_NOTES_ORACLE_RETURN_LENGTH];\n    let opt_notes = oracle::notes::get_notes(storage_slot,\n        note_interface,\n        num_selects,\n        select_by,\n        select_values,\n        sort_by,\n        sort_order,\n        options.limit,\n        options.offset,\n        placeholder_opt_notes,\n        placeholder_fields);\n\n    let filter = options.filter;\n    let filter_args = options.filter_args;\n    filter(opt_notes, filter_args)\n}\n\nunconstrained pub fn view_notes<Note, N>(storage_slot: Field, note_interface: NoteInterface<Note, N>, options: NoteViewerOptions<Note, N>) -> [Option<Note>; MAX_NOTES_PER_PAGE] {\n    let (num_selects, select_by, select_values, sort_by, sort_order) = flatten_options(options.selects, options.sorts);\n    let placeholder_opt_notes = [Option::none(); MAX_NOTES_PER_PAGE];\n    let placeholder_fields = [0; VIEW_NOTE_ORACLE_RETURN_LENGTH];\n    oracle::notes::get_notes(storage_slot,\n        note_interface,\n        num_selects,\n        select_by,\n        select_values,\n        sort_by,\n        sort_order,\n        options.limit,\n        options.offset,\n        placeholder_opt_notes,\n        placeholder_fields)\n}\n\nunconstrained fn flatten_options<Note, N>(selects: BoundedVec<Option<Select>, N>, sorts: BoundedVec<Option<Sort>, N>) -> (u8, [u8; N], [Field; N], [u8; N], [u2; N]) {\n    let mut num_selects = 0;\n    let mut select_by = [0; N];\n    let mut select_values = [0; N];\n    for i in 0..selects.len {\n        let select = selects.get(i);\n        if select.is_some() {\n            select_by[num_selects] = select.unwrap_unchecked().field_index;\n            select_values[num_selects] = select.unwrap_unchecked().value;\n            num_selects += 1;\n        };\n    }\n\n    let mut sort_by = [0; N];\n    let mut sort_order = [0; N];\n    for i in 0..sorts.len {\n        let sort = sorts.get(i);\n        if sort.is_some() {\n            sort_by[i] = sort.unwrap_unchecked().field_index;\n            sort_order[i] = sort.unwrap_unchecked().order;\n        };\n    }\n\n    (num_selects, select_by, select_values, sort_by, sort_order)\n}\n",
                "path": "/aztec/note/note_getter.nr"
            },
            "112": {
                "source": "use crate::hash::pedersen_hash;\nuse dep::protocol_types::constants::{GENERATOR_INDEX__UNIQUE_COMMITMENT, GENERATOR_INDEX__SILOED_COMMITMENT};\n\npub fn compute_inner_hash(storage_slot: Field, note_hash: Field) -> Field {\n    // TODO(#1205) Do we need a generator index here?\n    pedersen_hash([storage_slot, note_hash], 0)\n}\n\npub fn compute_siloed_hash(contract_address: Field, inner_note_hash: Field) -> Field {\n    let inputs = [contract_address, inner_note_hash];\n    pedersen_hash(inputs, GENERATOR_INDEX__SILOED_COMMITMENT)\n}\n\npub fn compute_unique_hash(nonce: Field, siloed_note_hash: Field) -> Field {\n    let inputs = [nonce, siloed_note_hash];\n    pedersen_hash(inputs, GENERATOR_INDEX__UNIQUE_COMMITMENT)\n}\n",
                "path": "/aztec/note/note_hash.nr"
            },
            "116": {
                "source": "use dep::protocol_types::constants::GENERATOR_INDEX__OUTER_NULLIFIER;\nuse crate::{\n    note::{\n        note_hash::{compute_inner_hash, compute_siloed_hash, compute_unique_hash},\n        note_header::NoteHeader,\n        note_interface::NoteInterface,\n    },\n    utils::arr_copy_slice,\n    hash::pedersen_hash,\n};\n\npub fn compute_inner_note_hash<Note, N>(note_interface: NoteInterface<Note, N>, note: Note) -> Field {\n    let get_header = note_interface.get_header;\n    let header = get_header(note);\n\n    let compute_note_hash = note_interface.compute_note_hash;\n    let note_hash = compute_note_hash(note);\n\n    compute_inner_hash(header.storage_slot, note_hash)\n}\n\npub fn compute_siloed_note_hash<Note, N>(note_interface: NoteInterface<Note, N>, note_with_header: Note) -> Field {\n    let get_header = note_interface.get_header;\n    let header = get_header(note_with_header);\n\n    let inner_note_hash = compute_inner_note_hash(note_interface, note_with_header);\n\n    compute_siloed_hash(header.contract_address, inner_note_hash)\n}\n\npub fn compute_unique_siloed_note_hash<Note, N>(note_interface: NoteInterface<Note, N>, note_with_header: Note) -> Field {\n    let get_header = note_interface.get_header;\n    let header = get_header(note_with_header);\n\n    let siloed_note_hash = compute_siloed_note_hash(note_interface, note_with_header);\n\n    compute_unique_hash(header.nonce, siloed_note_hash)\n}\n\npub fn compute_siloed_nullifier<Note, N>(note_interface: NoteInterface<Note, N>, note_with_header: Note) -> Field {\n    let get_header = note_interface.get_header;\n    let header = get_header(note_with_header);\n\n    let compute_nullifier = note_interface.compute_nullifier;\n    let inner_nullifier = compute_nullifier(note_with_header);\n\n    let input = [header.contract_address, inner_nullifier];\n    pedersen_hash(input, GENERATOR_INDEX__OUTER_NULLIFIER)\n}\n\npub fn compute_note_hash_for_read_or_nullify<Note, N>(note_interface: NoteInterface<Note, N>, note_with_header: Note) -> Field {\n    let get_header = note_interface.get_header;\n    let header = get_header(note_with_header);\n\n    // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1386)\n    if (header.is_transient) {\n        // If a note is transient, we just read the inner_note_hash (kernel will silo by contract address).\n        compute_inner_note_hash(note_interface, note_with_header)\n    } else if (header.nonce == 0) {\n        // If not transient and nonce is zero, that means we are reading a public note.\n        compute_siloed_note_hash(note_interface, note_with_header)\n    } else {\n        // When nonce is nonzero, that means we are reading a settled note (from tree) created in a\n        // previous TX. So we need the unique_siloed_note_hash which has already been hashed with\n        // contract address and then nonce. This hash will match the existing leaf in the private\n        // data tree, so the kernel can just perform a membership check directly on this hash/leaf.\n        compute_unique_siloed_note_hash(note_interface, note_with_header)\n    }\n}\n\npub fn compute_note_hash_and_nullifier<Note, N, S>(note_interface: NoteInterface<Note, N>, note_header: NoteHeader, serialized_note: [Field; S]) -> [Field; 4] {\n    let deserialize = note_interface.deserialize;\n    let set_header = note_interface.set_header;\n    let mut note = deserialize(arr_copy_slice(serialized_note, [0; N], 0));\n    set_header(&mut note, note_header);\n\n    let compute_note_hash = note_interface.compute_note_hash;\n    let note_hash = compute_note_hash(note);\n    let inner_note_hash = compute_inner_hash(note_header.storage_slot, note_hash);\n\n    let siloed_note_hash = compute_siloed_hash(note_header.contract_address, inner_note_hash);\n\n    let unique_siloed_note_hash = compute_unique_hash(note_header.nonce, siloed_note_hash);\n\n    let compute_nullifier = note_interface.compute_nullifier;\n    let inner_nullifier = compute_nullifier(note);\n\n    [inner_note_hash, siloed_note_hash, unique_siloed_note_hash, inner_nullifier]\n}\n",
                "path": "/aztec/note/utils.nr"
            },
            "125": {
                "source": "use crate::types::point::Point;\nuse crate::address::compute_address;\n\n#[oracle(getPublicKeyAndPartialAddress)]\nfn get_public_key_and_partial_address_oracle(_address: Field) -> [Field; 3] {}\n\nunconstrained fn get_public_key_and_partial_address_internal(address: Field) -> [Field; 3] {\n    get_public_key_and_partial_address_oracle(address)\n}\n\npub fn get_public_key(address: Field) -> Point {\n    let result = get_public_key_and_partial_address_internal(address);\n    let pub_key_x = result[0];\n    let pub_key_y = result[1];\n    let partial_address = result[2];\n\n    let calculated_address = compute_address(pub_key_x, pub_key_y, partial_address);\n    assert(calculated_address == address);\n\n    Point::new(pub_key_x, pub_key_y)\n}\n",
                "path": "/aztec/oracle/get_public_key.nr"
            },
            "126": {
                "source": "use crate::oracle::get_public_key::get_public_key;\nuse crate::types::point::Point;\n\n#[oracle(getSecretKey)]\nfn get_secret_key_oracle(_owner: Point) -> [Field; dep::std::grumpkin_scalar::GRUMPKIN_SCALAR_SERIALIZED_LEN] {}\n\nunconstrained fn get_secret_key_internal(owner_public_key: Point) -> dep::std::grumpkin_scalar::GrumpkinScalar {\n    dep::std::grumpkin_scalar::deserialize_grumpkin_scalar(get_secret_key_oracle(owner_public_key))\n}\n\npub fn get_secret_key(owner: Field) -> dep::std::grumpkin_scalar::GrumpkinScalar {\n    let owner_public_key = get_public_key(owner);\n    let secret = get_secret_key_internal(owner_public_key);\n\n    // Constrain the owner - Nullifier secret key is currently just the encryption private key so we can constrain\n    // the owner by deriving the public key from the secret key and checking the result.\n    let computed_public_key = dep::std::grumpkin_scalar_mul::grumpkin_fixed_base(secret);\n    assert(owner_public_key.x == computed_public_key[0]);\n    assert(owner_public_key.y == computed_public_key[1]);\n\n    secret\n}\n",
                "path": "/aztec/oracle/get_secret_key.nr"
            },
            "128": {
                "source": "#[oracle(getRandomField)]\nfn rand_oracle() -> Field {}\n\nunconstrained pub fn rand() -> Field {\n    rand_oracle()\n}\n",
                "path": "/aztec/oracle/rand.nr"
            },
            "132": {
                "source": "use dep::std::option::Option;\nuse crate::note::{\n    note_header::NoteHeader,\n    note_interface::NoteInterface,\n};\nuse crate::utils::arr_copy_slice;\n\n#[oracle(notifyCreatedNote)]\nfn notify_created_note_oracle<N>(_storage_slot: Field, _serialized_note: [Field; N], _inner_note_hash: Field) -> Field {}\n\nunconstrained pub fn notify_created_note<N>(storage_slot: Field, serialized_note: [Field; N], inner_note_hash: Field) -> Field {\n    notify_created_note_oracle(storage_slot, serialized_note, inner_note_hash)\n}\n\n#[oracle(notifyNullifiedNote)]\nfn notify_nullified_note_oracle<N>(_nullifier: Field, _inner_note_hash: Field) -> Field {}\n\nunconstrained pub fn notify_nullified_note<N>(nullifier: Field, inner_note_hash: Field) -> Field {\n    notify_nullified_note_oracle(nullifier, inner_note_hash)\n}\n\n#[oracle(getNotes)]\nfn get_notes_oracle<N, S>(\n    _storage_slot: Field,\n    _num_selects: u8,\n    _select_by: [u8; N],\n    _select_values: [Field; N],\n    _sort_by: [u8; N],\n    _sort_order: [u2; N],\n    _limit: u32,\n    _offset: u32,\n    _return_size: u32,\n    _placeholder_fields: [Field; S]\n) -> [Field; S] {}\n\nunconstrained fn get_notes_oracle_wrapper<N, S>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by: [u8; N],\n    select_values: [Field; N],\n    sort_by: [u8; N],\n    sort_order: [u2; N],\n    limit: u32,\n    offset: u32,\n    mut placeholder_fields: [Field; S]\n) -> [Field; S] {\n    let return_size = placeholder_fields.len() as u32;\n    get_notes_oracle(storage_slot,\n        num_selects,\n        select_by,\n        select_values,\n        sort_by,\n        sort_order,\n        limit,\n        offset,\n        return_size,\n        placeholder_fields)\n}\n\nunconstrained pub fn get_notes<Note, N, M, S, NS>(\n    storage_slot: Field,\n    note_interface: NoteInterface<Note, N>,\n    num_selects: u8,\n    select_by: [u8; M],\n    select_values: [Field; M],\n    sort_by: [u8; M],\n    sort_order: [u2; M],\n    limit: u32,\n    offset: u32,\n    mut placeholder_opt_notes: [Option<Note>; S], // TODO: Remove it and use `limit` to initialize the note array.\n    placeholder_fields: [Field; NS] // TODO: Remove it and use `limit` to initialize the note array.\n) -> [Option<Note>; S] {\n    let fields = get_notes_oracle_wrapper(storage_slot,\n        num_selects,\n        select_by,\n        select_values,\n        sort_by,\n        sort_order,\n        limit,\n        offset,\n        placeholder_fields);\n    let num_notes = fields[0] as u32;\n    let contract_address = fields[1];\n    let deserialize = note_interface.deserialize;\n    let set_header = note_interface.set_header;\n    for i in 0..placeholder_opt_notes.len() {\n        if i as u32 < num_notes {\n            // lengths named as per typescript.\n            let return_header_length: Field = 2; // num_notes & contract_address.\n            let extra_preimage_length: Field = 2; // nonce & is_transient.\n            let read_offset: Field = return_header_length + i * (N + extra_preimage_length);\n            let nonce = fields[read_offset];\n            let is_transient = fields[read_offset + 1] as bool;\n            let header = NoteHeader { contract_address, nonce, storage_slot, is_transient };\n            let serialized_note = arr_copy_slice(fields, [0; N], read_offset + 2);\n            let mut note = deserialize(serialized_note);\n            set_header(&mut note, header);\n            placeholder_opt_notes[i] = Option::some(note);\n        };\n    }\n    placeholder_opt_notes\n}\n\n#[oracle(checkNullifierExists)]\nfn check_nullifier_exists_oracle(_inner_nullifier: Field) -> Field {}\n\nunconstrained pub fn check_nullifier_exists(inner_nullifier: Field) -> bool {\n    check_nullifier_exists_oracle(inner_nullifier) == 1\n}\n",
                "path": "/aztec/oracle/notes.nr"
            },
            "134": {
                "source": "use crate::types::point::Point;\nuse dep::protocol_types::constants::NUM_FIELDS_PER_SHA256;\n\n// TODO: Should take encrypted data.\n#[oracle(emitEncryptedLog)]\nfn emit_encrypted_log_oracle<N>(_contract_address: Field, _storage_slot: Field, _encryption_pub_key: Point, _preimage: [Field; N]) -> Field {}\n\nunconstrained pub fn emit_encrypted_log<N>(contract_address: Field, storage_slot: Field, encryption_pub_key: Point, preimage: [Field; N]) -> [Field; NUM_FIELDS_PER_SHA256] {\n    [emit_encrypted_log_oracle(contract_address, storage_slot, encryption_pub_key, preimage), 0]\n}\n\n#[oracle(emitUnencryptedLog)]\nfn emit_unencrypted_log_oracle<T>(_contract_address: Field, _event_selector: Field, _message: T) -> Field {}\n\nunconstrained pub fn emit_unencrypted_log<T>(contract_address: Field, event_selector: Field, message: T) -> [Field; NUM_FIELDS_PER_SHA256] {\n    // https://github.com/AztecProtocol/aztec-packages/issues/885\n    [emit_unencrypted_log_oracle(contract_address, event_selector, message), 0]\n}\n",
                "path": "/aztec/oracle/logs.nr"
            },
            "140": {
                "source": "use crate::context::{PrivateContext, PublicContext, Context};\nuse dep::std::option::Option;\nuse crate::hash::pedersen_hash;\n\n// docs:start:map\nstruct Map<V> {\n    context: Context,\n    storage_slot: Field,\n    state_var_constructor: fn(Context, Field) -> V,\n}\n// docs:end:map\n\nimpl<V> Map<V> {\n    // docs:start:new\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        state_var_constructor: fn(Context, Field) -> V,\n    ) -> Map<V> {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map {\n            context,\n            storage_slot,\n            state_var_constructor,\n        }\n    }\n    // docs:end:new\n\n    // docs:start:at\n    pub fn at(self, key: Field) -> V {\n        // TODO(#1204): use a generator index for the storage slot\n        let derived_storage_slot = pedersen_hash([self.storage_slot, key],0);\n\n        let state_var_constructor = self.state_var_constructor;\n        state_var_constructor(self.context, derived_storage_slot)\n    }\n    // docs:end:at\n}\n",
                "path": "/aztec/state_vars/map.nr"
            },
            "142": {
                "source": "use dep::std::option::Option;\nuse crate::abi::PublicContextInputs;\nuse dep::protocol_types::constants::{MAX_NOTES_PER_PAGE, MAX_READ_REQUESTS_PER_CALL};\nuse crate::context::{PrivateContext, PublicContext, Context};\nuse crate::note::{\n    lifecycle::{create_note, create_note_hash_from_public, destroy_note},\n    note_getter::{get_notes, view_notes},\n    note_getter_options::NoteGetterOptions,\n    note_header::NoteHeader,\n    note_interface::NoteInterface,\n    note_viewer_options::NoteViewerOptions,\n    utils::compute_note_hash_for_read_or_nullify,\n};\n\n// docs:start:struct\nstruct Set<Note, N> {\n    context: Context,\n    storage_slot: Field,\n    note_interface: NoteInterface<Note, N>,\n}\n// docs:end:struct\n\nimpl<Note, N> Set<Note, N> {\n    // docs:start:new\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        note_interface: NoteInterface<Note, N>,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Set {\n            context,\n            storage_slot,\n            note_interface,\n        }\n    }\n    // docs:end:new\n\n    // docs:start:insert\n    pub fn insert(self,\n        note: &mut Note,\n        broadcast: bool,\n    ) {\n        create_note(\n            self.context.private.unwrap(),\n            self.storage_slot,\n            note,\n            self.note_interface,\n            broadcast,\n        );\n    }\n    // docs:end:insert\n\n    // docs:start:insert_from_public\n    pub fn insert_from_public(self, note: &mut Note) {\n        create_note_hash_from_public(\n            self.context.public.unwrap(),\n            self.storage_slot,\n            note,\n            self.note_interface,\n        );\n    }\n    // docs:end:insert_from_public\n    \n    // DEPRECATED\n    fn assert_contains_and_remove(_self: Self, _note: &mut Note, _nonce: Field) {\n        assert(false, \"`assert_contains_and_remove` has been deprecated. Please call PXE.addNote() to add a note to the database. Then use Set.get_notes() and Set.remove() in your contract to verify and remove a note.\");\n    }\n\n    // DEPRECATED\n    fn assert_contains_and_remove_publicly_created(_self: Self, _note: &mut Note) {\n        assert(false, \"`assert_contains_and_remove_publicly_created` has been deprecated. Please call PXE.addNote() to add a note to the database. Then use Set.get_notes() and Set.remove() in your contract to verify and remove a note.\");\n    }\n\n    // docs:start:remove\n    pub fn remove(self, note: Note) {\n        let context = self.context.private.unwrap();\n        let note_hash = compute_note_hash_for_read_or_nullify(self.note_interface, note);\n        let has_been_read = context.read_requests.any(|r| r == note_hash);\n        assert(has_been_read, \"Can only remove a note that has been read from the set.\");\n\n        destroy_note(\n            context,\n            note,\n            self.note_interface,\n        );\n    }\n    // docs:end:remove\n\n    // docs:start:get_notes\n    pub fn get_notes<FILTER_ARGS>(\n        self,\n        options: NoteGetterOptions<Note, N, FILTER_ARGS>,\n    ) -> [Option<Note>; MAX_READ_REQUESTS_PER_CALL] {\n        let storage_slot = self.storage_slot;\n        let opt_notes = get_notes(\n            self.context.private.unwrap(),\n            storage_slot,\n            self.note_interface,\n            options,\n        );\n        opt_notes\n    }\n    // docs:end:get_notes\n\n    // docs:start:view_notes\n    unconstrained pub fn view_notes(\n        self,\n        options: NoteViewerOptions<Note, N>,\n    ) -> [Option<Note>; MAX_NOTES_PER_PAGE] {\n        view_notes(self.storage_slot, self.note_interface, options)\n    }\n    // docs:end:view_notes\n}\n",
                "path": "/aztec/state_vars/set.nr"
            },
            "147": {
                "source": "struct BoundedVec<T, MaxLen> {\n    storage: [T; MaxLen],\n    len: Field,\n}\n\nimpl<T, MaxLen> BoundedVec<T, MaxLen> {\n    pub fn new(initial_value: T) -> Self {\n        BoundedVec { storage: [initial_value; MaxLen], len: 0 }\n    }\n\n    pub fn get(mut self: Self, index: Field) -> T {\n        assert(index as u64 < self.len as u64);\n        self.storage[index]\n    }\n\n    pub fn get_unchecked(mut self: Self, index: Field) -> T {\n        self.storage[index]\n    }\n\n    pub fn push(&mut self, elem: T) {\n        assert(self.len as u64 < MaxLen as u64);\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    pub fn push_array<Len>(&mut self, array: [T; Len]) {\n        let newLen = self.len + array.len();\n        assert(newLen as u64 <= MaxLen as u64);\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = newLen;\n    }\n\n    pub fn pop(&mut self) -> T {\n        assert(self.len as u64 > 0);\n\n        let elem = self.storage[self.len - 1];\n        self.len -= 1;\n        elem\n    }\n\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        let mut exceeded_len = false;\n        for i in 0..MaxLen {\n            exceeded_len |= i == self.len;\n            if (!exceeded_len) {\n                ret |= predicate(self.storage[i]);\n            }\n        }\n        ret\n    }\n}\n\n#[test]\nfn test_vec_push_pop() {\n    let mut vec: BoundedVec<Field, 3> = BoundedVec::new(0);\n    assert(vec.len == 0);\n    vec.push(2);\n    assert(vec.len == 1);\n    vec.push(4);\n    assert(vec.len == 2);\n    vec.push(6);\n    assert(vec.len == 3);\n    let x = vec.pop();\n    assert(x == 6);\n    assert(vec.len == 2);\n    assert(vec.get(0) == 2);\n    assert(vec.get(1) == 4);\n}\n\n#[test]\nfn test_vec_push_array() {\n    let mut vec: BoundedVec<Field, 3> = BoundedVec::new(0);\n    vec.push_array([2, 4]);\n    assert(vec.len == 2);\n    assert(vec.get(0) == 2);\n    assert(vec.get(1) == 4);\n}\n\n#[test(should_fail)]\nfn test_vec_get_out_of_bound() {\n    let mut vec: BoundedVec<Field, 2> = BoundedVec::new(0);\n    vec.push_array([2, 4]);\n    let _x = vec.get(2);\n}\n\n#[test(should_fail)]\nfn test_vec_get_not_declared() {\n    let mut vec: BoundedVec<Field, 2> = BoundedVec::new(0);\n    vec.push_array([2]);\n    let _x = vec.get(1);\n}\n\n#[test(should_fail)]\nfn test_vec_get_uninitialized() {\n    let mut vec: BoundedVec<Field, 2> = BoundedVec::new(0);\n    let _x = vec.get(0);\n}\n\n#[test(should_fail)]\nfn test_vec_push_overflow() {\n    let mut vec: BoundedVec<Field, 1> = BoundedVec::new(0);\n    vec.push(1);\n    vec.push(2);\n}\n\n#[test]\nfn test_vec_any() {\n    let mut vec: BoundedVec<Field, 3> = BoundedVec::new(0);\n    vec.push_array([2, 4, 6]);\n    assert(vec.any(|v| v == 2) == true);\n    assert(vec.any(|v| v == 4) == true);\n    assert(vec.any(|v| v == 6) == true);\n    assert(vec.any(|v| v == 3) == false);\n}\n\n#[test]\nfn test_vec_any_not_default() {\n    let default_value = 1;\n    let mut vec: BoundedVec<Field, 3> = BoundedVec::new(default_value);\n    vec.push_array([2, 4]);\n    assert(vec.any(|v| v == default_value) == false);\n}\n",
                "path": "/aztec/types/vec.nr"
            },
            "153": {
                "source": "pub fn arr_copy_slice<T, N, M>(src: [T; N], mut dst: [T; M], offset: Field) -> [T; M] {\n    for i in 0..dst.len() {\n        dst[i] = src[i + offset];\n    }\n    dst\n}\n\npub fn field_from_bytes<N>(bytes: [u8; N], big_endian: bool) -> Field {\n    assert(bytes.len() as u32 < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        let mut index = i;\n        if big_endian {\n            index = N - i - 1;\n        }\n        as_field += (bytes[index] as Field) * offset;\n        offset *= 256;\n    }\n\n    as_field\n}\n\n// TODO(#3470): Copied over from https://github.com/AztecProtocol/aztec-packages/blob/a07c4bd47313be6aa604a63f37857eb0136b41ba/yarn-project/noir-protocol-circuits/src/crates/rollup-lib/src/base/base_rollup_inputs.nr#L599\n// move to a shared place?\n\n// TODO to radix returns u8, so we cannot use bigger radixes. It'd be ideal to use a radix of the maximum range-constrained integer noir supports\npub fn full_field_less_than(lhs: Field, rhs: Field) -> bool {\n    dep::std::eddsa::lt_bytes32(lhs, rhs)\n}\n\npub fn full_field_greater_than(lhs: Field, rhs: Field) -> bool {\n    dep::std::eddsa::lt_bytes32(rhs, lhs)\n}",
                "path": "/aztec/utils.nr"
            },
            "154": {
                "source": "use dep::aztec::note::{\n    note_getter::view_notes,\n    note_viewer_options::NoteViewerOptions,\n};\nuse dep::aztec::state_vars::set::Set;\nuse crate::value_note::{VALUE_NOTE_LEN, ValueNote};\n\nunconstrained pub fn get_balance(set: Set<ValueNote, VALUE_NOTE_LEN>) -> Field {\n    get_balance_with_offset(set, 0)\n}\n\nunconstrained pub fn get_balance_with_offset(set: Set<ValueNote, VALUE_NOTE_LEN>, offset: u32) -> Field {\n    let mut balance = 0;\n    // docs:start:view_notes\n    let options = NoteViewerOptions::new().set_offset(offset);\n    let opt_notes = set.view_notes(options);\n    // docs:end:view_notes\n    let len = opt_notes.len();\n    for i in 0..len {\n        if opt_notes[i].is_some() {\n            balance += opt_notes[i].unwrap_unchecked().value;\n        }\n    }\n    if (opt_notes[len - 1].is_some()) {\n        balance += get_balance_with_offset(set, offset + opt_notes.len() as u32);\n    }\n\n    balance\n}\n",
                "path": "/value_note/balance_utils.nr"
            },
            "157": {
                "source": "use dep::aztec::{\n    note::{\n        note_header::NoteHeader,\n        note_interface::NoteInterface,\n        utils::compute_note_hash_for_read_or_nullify,\n    },\n    oracle::{\n        rand::rand,\n        get_secret_key::get_secret_key,\n        get_public_key::get_public_key,\n    },\n    log::emit_encrypted_log,\n    hash::pedersen_hash,\n    context::PrivateContext,\n};\n\nglobal VALUE_NOTE_LEN: Field = 3; // 3 plus a header.\n\n// docs:start:value-note-def\nstruct ValueNote {\n    value: Field,\n    owner: Field,\n    randomness: Field,\n    header: NoteHeader,\n}\n// docs:end:value-note-def\n\nimpl ValueNote {\n    pub fn new(value: Field, owner: Field) -> Self {\n        let randomness = rand();\n        let header = NoteHeader::empty();\n        ValueNote {\n            value,\n            owner,\n            randomness,\n            header,\n        }\n    }\n\n    pub fn serialize(self) -> [Field; VALUE_NOTE_LEN] {\n        [self.value, self.owner, self.randomness]\n    }\n\n    pub fn deserialize(serialized_note: [Field; VALUE_NOTE_LEN]) -> Self {\n        ValueNote {\n            value: serialized_note[0],\n            owner: serialized_note[1],\n            randomness: serialized_note[2],\n            header: NoteHeader::empty(),\n        }\n    }\n\n    pub fn compute_note_hash(self) -> Field {\n        // TODO(#1205) Should use a non-zero generator index.\n        pedersen_hash(self.serialize(),0)\n    }\n\n    // docs:start:nullifier\n\n    pub fn compute_nullifier(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_read_or_nullify(ValueNoteMethods, self);\n        let secret = get_secret_key(self.owner);\n        // TODO(#1205) Should use a non-zero generator index.\n        pedersen_hash([\n            note_hash_for_nullify,\n            secret.low,\n            secret.high,\n        ],0)\n    }\n\n    // docs:end:nullifier\n\n    pub fn set_header(&mut self, header: NoteHeader) {\n        self.header = header;\n    }\n\n    // Broadcasts the note as an encrypted log on L1.\n    pub fn broadcast(self, context: &mut PrivateContext, slot: Field) {\n        let encryption_pub_key = get_public_key(self.owner);\n        emit_encrypted_log(\n            context,\n            (*context).this_address(),\n            slot,\n            encryption_pub_key,\n            self.serialize(),\n        );\n    }\n}\n\nfn deserialize(serialized_note: [Field; VALUE_NOTE_LEN]) -> ValueNote {\n    ValueNote::deserialize(serialized_note)\n}\n\nfn serialize(note: ValueNote) -> [Field; VALUE_NOTE_LEN] {\n    note.serialize()\n}\n\nfn compute_note_hash(note: ValueNote) -> Field {\n    note.compute_note_hash()\n}\n\nfn compute_nullifier(note: ValueNote) -> Field {\n    note.compute_nullifier()\n}\n\nfn get_header(note: ValueNote) -> NoteHeader {\n    note.header\n}\n\nfn set_header(note: &mut ValueNote, header: NoteHeader) {\n    note.set_header(header)\n}\n\n// Broadcasts the note as an encrypted log on L1.\nfn broadcast(context: &mut PrivateContext, slot: Field, note: ValueNote) {\n    note.broadcast(context, slot);\n}\n\nglobal ValueNoteMethods = NoteInterface {\n    deserialize,\n    serialize,\n    compute_note_hash,\n    compute_nullifier,\n    get_header,\n    set_header,\n    broadcast,\n};\n",
                "path": "/value_note/value_note.nr"
            },
            "158": {
                "source": "use dep::aztec::{\n    context::Context,\n    note::note_getter_options::NoteGetterOptions,\n    state_vars::set::Set,\n};\nuse dep::value_note::{\n    filter::filter_notes_min_sum,\n    value_note::{ValueNote, ValueNoteMethods, VALUE_NOTE_LEN},\n};\n\nstruct EasyPrivateUint {\n    context: Context,\n    set: Set<ValueNote, VALUE_NOTE_LEN>,\n    storage_slot: Field,\n}\n\nimpl EasyPrivateUint {\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        let set = Set {\n            context,\n            storage_slot,\n            note_interface: ValueNoteMethods,\n        };\n        EasyPrivateUint {\n            context,\n            set,\n            storage_slot,\n        }\n    }\n\n    // Very similar to `value_note::utils::increment`.\n    pub fn add(self, addend: u120, owner: Field) {\n        // Creates new note for the owner.\n        let mut addend_note = ValueNote::new(addend as Field, owner);\n\n        // Insert the new note to the owner's set of notes.\n        // docs:start:insert\n        self.set.insert(&mut addend_note, true);\n        // docs:end:insert\n    }\n\n    // Very similar to `value_note::utils::decrement`.\n    pub fn sub(self, subtrahend: u120, owner: Field) {\n        // docs:start:get_notes\n        let options = NoteGetterOptions::with_filter(filter_notes_min_sum, subtrahend as Field);\n        let maybe_notes = self.set.get_notes(options);\n        // docs:end:get_notes\n\n        let mut minuend: u120 = 0;\n        for i in 0..maybe_notes.len() {\n            if maybe_notes[i].is_some() {\n                let note = maybe_notes[i].unwrap_unchecked();\n\n                // Ensure the notes are actually owned by the owner (to prevent user from generating a valid proof while\n                // spending someone else's notes).\n                assert(note.owner == owner);\n\n                // Removes the note from the owner's set of notes.\n                // docs:start:remove\n                self.set.remove(note);\n                // docs:end:remove\n\n                minuend += note.value as u120;\n            }\n        }\n\n        assert(minuend >= subtrahend);\n\n        // Creates change note for the owner.\n        let result_value = minuend - subtrahend;\n        let mut result_note = ValueNote::new(result_value as Field, owner);\n        self.set.insert(&mut result_note, result_value != 0);\n    }\n}\n",
                "path": "/easy_private_state/easy_private_state.nr"
            }
        }
    }
}
